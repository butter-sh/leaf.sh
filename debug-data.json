{
  "page_title": "whip.sh - Documentation",
  "page_description": "Release cycle management for arty.sh projects",
  "base_path": "/",
  "project_name": "whip.sh",
  "project_version": "1.0.0",
  "project_description": "Release cycle management for arty.sh projects",
  "icon": "<svg class=\"w-full h-full\" fill=\"currentColor\" viewBox=\"0 0 24 24\"><path d=\"M13 2L3 14h9l-1 8 10-12h-9l1-8z\"/></svg>",
  "readme_content": "# whip.sh\n\nRelease cycle management for arty.sh projects with semantic versioning, changelog generation, git hooks, and monorepo support.\n\n## Features\n\n- **Semantic Versioning**: Automatic version bumping (major, minor, patch)\n- **Changelog Generation**: Create changelogs from git commit history\n- **Git Tag Management**: Create and push annotated git tags\n- **Commit Hooks**: Install pluggable git hooks with bash validation\n- **Monorepo Support**: Batch operations on multiple arty.yml projects\n- **arty.yml Integration**: Seamlessly integrates with arty.sh ecosystem\n\n## Installation\n\n### Using hammer.sh\n\n```bash\nhammer.sh whip my-project\ncd my-project\nbash setup.sh\n```\n\n### Manual Installation\n\n```bash\ngit clone <repository-url>\ncd whip.sh\nchmod +x whip.sh\n```\n\n## Quick Start\n\n```bash\n# Initialize (if in existing project)\n# Just ensure you have an arty.yml file\n\n# Install commit hooks for code quality\n./whip.sh hooks install\n\n# Create a patch release (bumps 1.0.0 -> 1.0.1)\n./whip.sh release\n\n# Create a minor release (bumps 1.0.0 -> 1.1.0)\n./whip.sh release minor\n\n# Create a major release (bumps 1.0.0 -> 2.0.0)\n./whip.sh release major\n```\n\n## Usage\n\n### Release Commands\n\nCreate a full release with version bump, changelog update, and git tag:\n\n```bash\n# Patch release (default)\n./whip.sh release\n\n# Minor release\n./whip.sh release minor\n\n# Major release\n./whip.sh release major\n\n# Release without pushing\n./whip.sh release --no-push\n```\n\nThe release process:\n1. Bumps version in arty.yml according to semver\n2. Generates/updates CHANGELOG.md from git commits\n3. Creates a git commit with version changes\n4. Creates an annotated git tag (e.g., v1.2.3)\n5. Pushes commits and tags to remote\n\n### Version Management\n\n```bash\n# Show current version\n./whip.sh version\n\n# Bump version without release\n./whip.sh bump patch\n./whip.sh bump minor\n./whip.sh bump major\n```\n\n### Changelog\n\n```bash\n# Generate changelog from all commits\n./whip.sh changelog\n\n# Generate changelog from specific tag\n./whip.sh changelog v1.0.0\n\n# Generate changelog for range\n./whip.sh changelog v1.0.0 HEAD\n```\n\n### Git Hooks\n\nInstall commit hooks for automatic code validation:\n\n```bash\n# Install hooks\n./whip.sh hooks install\n\n# Uninstall hooks\n./whip.sh hooks uninstall\n\n# Create custom hooks template\n./whip.sh hooks create\n```\n\nBuilt-in validations:\n- **Bash syntax check**: Uses `bash -n` to validate syntax\n- **ShellCheck**: Runs shellcheck if available (optional)\n- **Pluggable**: Add custom hooks to `.whip/hooks/`\n\n### Monorepo Support\n\nManage multiple arty.yml projects in a monorepo structure:\n\n```bash\n# List all arty.yml projects\n./whip.sh mono list\n\n# Show versions of all projects\n./whip.sh mono version\n\n# Bump version for all projects\n./whip.sh mono bump patch\n\n# Filter by glob pattern\n./whip.sh mono version \"lib-*\"\n\n# Show git status for all projects\n./whip.sh mono status\n```\n\nExample monorepo structure:\n```\nmonorepo/\n├── lib-core/\n│   └── arty.yml\n├── lib-utils/\n│   └── arty.yml\n└── app-main/\n    └── arty.yml\n```\n\n## Configuration\n\n### Environment Variables\n\n- `WHIP_CONFIG`: Config file path (default: `arty.yml`)\n- `WHIP_CHANGELOG`: Changelog file path (default: `CHANGELOG.md`)\n\n### Custom Config\n\n```bash\n# Use custom config file\n./whip.sh --config myconfig.yml release\n\n# Use custom changelog file\n./whip.sh --changelog HISTORY.md release\n```\n\n## Integration with arty.sh\n\nwhip.sh is designed to work seamlessly with arty.sh:\n\n```yaml\n# arty.yml\nname: \"my-project\"\nversion: \"1.0.0\"\ndescription: \"My awesome project\"\n\nscripts:\n  release: \"bash whip.sh release\"\n  release-major: \"bash whip.sh release major\"\n  release-minor: \"bash whip.sh release minor\"\n```\n\nThen use via arty:\n\n```bash\narty release        # Patch release\narty release-major  # Major release\narty release-minor  # Minor release\n```\n\n## Custom Hooks\n\nCreate custom hooks in `.whip/hooks/`:\n\n```bash\n# Create hooks directory\nmkdir -p .whip/hooks\n\n# Add custom pre-commit hook\ncat > .whip/hooks/pre-commit << 'EOF'\n#!/usr/bin/env bash\necho \"Running custom checks...\"\n# Your custom validation logic here\nEOF\n\nchmod +x .whip/hooks/pre-commit\n\n# Install hooks\n./whip.sh hooks install\n```\n\n## Examples\n\n### Simple Release Workflow\n\n```bash\n# Make changes and commit\ngit add .\ngit commit -m \"feat: add new feature\"\n\n# Create release\n./whip.sh release patch\n\n# Output:\n# [INFO] Starting release process\n# [INFO] New version: 1.0.1\n# [✓] Updated version to 1.0.1 in arty.yml\n# [✓] Updated CHANGELOG.md\n# [✓] Committed version changes\n# [✓] Created tag: v1.0.1\n# [✓] Pushed tag: v1.0.1\n# [✓] Pushed commits\n# [✓] Release 1.0.1 completed successfully!\n```\n\n### Monorepo Batch Operations\n\n```bash\n# Bump all library projects\n./whip.sh mono bump minor \"lib-*\"\n\n# Output:\n# [→] Scanning for arty.yml projects in .\n# [INFO] Found 2 project(s)\n#\n# ━━━ Processing: lib-core ━━━\n# [✓] Updated version to 1.1.0 in arty.yml\n# Bumped to: 1.1.0\n#\n# ━━━ Processing: lib-utils ━━━\n# [✓] Updated version to 1.1.0 in arty.yml\n# Bumped to: 1.1.0\n#\n# [✓] All projects processed successfully\n```\n\n## Requirements\n\n- bash 4.0+\n- git\n- yq (YAML processor) - [Installation](https://github.com/mikefarah/yq)\n- shellcheck (optional, for pre-commit hooks)\n\n## License\n\nMIT\n\n## Author\n\n&#123;&#123;author&#125;&#125;",
  "readme_content_json": "\"# whip.sh\\n\\nRelease cycle management for arty.sh projects with semantic versioning, changelog generation, git hooks, and monorepo support.\\n\\n## Features\\n\\n- **Semantic Versioning**: Automatic version bumping (major, minor, patch)\\n- **Changelog Generation**: Create changelogs from git commit history\\n- **Git Tag Management**: Create and push annotated git tags\\n- **Commit Hooks**: Install pluggable git hooks with bash validation\\n- **Monorepo Support**: Batch operations on multiple arty.yml projects\\n- **arty.yml Integration**: Seamlessly integrates with arty.sh ecosystem\\n\\n## Installation\\n\\n### Using hammer.sh\\n\\n```bash\\nhammer.sh whip my-project\\ncd my-project\\nbash setup.sh\\n```\\n\\n### Manual Installation\\n\\n```bash\\ngit clone <repository-url>\\ncd whip.sh\\nchmod +x whip.sh\\n```\\n\\n## Quick Start\\n\\n```bash\\n# Initialize (if in existing project)\\n# Just ensure you have an arty.yml file\\n\\n# Install commit hooks for code quality\\n./whip.sh hooks install\\n\\n# Create a patch release (bumps 1.0.0 -> 1.0.1)\\n./whip.sh release\\n\\n# Create a minor release (bumps 1.0.0 -> 1.1.0)\\n./whip.sh release minor\\n\\n# Create a major release (bumps 1.0.0 -> 2.0.0)\\n./whip.sh release major\\n```\\n\\n## Usage\\n\\n### Release Commands\\n\\nCreate a full release with version bump, changelog update, and git tag:\\n\\n```bash\\n# Patch release (default)\\n./whip.sh release\\n\\n# Minor release\\n./whip.sh release minor\\n\\n# Major release\\n./whip.sh release major\\n\\n# Release without pushing\\n./whip.sh release --no-push\\n```\\n\\nThe release process:\\n1. Bumps version in arty.yml according to semver\\n2. Generates/updates CHANGELOG.md from git commits\\n3. Creates a git commit with version changes\\n4. Creates an annotated git tag (e.g., v1.2.3)\\n5. Pushes commits and tags to remote\\n\\n### Version Management\\n\\n```bash\\n# Show current version\\n./whip.sh version\\n\\n# Bump version without release\\n./whip.sh bump patch\\n./whip.sh bump minor\\n./whip.sh bump major\\n```\\n\\n### Changelog\\n\\n```bash\\n# Generate changelog from all commits\\n./whip.sh changelog\\n\\n# Generate changelog from specific tag\\n./whip.sh changelog v1.0.0\\n\\n# Generate changelog for range\\n./whip.sh changelog v1.0.0 HEAD\\n```\\n\\n### Git Hooks\\n\\nInstall commit hooks for automatic code validation:\\n\\n```bash\\n# Install hooks\\n./whip.sh hooks install\\n\\n# Uninstall hooks\\n./whip.sh hooks uninstall\\n\\n# Create custom hooks template\\n./whip.sh hooks create\\n```\\n\\nBuilt-in validations:\\n- **Bash syntax check**: Uses `bash -n` to validate syntax\\n- **ShellCheck**: Runs shellcheck if available (optional)\\n- **Pluggable**: Add custom hooks to `.whip/hooks/`\\n\\n### Monorepo Support\\n\\nManage multiple arty.yml projects in a monorepo structure:\\n\\n```bash\\n# List all arty.yml projects\\n./whip.sh mono list\\n\\n# Show versions of all projects\\n./whip.sh mono version\\n\\n# Bump version for all projects\\n./whip.sh mono bump patch\\n\\n# Filter by glob pattern\\n./whip.sh mono version \\\"lib-*\\\"\\n\\n# Show git status for all projects\\n./whip.sh mono status\\n```\\n\\nExample monorepo structure:\\n```\\nmonorepo/\\n├── lib-core/\\n│   └── arty.yml\\n├── lib-utils/\\n│   └── arty.yml\\n└── app-main/\\n    └── arty.yml\\n```\\n\\n## Configuration\\n\\n### Environment Variables\\n\\n- `WHIP_CONFIG`: Config file path (default: `arty.yml`)\\n- `WHIP_CHANGELOG`: Changelog file path (default: `CHANGELOG.md`)\\n\\n### Custom Config\\n\\n```bash\\n# Use custom config file\\n./whip.sh --config myconfig.yml release\\n\\n# Use custom changelog file\\n./whip.sh --changelog HISTORY.md release\\n```\\n\\n## Integration with arty.sh\\n\\nwhip.sh is designed to work seamlessly with arty.sh:\\n\\n```yaml\\n# arty.yml\\nname: \\\"my-project\\\"\\nversion: \\\"1.0.0\\\"\\ndescription: \\\"My awesome project\\\"\\n\\nscripts:\\n  release: \\\"bash whip.sh release\\\"\\n  release-major: \\\"bash whip.sh release major\\\"\\n  release-minor: \\\"bash whip.sh release minor\\\"\\n```\\n\\nThen use via arty:\\n\\n```bash\\narty release        # Patch release\\narty release-major  # Major release\\narty release-minor  # Minor release\\n```\\n\\n## Custom Hooks\\n\\nCreate custom hooks in `.whip/hooks/`:\\n\\n```bash\\n# Create hooks directory\\nmkdir -p .whip/hooks\\n\\n# Add custom pre-commit hook\\ncat > .whip/hooks/pre-commit << 'EOF'\\n#!/usr/bin/env bash\\necho \\\"Running custom checks...\\\"\\n# Your custom validation logic here\\nEOF\\n\\nchmod +x .whip/hooks/pre-commit\\n\\n# Install hooks\\n./whip.sh hooks install\\n```\\n\\n## Examples\\n\\n### Simple Release Workflow\\n\\n```bash\\n# Make changes and commit\\ngit add .\\ngit commit -m \\\"feat: add new feature\\\"\\n\\n# Create release\\n./whip.sh release patch\\n\\n# Output:\\n# [INFO] Starting release process\\n# [INFO] New version: 1.0.1\\n# [✓] Updated version to 1.0.1 in arty.yml\\n# [✓] Updated CHANGELOG.md\\n# [✓] Committed version changes\\n# [✓] Created tag: v1.0.1\\n# [✓] Pushed tag: v1.0.1\\n# [✓] Pushed commits\\n# [✓] Release 1.0.1 completed successfully!\\n```\\n\\n### Monorepo Batch Operations\\n\\n```bash\\n# Bump all library projects\\n./whip.sh mono bump minor \\\"lib-*\\\"\\n\\n# Output:\\n# [→] Scanning for arty.yml projects in .\\n# [INFO] Found 2 project(s)\\n#\\n# ━━━ Processing: lib-core ━━━\\n# [✓] Updated version to 1.1.0 in arty.yml\\n# Bumped to: 1.1.0\\n#\\n# ━━━ Processing: lib-utils ━━━\\n# [✓] Updated version to 1.1.0 in arty.yml\\n# Bumped to: 1.1.0\\n#\\n# [✓] All projects processed successfully\\n```\\n\\n## Requirements\\n\\n- bash 4.0+\\n- git\\n- yq (YAML processor) - [Installation](https://github.com/mikefarah/yq)\\n- shellcheck (optional, for pre-commit hooks)\\n\\n## License\\n\\nMIT\\n\\n## Author\\n\\n{{author}}\"",
  "github_url": "https://github.com/butter-sh",
  "source_files_html": "<div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">setup.sh</h3><p class=\"text-blue-100 text-sm\">setup.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Setup script for whip.sh\n\nset -euo pipefail\n\necho &quot;Setting up whip.sh...&quot;\n\n# Make whip.sh executable\nchmod +x whip.sh\n\n# Create .whip directory for hooks\nmkdir -p .whip/hooks\n\necho &quot;✓ Setup complete!&quot;\necho &quot;&quot;\necho &quot;Next steps:&quot;\necho &quot;  1. Install git hooks: ./whip.sh hooks install&quot;\necho &quot;  2. Create a release: ./whip.sh release&quot;\necho &quot;  3. See help: ./whip.sh --help&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">snapshot-tool.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/snapshot-tool.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/bin/bash\n\n# Snapshot management utility\n# View, compare, and manage test snapshots\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\n# Use environment variable if set, otherwise default to script directory\nSNAPSHOT_DIR=&quot;${SNAPSHOT_DIR:-${SCRIPT_DIR}/snapshots}&quot;\n\n# Colors for output - only use colors if output is to a terminal or if FORCE_COLOR is set\nexport FORCE_COLOR=${FORCE_COLOR:-&quot;1&quot;}\nif [ &quot;$FORCE_COLOR&quot; = &quot;0&quot; ]; then\n  export RED=&#39;&#39;\n  export GREEN=&#39;&#39;\n  export YELLOW=&#39;&#39;\n  export BLUE=&#39;&#39;\n  export CYAN=&#39;&#39;\n  export MAGENTA=&#39;&#39;\n  export BOLD=&#39;&#39;\n  export NC=&#39;&#39;\nelse\n  export RED=&#39;\\033[0;31m&#39;\n  export GREEN=&#39;\\033[0;32m&#39;\n  export YELLOW=&#39;\\033[1;33m&#39;\n  export BLUE=&#39;\\033[0;34m&#39;\n  export CYAN=&#39;\\033[0;36m&#39;\n  export MAGENTA=&#39;\\033[0;35m&#39;\n  export BOLD=&#39;\\033[1m&#39;\n  export NC=&#39;\\033[0m&#39;\nfi\n\nshow_help() {\n  cat &lt;&lt;EOF\nSnapshot Management Utility for judge.sh\n\nUsage: $0 &lt;command&gt; [options]\n\nCommands:\n    list                List all snapshots\n    show &lt;test-id&gt;      Show latest snapshot for test\n    diff &lt;test-id&gt;      Compare latest with master\n    clean [days]        Remove old snapshots (default: 7 days)\n    stats               Show snapshot statistics\n\nExamples:\n    $0 list                      # List all snapshots\n    $0 show my-test              # Show latest my-test snapshot\n    $0 diff my-test              # Compare latest with master\n    $0 clean                     # Remove snapshots older than 7 days\n    $0 clean 14                  # Remove snapshots older than 14 days\n    $0 stats                     # Show statistics\n\nEOF\n}\n\nlist_snapshots() {\n  echo &quot;Snapshots in: ${SNAPSHOT_DIR}&quot;\n  echo &quot;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;\n  echo &quot;&quot;\n\n  echo &quot;Master Snapshots:&quot;\n  ls -lh &quot;${SNAPSHOT_DIR}&quot;/*_master.log 2&gt;/dev/null | awk &#39;{print &quot;  &quot; $9, &quot;(&quot; $5 &quot;)&quot;}&#39;\n  echo &quot;&quot;\n\n  echo &quot;Recent Run Snapshots:&quot;\n  ls -lt &quot;${SNAPSHOT_DIR}&quot;/*_[0-9]*_[0-9]*.log 2&gt;/dev/null | head -10 | awk &#39;{print &quot;  &quot; $9, &quot;(&quot; $5 &quot;)&quot;}&#39;\n\n  local count=$(ls &quot;${SNAPSHOT_DIR}&quot;/*_[0-9]*_[0-9]*.log 2&gt;/dev/null | wc -l)\n  if [ $count -gt 10 ]; then\n    echo &quot;  ... and $((count - 10)) more&quot;\n  fi\n}\n\nshow_snapshot() {\n  local test_id=&quot;$1&quot;\n\n  if [ -z &quot;$test_id&quot; ]; then\n    echo &quot;Error: Test ID required&quot;\n    echo &quot;Usage: $0 show &lt;test-id&gt;&quot;\n    exit 1\n  fi\n\n  # Find latest snapshot for this test\n  local latest=$(ls -t &quot;${SNAPSHOT_DIR}/${test_id}&quot;_*.log 2&gt;/dev/null | head -1)\n\n  if [ -z &quot;$latest&quot; ]; then\n    echo &quot;No snapshots found for: $test_id&quot;\n    exit 1\n  fi\n\n  echo &quot;Showing: $latest&quot;\n  echo &quot;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;\n  echo &quot;&quot;\n  cat &quot;$latest&quot;\n}\n\ndiff_snapshot() {\n  local test_id=&quot;$1&quot;\n\n  if [ -z &quot;$test_id&quot; ]; then\n    echo &quot;Error: Test ID required&quot;\n    echo &quot;Usage: $0 diff &lt;test-id&gt;&quot;\n    exit 1\n  fi\n\n  local master=&quot;${SNAPSHOT_DIR}/${test_id}_master.log&quot;\n  local latest=$(ls -t &quot;${SNAPSHOT_DIR}/${test_id}&quot;_[0-9]*_[0-9]*.log 2&gt;/dev/null | head -1)\n\n  if [ ! -f &quot;$master&quot; ]; then\n    echo -e &quot;${RED}Master snapshot not found: $master${NC}&quot;\n    exit 1\n  fi\n\n  if [ -z &quot;$latest&quot; ]; then\n    echo -e &quot;${YELLOW}No recent snapshots found for: $test_id${NC}&quot;\n    exit 1\n  fi\n\n  echo &quot;Comparing:&quot;\n  echo &quot;  Master: $master&quot;\n  echo &quot;  Latest: $latest&quot;\n  echo &quot;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;\n  echo &quot;&quot;\n\n  if diff -q &quot;$master&quot; &quot;$latest&quot; &gt;/dev/null 2&gt;&amp;1; then\n    echo -e &quot;${GREEN}✓ No differences - outputs match${NC}&quot;\n  else\n    echo -e &quot;${YELLOW}⚠ Differences found:${NC}&quot;\n    echo &quot;&quot;\n    diff -u &quot;$master&quot; &quot;$latest&quot; | head -50\n    echo &quot;&quot;\n    echo &quot;... (showing first 50 lines of diff)&quot;\n  fi\n}\n\nclean_snapshots() {\n  local days=&quot;${1:-7}&quot;\n\n  echo &quot;Removing snapshots older than $days days...&quot;\n  echo &quot;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;\n  echo &quot;&quot;\n\n  local count=$(find &quot;${SNAPSHOT_DIR}&quot; -name &quot;*_[0-9]*_[0-9]*.log&quot; -mtime +$days 2&gt;/dev/null | wc -l)\n\n  if [ $count -eq 0 ]; then\n    echo &quot;No old snapshots to remove&quot;\n    return\n  fi\n\n  echo &quot;Found $count snapshot(s) to remove:&quot;\n  find &quot;${SNAPSHOT_DIR}&quot; -name &quot;*_[0-9]*_[0-9]*.log&quot; -mtime +$days -exec basename {} \\; | sed &#39;s/^/  /&#39;\n  echo &quot;&quot;\n\n  read -p &quot;Remove these files? [y/N] &quot; -n 1 -r\n  echo\n\n  if [[ $REPLY =~ ^[Yy]$ ]]; then\n    find &quot;${SNAPSHOT_DIR}&quot; -name &quot;*_[0-9]*_[0-9]*.log&quot; -mtime +$days -delete\n    echo -e &quot;${GREEN}✓ Removed $count snapshot(s)${NC}&quot;\n  else\n    echo &quot;Cancelled&quot;\n  fi\n}\n\nshow_stats() {\n  echo &quot;Snapshot Statistics&quot;\n  echo &quot;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;\n  echo &quot;&quot;\n\n  local master_count=$(ls &quot;${SNAPSHOT_DIR}&quot;/*_master.log 2&gt;/dev/null | wc -l)\n  local run_count=$(ls &quot;${SNAPSHOT_DIR}&quot;/*_[0-9]*_[0-9]*.log 2&gt;/dev/null | wc -l)\n  local total_size=$(du -sh &quot;${SNAPSHOT_DIR}&quot; 2&gt;/dev/null | awk &#39;{print $1}&#39;)\n\n  echo &quot;Master snapshots: $master_count&quot;\n  echo &quot;Run snapshots:    $run_count&quot;\n  echo &quot;Total size:       $total_size&quot;\n  echo &quot;&quot;\n\n  if [ $run_count -gt 0 ]; then\n    echo &quot;Oldest snapshot:&quot;\n    ls -lt &quot;${SNAPSHOT_DIR}&quot;/*_[0-9]*_[0-9]*.log 2&gt;/dev/null | tail -1 | awk &#39;{print &quot;  &quot; $9, &quot;(&quot; $6, $7, $8 &quot;)&quot;}&#39;\n    echo &quot;&quot;\n\n    echo &quot;Newest snapshot:&quot;\n    ls -lt &quot;${SNAPSHOT_DIR}&quot;/*_[0-9]*_[0-9]*.log 2&gt;/dev/null | head -1 | awk &#39;{print &quot;  &quot; $9, &quot;(&quot; $6, $7, $8 &quot;)&quot;}&#39;\n  fi\n}\n\n# Main command dispatcher\ncase &quot;${1:-}&quot; in\nlist)\n  list_snapshots\n  ;;\nshow)\n  show_snapshot &quot;$2&quot;\n  ;;\ndiff)\n  diff_snapshot &quot;$2&quot;\n  ;;\nclean)\n  clean_snapshots &quot;$2&quot;\n  ;;\nstats)\n  show_stats\n  ;;\n-h | --help | help | &quot;&quot;)\n  show_help\n  ;;\n*)\n  echo &quot;Unknown command: $1&quot;\n  echo &quot;&quot;\n  show_help\n  exit 1\n  ;;\nesac</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">run-all-tests.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/run-all-tests.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/bin/bash\n\n# Test Runner with Snapshot Support\n# Runs all test suites, captures output, and manages snapshots\n\nset -e\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\n\n# Export tests dir\nexport TESTS_DIR=&quot;$PWD/__tests&quot;\n# Export tests temp dir\nexport TEMP_DIR=&quot;${TESTS_DIR}/temp&quot;\n\n# Create temp directory\nmkdir -p &quot;${TEMP_DIR}&quot;\n\nsource &quot;${SCRIPT_DIR}/test-helpers.sh&quot;\nif [ -f &quot;${TESTS_DIR}/test-helpers.sh&quot; ]; then\n  source &quot;${TESTS_DIR}/test-helpers.sh&quot;\nfi\n\n# Load test config\nsource &quot;${SCRIPT_DIR}/test-config.sh&quot;\nif [ -f &quot;${TESTS_DIR}/test-config.sh&quot; ]; then\n  source &quot;${TESTS_DIR}/test-config.sh&quot;\nfi\n\n# Auto-discover test files\nshopt -s nullglob\nTEST_FILES_ARRAY=()\nfor test_file in ${TESTS_DIR}/test-*-*.sh; do\n  basename_file=&quot;$(basename &quot;$test_file&quot;)&quot;\n  TEST_FILES_ARRAY+=(&quot;$basename_file&quot;)\ndone\nexport TEST_FILES=(&quot;${TEST_FILES_ARRAY[@]}&quot;)\nshopt -u nullglob\n\n# ============================================================================\n# CONFIGURATION\n# ============================================================================\n\nPROJECT_ROOT=&quot;${TESTS_DIR}&quot;\nSNAPSHOT_DIR=&quot;${PROJECT_ROOT}/snapshots&quot;\nSNAPSHOT_TIMESTAMP=$(date +&quot;%Y%m%d_%H%M%S&quot;)\n\n# Create snapshot directory if it doesn&#39;t exist\nshopt -s nullglob\nmkdir -p &quot;${SNAPSHOT_DIR}&quot;\nmkdir -p &quot;${SNAPSHOT_DIR}/archive&quot;\nfor snapshot in ${SNAPSHOT_DIR}/*.sh_master.log; do\n  cp &quot;$snapshot&quot; &quot;${SNAPSHOT_DIR}/archive&quot;\ndone\nfor snapshot in ${SNAPSHOT_DIR}/*.log; do\n  rm &quot;$snapshot&quot;\ndone\nrm -rf &quot;${SNAPSHOT_DIR}/archive&quot;\nif [ ! -f &quot;${SNAPSHOT_DIR}/.gitignore&quot; ]; then\n  echo &#39;*&#39; &gt;&gt;${SNAPSHOT_DIR}/.gitignore\n  echo &#39;!*_master.log&#39; &gt;&gt;${SNAPSHOT_DIR}/.gitignore\nfi\nshopt -u nullglob\n\n# Parse command line arguments\nUPDATE_SNAPSHOTS=0\nVERBOSE=0\nSPECIFIC_TEST=&quot;&quot;\n\nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n  -u | --update-snapshots)\n    UPDATE_SNAPSHOTS=1\n    export UPDATE_SNAPSHOTS\n    shift\n    ;;\n  -v | --verbose)\n    VERBOSE=1\n    export VERBOSE\n    shift\n    ;;\n  -t | --test)\n    SPECIFIC_TEST=&quot;$2&quot;\n    shift 2\n    ;;\n  -h | --help)\n    cat &lt;&lt;EOF\njudge.sh Test Suite Runner\n\nUsage: $0 [OPTIONS]\n\nOptions:\n    -u, --update-snapshots   Update all test snapshots\n    -v, --verbose           Enable verbose output\n    -t, --test TEST         Run specific test suite\n    -h, --help             Show this help message\n\nExamples:\n    $0                              Run all tests\n    $0 -u                           Update all snapshots\n    $0 -v                           Verbose output\n    $0 -t my-test                   Run only my-test suite\n    $0 -u -t my-test                Update snapshots for my-test\n\nSnapshots:\n    Test output is captured and saved to: snapshots/\n    Each test run creates a timestamped snapshot for comparison.\n    Use -u flag to update the master snapshots.\n\nEOF\n    exit 0\n    ;;\n  *)\n    echo &quot;Unknown option: $1&quot;\n    echo &quot;Use -h or --help for usage information&quot;\n    exit 1\n    ;;\n  esac\ndone\n\n# ============================================================================\n# SNAPSHOT FUNCTIONS\n# ============================================================================\n\nsave_snapshot() {\n  local test_name=&quot;$1&quot;\n  local output=&quot;$2&quot;\n  local snapshot_file=&quot;${SNAPSHOT_DIR}/${test_name}_${SNAPSHOT_TIMESTAMP}.log&quot;\n  local master_snapshot=&quot;${SNAPSHOT_DIR}/${test_name}_master.log&quot;\n\n  # Save timestamped snapshot\n  echo &quot;$output&quot; &gt;&quot;$snapshot_file&quot;\n\n  # Update master snapshot if requested\n  if [ $UPDATE_SNAPSHOTS -eq 1 ]; then\n    echo &quot;$output&quot; &gt;&quot;$master_snapshot&quot;\n    log_info &quot;Updated master snapshot: ${master_snapshot}&quot;\n  fi\n\n  log_info &quot;Saved snapshot: ${snapshot_file}&quot;\n}\n\ncompare_snapshot() {\n  local test_name=&quot;$1&quot;\n  local output=&quot;$2&quot;\n  local master_snapshot=&quot;${SNAPSHOT_DIR}/${test_name}_master.log&quot;\n\n  if [ ! -f &quot;$master_snapshot&quot; ]; then\n    log_warning &quot;No master snapshot found for ${test_name}&quot;\n    log_info &quot;Creating initial master snapshot...&quot;\n    echo &quot;$output&quot; &gt;&quot;$master_snapshot&quot;\n    return 0\n  fi\n\n  # Compare with master\n  local temp_file=$(mktemp)\n  echo &quot;$output&quot; &gt;&quot;$temp_file&quot;\n\n  if diff -q &quot;$master_snapshot&quot; &quot;$temp_file&quot; &gt;/dev/null 2&gt;&amp;1; then\n    log_info &quot;✓ Output matches master snapshot&quot;\n    rm &quot;$temp_file&quot;\n    return 0\n  else\n    log_warning &quot;⚠ Output differs from master snapshot&quot;\n    log_info &quot;Run with -u flag to update snapshots&quot;\n    rm &quot;$temp_file&quot;\n    return 1\n  fi\n}\n\n# ============================================================================\n# BANNER\n# ============================================================================\n\nclear\necho -e &quot;${CYAN}╔════════════════════════════════════════════════════════════════╗${NC}&quot;\necho -e &quot;${CYAN}║                                                                ║${NC}&quot;\necho -e &quot;${CYAN}║              judge.sh                                          ║${NC}&quot;\necho -e &quot;${CYAN}║              Version 1.0.0                                     ║${NC}&quot;\necho -e &quot;${CYAN}║                                                                ║${NC}&quot;\necho -e &quot;${CYAN}╚════════════════════════════════════════════════════════════════╝${NC}&quot;\necho &quot;&quot;\n\n# ============================================================================\n# PRE-FLIGHT CHECKS\n# ============================================================================\n\nlog_section &quot;PRE-FLIGHT CHECKS&quot;\n\nfor test_file in &quot;${TEST_FILES[@]}&quot;; do\n  if [ -f &quot;${TESTS_DIR}/${test_file}&quot; ]; then\n    log_pass &quot;Found ${test_file}&quot;\n  else\n    log_warning &quot;Missing ${test_file}&quot;\n  fi\ndone\n\n# ============================================================================\n# TEST CONFIGURATION INFO\n# ============================================================================\n\nlog_section &quot;TEST CONFIGURATION&quot;\n\nif [ $UPDATE_SNAPSHOTS -eq 1 ]; then\n  log_info &quot;Snapshot mode: UPDATE (will create/update snapshots)&quot;\nelse\n  log_info &quot;Snapshot mode: COMPARE (will compare against existing snapshots)&quot;\nfi\n\nif [ -n &quot;$SPECIFIC_TEST&quot; ]; then\n  log_info &quot;Running specific test: $SPECIFIC_TEST&quot;\nelse\n  log_info &quot;Running all tests&quot;\nfi\n\nlog_info &quot;Snapshot directory: ${SNAPSHOT_DIR}&quot;\n\n# ============================================================================\n# RUN TESTS\n# ============================================================================\n\nFAILED_SUITES=()\n\nrun_test_suite() {\n  local test_file=&quot;$1&quot;\n  local test_name=&quot;$2&quot;\n  local test_id=&quot;$3&quot;\n\n  if [ ! -f &quot;${TESTS_DIR}/${test_file}&quot; ]; then\n    log_skip &quot;Test file not found: ${test_file}&quot;\n    return\n  fi\n\n  setup_sandbox\n\n  chmod +x &quot;${TESTS_DIR}/${test_file}&quot;\n\n  log_section &quot;RUNNING: ${test_name}&quot;\n\n  # Capture all output\n  local output_file=$(mktemp)\n\n  source &quot;${TESTS_DIR}/${test_file}&quot;\n\n  # Running Suite\n  run_tests &amp;&amp; print_test_summary 2&gt;&amp;1 | tee &quot;$output_file&quot;\n  local exit_code=${PIPESTATUS[0]}\n\n  # Read captured output\n  local captured_output=$(cat &quot;$output_file&quot;)\n\n  # Save snapshot\n  save_snapshot &quot;$test_id&quot; &quot;$captured_output&quot;\n\n  # Compare with master if not updating\n  if [ $UPDATE_SNAPSHOTS -eq 0 ]; then\n    compare_snapshot &quot;$test_id&quot; &quot;$captured_output&quot;\n  fi\n\n  # Cleanup temp file\n  rm &quot;$output_file&quot;\n\n  if [ $exit_code -eq 0 ]; then\n    log_success &quot;${test_name} completed successfully&quot;\n  else\n    log_failure &quot;${test_name} failed&quot;\n    FAILED_SUITES+=(&quot;$test_name&quot;)\n  fi\n\n  teardown_sandbox\n\n  echo &quot;&quot;\n}\n\n# Run specific test or all tests\nif [ -n &quot;$SPECIFIC_TEST&quot; ]; then\n  run_test_suite &quot;test-${SPECIFIC_TEST}.sh&quot; &quot;${SPECIFIC_TEST}&quot; &quot;${SPECIFIC_TEST}&quot;\nelse\n  for suite in &quot;${TEST_FILES[@]}&quot;; do\n    run_test_suite &quot;${suite}&quot; &quot;${suite}&quot; &quot;${suite}&quot;\n  done\nfi\n\n# ============================================================================\n# FINAL REPORT\n# ============================================================================\n\nlog_section &quot;FINAL TEST REPORT&quot;\n\necho &quot;&quot;\necho -e &quot;${CYAN}Test Execution Summary:${NC}&quot;\necho -e &quot;${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}&quot;\necho &quot;&quot;\n\nif [ ${#FAILED_SUITES[@]} -eq 0 ]; then\n  echo -e &quot;${GREEN}✓ All test suites passed!${NC}&quot;\n  echo &quot;&quot;\n  suites_run=$([ -n &quot;$SPECIFIC_TEST&quot; ] &amp;&amp; echo 1 || echo ${#TEST_FILES[@]})\n  echo &quot;  Test suites run: $suites_run&quot;\n  echo &quot;&quot;\nelse\n  echo -e &quot;${RED}✗ Some test suites failed:${NC}&quot;\n  echo &quot;&quot;\n  for suite in &quot;${FAILED_SUITES[@]}&quot;; do\n    echo &quot;  - $suite&quot;\n  done\n  echo &quot;&quot;\n  echo &quot;  Failed suites: ${#FAILED_SUITES[@]}&quot;\n  echo &quot;&quot;\nfi\n\necho -e &quot;${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}&quot;\necho &quot;&quot;\n\n# Snapshot information\necho -e &quot;${BLUE}Snapshots:${NC}&quot;\necho &quot;  Location: ${SNAPSHOT_DIR}&quot;\necho &quot;  Timestamp: ${SNAPSHOT_TIMESTAMP}&quot;\n\nif [ $UPDATE_SNAPSHOTS -eq 1 ]; then\n  echo -e &quot;  Status: ${GREEN}Master snapshots updated ✓${NC}&quot;\nelse\n  echo &quot;  Status: Compared against master snapshots&quot;\nfi\necho &quot;&quot;\n\n\nif [ $UPDATE_SNAPSHOTS -eq 0 ]; then\n  log_info &quot;Tip: Run with -u flag to update snapshots if tests fail&quot;\nfi\n\nif [ $VERBOSE -eq 0 ]; then\n  log_info &quot;Tip: Run with -v flag for verbose output&quot;\nfi\n\necho &quot;&quot;\n\n# Exit with appropriate code\nif [ ${#FAILED_SUITES[@]} -eq 0 ]; then\n  exit 0\nelse\n  exit 1\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">setup.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/setup.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# Setup script for judge.sh\n# Initializes the project environment\n\nset -e\n\nchmod +x run-all-tests.sh\nchmod +x setup-snapshots.sh\nchmod +x snapshot-tool.sh\necho &quot;✓ Made test scripts executable&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-config.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/test-config.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test configuration for test suites\n# This file is sourced by test files to set common configuration\n\n# Snapshot configuration\nexport SNAPSHOT_UPDATE=&quot;${UPDATE_SNAPSHOTS:-0}&quot;\nexport SNAPSHOT_VERBOSE=&quot;${VERBOSE:-0}&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">judge.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/judge.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# judge.sh - Main entry point for test framework\n# Delegates commands to specialized scripts\n\nset -euo pipefail\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nREAL_BASH_SOURCE=&quot;$(readlink -f &quot;${BASH_SOURCE[0]}&quot;)&quot;\nREAL_SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${REAL_BASH_SOURCE}&quot;)&quot; &amp;&amp; pwd)&quot;\n\n# Colors for output - only use colors if output is to a terminal or if FORCE_COLOR is set\nexport FORCE_COLOR=${FORCE_COLOR:-&quot;1&quot;}\nif [ &quot;$FORCE_COLOR&quot; = &quot;0&quot; ]; then\n  export RED=&#39;&#39;\n  export GREEN=&#39;&#39;\n  export YELLOW=&#39;&#39;\n  export BLUE=&#39;&#39;\n  export CYAN=&#39;&#39;\n  export MAGENTA=&#39;&#39;\n  export BOLD=&#39;&#39;\n  export NC=&#39;&#39;\nelse\n  export RED=&#39;\\033[0;31m&#39;\n  export GREEN=&#39;\\033[0;32m&#39;\n  export YELLOW=&#39;\\033[1;33m&#39;\n  export BLUE=&#39;\\033[0;34m&#39;\n  export CYAN=&#39;\\033[0;36m&#39;\n  export MAGENTA=&#39;\\033[0;35m&#39;\n  export BOLD=&#39;\\033[1m&#39;\n  export NC=&#39;\\033[0m&#39;\nfi\n\nshow_usage() {\n  cat &lt;&lt;EOF\njudge.sh - A bash testing framework with snapshot support\n\nUSAGE:\n    judge.sh &lt;command&gt; [options]\n\nCOMMANDS:\n    run      Run all tests (delegates to run-all-tests.sh)\n    setup    Initialize snapshot baselines (delegates to setup-snapshots.sh)\n    snap     Manage snapshots (delegates to snapshot-tool.sh)\n    help     Show this help message\n\nEXAMPLES:\n    # Run all tests\n    judge.sh run\n\n    # Run tests with verbose output\n    judge.sh run -v\n\n    # Run specific test suite\n    judge.sh run -t my-test\n\n    # Update snapshots\n    judge.sh run -u\n\n    # Initialize snapshots (first time setup)\n    judge.sh setup\n\n    # List all snapshots\n    judge.sh snap list\n\n    # Compare snapshot with master\n    judge.sh snap diff test-name\n\n    # Show snapshot statistics\n    judge.sh snap stats\n\nFor detailed command help:\n    judge.sh run --help\n    judge.sh snap --help\n\nEOF\n}\n\nmain() {\n  if [[ $# -eq 0 ]]; then\n    show_usage\n    exit 0\n  fi\n\n  local command=&quot;$1&quot;\n  shift\n\n  case &quot;$command&quot; in\n  run)\n    # Delegate to run-all-tests.sh\n    exec bash &quot;${REAL_SCRIPT_DIR}/run-all-tests.sh&quot; &quot;$@&quot;\n    ;;\n  setup)\n    # Delegate to setup-snapshots.sh\n    exec bash &quot;${REAL_SCRIPT_DIR}/setup-snapshots.sh&quot; &quot;$@&quot;\n    ;;\n  snap)\n    # Delegate to snapshot-tool.sh\n    exec bash &quot;${REAL_SCRIPT_DIR}/snapshot-tool.sh&quot; &quot;$@&quot;\n    ;;\n  help | --help | -h)\n    show_usage\n    exit 0\n    ;;\n  *)\n    echo -e &quot;${RED}Error: Unknown command &#39;$command&#39;${NC}&quot;\n    echo &quot;&quot;\n    show_usage\n    exit 1\n    ;;\n  esac\n}\n\nmain &quot;$@&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">setup-snapshots.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/setup-snapshots.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/bin/bash\n\n# Initial snapshot setup\n# Run this once to create master snapshots for the first time\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\n\necho &quot;════════════════════════════════════════════════════&quot;\necho &quot;  Initial Snapshot Setup for judge.sh&quot;\necho &quot;════════════════════════════════════════════════════&quot;\necho &quot;&quot;\necho &quot;This will create master snapshots for all test suites.&quot;\necho &quot;Master snapshots serve as the reference for future test runs.&quot;\necho &quot;&quot;\necho &quot;Press Enter to continue, or Ctrl+C to cancel...&quot;\nread\n\necho &quot;&quot;\necho &quot;Running all tests and creating master snapshots...&quot;\necho &quot;&quot;\n\n# Run with update flag to create master snapshots\n&quot;${SCRIPT_DIR}/run-all-tests.sh&quot; -u\n\necho &quot;&quot;\necho &quot;════════════════════════════════════════════════════&quot;\necho &quot;  Setup Complete&quot;\necho &quot;════════════════════════════════════════════════════&quot;\necho &quot;&quot;\necho &quot;Master snapshots created in: snapshots/&quot;\necho &quot;&quot;\necho &quot;Next steps:&quot;\necho &quot;  1. Review the master snapshot files&quot;\necho &quot;  2. Commit them to git:&quot;\necho &quot;     git add snapshots/*_master.log&quot;\necho &quot;     git commit -m \\&quot;Add initial test snapshots\\&quot;&quot;\necho &quot;&quot;\necho &quot;  3. Run tests normally:&quot;\necho &quot;     ./judge.sh run&quot;\necho &quot;&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-helpers.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/test-helpers.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/bin/bash\n\n# Test Helpers for judge.sh\n# Provides utilities for snapshot testing, assertions, and test reporting\n\n# Test counters\nTESTS_RUN=0\nTESTS_PASSED=0\nTESTS_FAILED=0\nTEST_ENV_DIR=&quot;&quot;\n\n# ============================================================================\n# SETUP FUNCTIONS\n# ============================================================================\n\n# Setup before each test\nsetup_sandbox() {\n  # Test counters\n  TESTS_RUN=0\n  TESTS_PASSED=0\n  TESTS_FAILED=0\n  setup_test_env\n  TEST_ENV_DIR=$(create_test_env)\n  cd &quot;$TEST_ENV_DIR&quot;\n}\n\n# Cleanup after each test\nteardown_sandbox() {\n  teardown_test_env\n  cd /\n}\n\n# Test utilities\ncreate_test_env() {\n  local test_dir=&quot;$TEST_ENV_DIR&quot;\n  if [[ -n &quot;$test_dir&quot; ]] &amp;&amp; [[ -d &quot;$test_dir&quot; ]]; then\n    echo &quot;$test_dir&quot;\n  else\n    local test_base_dir=&quot;${TEMP_DIR}&quot;\n    test_dir=$(mktemp -d &quot;${test_base_dir}/judge-test-XXXXXX&quot;)\n    echo &quot;$test_dir&quot;\n  fi\n}\n\ncleanup_test_env() {\n  local test_dir=&quot;$TEST_ENV_DIR&quot;\n  if [[ -n &quot;$test_dir&quot; ]] &amp;&amp; [[ -d &quot;$test_dir&quot; ]]; then\n    rm -rf &quot;$test_dir&quot;\n  fi\n}\n\n# ============================================================================\n# LOGGING FUNCTIONS\n# ============================================================================\n\nlog_test() {\n  echo -e &quot;${CYAN}[TEST]${NC} $1&quot;\n}\n\nlog_pass() {\n  echo -e &quot;${GREEN}[PASS]${NC} $1&quot;\n}\n\nlog_fail() {\n  echo -e &quot;${RED}[FAIL]${NC} $1&quot;\n}\n\nlog_skip() {\n  echo -e &quot;${YELLOW}[SKIP]${NC} $1&quot;\n}\n\nlog_info() {\n  echo -e &quot;${BLUE}[INFO]${NC} $1&quot;\n}\n\nlog_warning() {\n  echo -e &quot;${YELLOW}[WARN]${NC} $1&quot;\n}\n\nlog_error() {\n  echo -e &quot;${RED}[ERROR]${NC} $1&quot;\n}\n\nlog_success() {\n  echo -e &quot;${GREEN}[✓]${NC} $1&quot;\n}\n\nlog_failure() {\n  echo -e &quot;${RED}[✗]${NC} $1&quot;\n}\n\nlog_section() {\n  echo &quot;&quot;\n  echo -e &quot;${CYAN}═══════════════════════════════════════════════════════${NC}&quot;\n  echo -e &quot;${CYAN}  $1${NC}&quot;\n  echo -e &quot;${CYAN}═══════════════════════════════════════════════════════${NC}&quot;\n  echo &quot;&quot;\n}\n\n# ============================================================================\n# ASSERTION FUNCTIONS\n# ============================================================================\n\nassert_success() {\n  assert_exit_code 0 &quot;$?&quot; &quot;${1:-Command should succeed}&quot;\n}\n\nassert_failure() {\n  assert_false &quot;[[ $? -ne 0 ]]&quot; &quot;${1:-Command should fail}&quot;\n}\n\nassert_equals() {\n  local expected=&quot;$1&quot;\n  local actual=&quot;$2&quot;\n  local test_name=&quot;$3&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  if [ &quot;$expected&quot; = &quot;$actual&quot; ]; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 1\n  else\n    TESTS_FAILED=$((TESTS_FAILED + 1))\n    log_fail &quot;$test_name&quot;\n    echo &quot;  Expected: $expected&quot;\n    echo &quot;  Actual:   $actual&quot;\n    return 0\n  fi\n}\n\nassert_not_equals() {\n  local expected=&quot;$1&quot;\n  local actual=&quot;$2&quot;\n  local test_name=&quot;$3&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  if [ &quot;$expected&quot; != &quot;$actual&quot; ]; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 0\n  else\n    TESTS_FAILED=$((TESTS_FAILED + 1))\n    log_fail &quot;$test_name&quot;\n    echo &quot;  Expected values to be different&quot;\n    echo &quot;  Both equal: $expected&quot;\n    return 1\n  fi\n}\n\nassert_contains() {\n  local haystack=&quot;$1&quot;\n  local needle=&quot;$2&quot;\n  local test_name=&quot;$3&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  if echo &quot;$haystack&quot; | grep -qiF -- &quot;$needle&quot;; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 0\n  else\n    TESTS_FAILED=$((TESTS_FAILED + 1))\n    log_fail &quot;$test_name&quot;\n    echo &quot;  Expected to contain: $needle&quot;\n    if [ &quot;${VERBOSE:-0}&quot; = &quot;1&quot; ]; then\n      echo &quot;  Actual output:&quot;\n      echo &quot;$haystack&quot; | head -20\n    fi\n    return 1\n  fi\n}\n\nassert_not_contains() {\n  local haystack=&quot;$1&quot;\n  local needle=&quot;$2&quot;\n  local test_name=&quot;$3&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  if ! echo &quot;$haystack&quot; | grep -qiF -- &quot;$needle&quot;; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 0\n  else\n    TESTS_FAILED=$((TESTS_FAILED + 1))\n    log_fail &quot;$test_name&quot;\n    echo &quot;  Expected NOT to contain: $needle&quot;\n    if [ &quot;${VERBOSE:-0}&quot; = &quot;1&quot; ]; then\n      echo &quot;  Actual output:&quot;\n      echo &quot;$haystack&quot; | head -20\n    fi\n    return 1\n  fi\n}\n\nassert_exit_code() {\n  local expected_code=&quot;$1&quot;\n  local actual_code=&quot;$2&quot;\n  local test_name=&quot;$3&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  # Ensure both codes are set, default to empty string representation\n  if [[ -z &quot;$expected_code&quot; ]]; then\n    expected_code=&quot;(empty)&quot;\n  fi\n  if [[ -z &quot;$actual_code&quot; ]]; then\n    actual_code=&quot;(empty)&quot;\n  fi\n\n  if [[ &quot;$expected_code&quot; -eq &quot;$actual_code&quot; ]] 2&gt;/dev/null; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 0\n  else\n    TESTS_FAILED=$((TESTS_FAILED + 1))\n    log_fail &quot;$test_name&quot;\n    echo &quot;  Expected exit code: $expected_code&quot;\n    echo &quot;  Actual exit code:   $actual_code&quot;\n    return 1\n  fi\n}\n\nassert_file_exists() {\n  local file=&quot;$1&quot;\n  local test_name=&quot;$2&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  if [ -f &quot;$file&quot; ]; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 0\n  else\n    TESTS_FAILED=$((TESTS_FAILED + 1))\n    log_fail &quot;$test_name&quot;\n    echo &quot;  File not found: $file&quot;\n    return 1\n  fi\n}\n\nassert_directory_exists() {\n  local dir=&quot;$1&quot;\n  local test_name=&quot;$2&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  if [ -d &quot;$dir&quot; ]; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 0\n  else\n    TESTS_FAILED=$((TESTS_FAILED + 1))\n    log_fail &quot;$test_name&quot;\n    echo &quot;  Directory not found: $dir&quot;\n    return 1\n  fi\n}\n\nassert_true() {\n  local command=&quot;$1&quot;\n  local test_name=&quot;$2&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  set +e\n  eval &quot;$command&quot;\n  local result=$?\n  set -e\n\n  if [ $result -eq 0 ]; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 0\n  else\n    TESTS_FAILED=$((TESTS_FAILED + 1))\n    log_fail &quot;$test_name&quot;\n    echo &quot;  Command failed: $command&quot;\n    echo &quot;  Exit code: $result&quot;\n    return 1\n  fi\n}\n\nassert_false() {\n  local command=&quot;$1&quot;\n  local test_name=&quot;$2&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  set +e\n  eval &quot;$command&quot;\n  local result=$?\n  set -e\n\n  if [ $result -ne 0 ]; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 0\n  else\n    TESTS_FAILED=$((TESTS_FAILED + 1))\n    log_fail &quot;$test_name&quot;\n    echo &quot;  Command should have failed: $command&quot;\n    return 1\n  fi\n}\n\n# ============================================================================\n# SNAPSHOT TESTING\n# ============================================================================\n\nnormalize_output() {\n  local content=&quot;$1&quot;\n  # Remove trailing whitespace, normalize line endings, remove ANSI color codes\n  echo &quot;$content&quot; | sed &#39;s/[[:space:]]*$//&#39; | tr -s &#39;\\n&#39; | sed &#39;s/\\x1b\\[[0-9;]*m//g&#39;\n}\n\ncreate_snapshot() {\n  local snapshot_name=&quot;$1&quot;\n  local content=&quot;$2&quot;\n  local snapshot_file=&quot;${SNAPSHOT_DIR}/${snapshot_name}.snapshot&quot;\n\n  # Normalize and save\n  normalize_output &quot;$content&quot; &gt;&quot;$snapshot_file&quot;\n  log_info &quot;Created snapshot: $snapshot_name&quot;\n}\n\nupdate_snapshot() {\n  local snapshot_name=&quot;$1&quot;\n  local content=&quot;$2&quot;\n\n  create_snapshot &quot;$snapshot_name&quot; &quot;$content&quot;\n  log_info &quot;Updated snapshot: $snapshot_name&quot;\n}\n\ncompare_snapshot() {\n  local snapshot_name=&quot;$1&quot;\n  local actual_content=&quot;$2&quot;\n  local test_name=&quot;$3&quot;\n  local snapshot_file=&quot;${SNAPSHOT_DIR}/${snapshot_name}.snapshot&quot;\n\n  TESTS_RUN=$((TESTS_RUN + 1))\n\n  if [ ! -f &quot;$snapshot_file&quot; ]; then\n    log_warning &quot;$test_name - Snapshot not found, creating...&quot;\n    create_snapshot &quot;$snapshot_name&quot; &quot;$actual_content&quot;\n    log_pass &quot;$test_name (snapshot created)&quot;\n    return 0\n  fi\n\n  local expected_content\n  expected_content=$(cat &quot;$snapshot_file&quot;)\n\n  # Normalize both for comparison\n  local normalized_expected\n  local normalized_actual\n  normalized_expected=$(normalize_output &quot;$expected_content&quot;)\n  normalized_actual=$(normalize_output &quot;$actual_content&quot;)\n\n  if [ &quot;$normalized_expected&quot; = &quot;$normalized_actual&quot; ]; then\n    TESTS_PASSED=$((TESTS_PASSED + 1))\n    log_pass &quot;$test_name&quot;\n    return 0\n  else\n    log_fail &quot;$test_name - Snapshot mismatch&quot;\n    echo &quot;  Snapshot: $snapshot_file&quot;\n    if [ &quot;${VERBOSE:-0}&quot; = &quot;1&quot; ]; then\n      echo &quot;  Diff:&quot;\n      diff -u &lt;(echo &quot;$normalized_expected&quot;) &lt;(echo &quot;$normalized_actual&quot;) | head -50 || true\n    else\n      echo &quot;  Use -v flag to see diff&quot;\n    fi\n    echo &quot;  Run with UPDATE_SNAPSHOTS=1 to update snapshots&quot;\n    return 1\n  fi\n}\n\n# ============================================================================\n# COMMAND EXECUTION\n# ============================================================================\n\ncapture_output() {\n  local cmd=&quot;$*&quot;\n  local output\n\n  set +e\n  output=$(eval &quot;$cmd&quot; 2&gt;&amp;1)\n  local exit_code=$?\n  set -e\n\n  # Return output via stdout\n  echo &quot;$output&quot;\n  # Store exit code in global variable\n  CAPTURED_EXIT_CODE=$exit_code\n  return $exit_code\n}\n\n# ============================================================================\n# TEST UTILITIES\n# ============================================================================\n\nsetup_test_env() {\n  log_info &quot;Setting up test environment...&quot;\n\n  # Ensure snapshot directory exists\n  mkdir -p &quot;${SNAPSHOT_DIR}&quot;\n\n  # Clean and create temp directory\n  rm -rf &quot;${TEMP_DIR}&quot;\n  mkdir -p &quot;${TEMP_DIR}&quot;\n\n  log_info &quot;Test environment ready&quot;\n  log_info &quot;Test temp directory: ${TEMP_DIR}&quot;\n}\n\nteardown_test_env() {\n  log_info &quot;Cleaning up test environment...&quot;\n\n  # Clean entire temp directory\n  if [ -d &quot;${TEMP_DIR}&quot; ]; then\n    rm -rf &quot;${TEMP_DIR}&quot;\n    log_info &quot;Removed temp directory: ${TEMP_DIR}&quot;\n  fi\n\n  log_info &quot;Cleanup complete&quot;\n}\n\n# ============================================================================\n# REPORTING\n# ============================================================================\n\nprint_test_summary() {\n  # Ensure counters are initialized with default values\n  local tests_run=${TESTS_RUN:-0}\n  local tests_passed=${TESTS_PASSED:-0}\n  local tests_failed=${TESTS_FAILED:-0}\n\n  echo &quot;&quot;\n  echo -e &quot;${CYAN}═══════════════════════════════════════════════════════${NC}&quot;\n  echo -e &quot;${CYAN}  TEST SUMMARY${NC}&quot;\n  echo -e &quot;${CYAN}═══════════════════════════════════════════════════════${NC}&quot;\n  echo &quot;&quot;\n  echo &quot;  Total Tests:  $tests_run&quot;\n  echo -e &quot;  ${GREEN}Passed:       $tests_passed${NC}&quot;\n  echo -e &quot;  ${RED}Failed:       $tests_failed${NC}&quot;\n\n  if [ $tests_run -gt 0 ]; then\n    local pass_rate=$((tests_passed * 100 / tests_run))\n    echo &quot;  Pass Rate:    ${pass_rate}%&quot;\n  fi\n\n  echo &quot;&quot;\n\n  if [ $tests_failed -eq 0 ]; then\n    echo -e &quot;${GREEN}✓ All tests passed!${NC}&quot;\n    echo &quot;&quot;\n    return 0\n  else\n    echo -e &quot;${RED}✗ Some tests failed${NC}&quot;\n    echo &quot;&quot;\n    return 1\n  fi\n}\n\n# Export functions for use in test scripts\nexport -f log_test log_pass log_fail log_skip log_info log_warning log_error log_success log_failure log_section\nexport -f assert_success assert_failure\nexport -f assert_equals assert_not_equals assert_contains assert_not_contains assert_exit_code\nexport -f assert_file_exists assert_directory_exists\nexport -f assert_true assert_false\nexport -f normalize_output create_snapshot update_snapshot compare_snapshot\nexport -f capture_output\nexport -f create_test_env cleanup_test_env print_test_summary</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-judge-assertions.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/__tests/test-judge-assertions.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for judge.sh assertion functions\n\n# Test: assert_equals works with matching values\ntest_assert_equals_success() {\n  { assert_equals &quot;test&quot; &quot;test&quot; &quot;Values should match&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should succeed &#39;assert_equals&#39;&quot;\n}\n\n# Test: assert_equals fails with non-matching values\ntest_assert_equals_failure() {\n  { assert_equals &quot;expected&quot; &quot;actual&quot; &quot;Values should not match&quot; &amp; } &gt;/dev/null\n  assert_failure &quot;Should fail &#39;assert_equals&#39;&quot;\n}\n\n# Test: assert_contains detects substring\ntest_assert_contains_success() {\n  { assert_contains &quot;Hello World&quot; &quot;World&quot; &quot;Should find substring&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should succeed &#39;assert_contains&#39;&quot;\n}\n\n# Test: assert_contains fails when substring absent\ntest_assert_contains_failure() {\n  { assert_contains &quot;Hello World&quot; &quot;Missing&quot; &quot;Should not find substring&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should fail &#39;assert_contains&#39;&quot;\n}\n\n# Test: assert_not_contains works correctly\ntest_assert_not_contains_success() {\n  { assert_not_contains &quot;Hello World&quot; &quot;Missing&quot; &quot;Should not contain substring&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should succeed &#39;assert_not_contains&#39;&quot;\n}\n\n# Test: assert_not_contains fails when substring present\ntest_assert_not_contains_failure() {\n  { assert_not_contains &quot;Hello World&quot; &quot;World&quot; &quot;Should fail&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should fail &#39;assert_not_contains&#39;&quot;\n}\n\n# Test: assert_exit_code checks correct code\ntest_assert_exit_code_success() {\n  { assert_exit_code 0 0 &quot;Exit codes should match&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should succeed &#39;assert_exit_code&#39;&quot;\n}\n\n# Test: assert_exit_code fails on mismatch\ntest_assert_exit_code_failure() {\n  { assert_exit_code assert_exit_code 0 1 &quot;Exit codes mismatch&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should fail &#39;assert_exit_code&#39;&quot;\n}\n\n# Test: assert_file_exists detects existing file\ntest_assert_file_exists_success() {\n  touch &quot;testfile.txt&quot;\n  { assert_file_exists &quot;testfile.txt&quot; &quot;File should exist&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should succeed &#39;assert_file_exists&#39;&quot;\n}\n\n# Test: assert_file_exists fails for missing file\ntest_assert_file_exists_failure() {\n  { assert_file_exists &quot;nonexistent.txt&quot; &quot;Missing file&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should fail &#39;assert_file_exists&#39;&quot;\n}\n\n# Test: assert_directory_exists detects existing directory\ntest_assert_directory_exists_success() {\n  mkdir &quot;testdir&quot;\n  { assert_directory_exists &quot;testdir&quot; &quot;Directory should exist&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should succeed &#39;assert_directory_exists&#39;&quot;\n}\n\n# Test: assert_directory_exists fails for missing directory\ntest_assert_directory_exists_failure() {\n  { assert_directory_exists &quot;nonexistent&quot; &quot;Missing dir&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should fail &#39;assert_directory_exists&#39;&quot;\n}\n\n# Test: assert_true evaluates commands\ntest_assert_true_success() {\n  { assert_true &quot;true&quot; &quot;True command&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should succeed &#39;assert_true&#39;&quot;\n}\n\n# Test: assert_true fails for false commands\ntest_assert_true_failure() {\n  { assert_true &quot;false&quot; &quot;False command&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should fail &#39;assert_true&#39;&quot;\n}\n\n# Test: assert_false evaluates commands\ntest_assert_false_success() {\n  { assert_false &quot;false&quot; &quot;False command&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should succeed &#39;assert_false&#39;&quot;\n}\n\n# Test: assert_false fails for true commands\ntest_assert_false_failure() {\n  { assert_false &quot;true&quot; &quot;True command&quot; &amp; } &gt;/dev/null\n  assert_success &quot;Should fail &#39;assert_false&#39;&quot;\n}\n\n# Run all tests\nrun_tests() {\n  log_section &quot;Assertion Tests&quot;\n\n  test_assert_equals_success\n  test_assert_equals_failure\n  test_assert_contains_success\n  test_assert_contains_failure\n  test_assert_not_contains_success\n  test_assert_not_contains_failure\n  test_assert_exit_code_success\n  test_assert_exit_code_failure\n  test_assert_file_exists_success\n  test_assert_file_exists_failure\n  test_assert_directory_exists_success\n  test_assert_directory_exists_failure\n  test_assert_true_success\n  test_assert_true_failure\n  test_assert_false_success\n  test_assert_false_failure\n}\n\nexport -f run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-judge-integration.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/__tests/test-judge-integration.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Integration tests for judge.sh - tests complete workflows\n\n\n# Test: complete test lifecycle\ntest_complete_lifecycle() {\n\n  cat &gt;&quot;${TEMP_DIR}/test-simple.sh&quot; &lt;&lt;&#39;EOF&#39;\n#!/usr/bin/env bash\nexit 0\nEOF\n  chmod +x &quot;${TEMP_DIR}/test-simple.sh&quot;\n  set +e\n  bash &quot;${TEMP_DIR}/test-simple.sh&quot; &gt;/dev/null 2&gt;&amp;1\n  result=$?\n  set -e\n  assert_equals 0 $result &quot;Test should pass&quot;\n}\n\n# Test: logging in sequence\ntest_logging_sequence() {\n\n  output=$(\n    log_info &quot;Starting test&quot;\n    log_test &quot;Running test&quot;\n    log_success &quot;All done&quot;\n  ) 2&gt;&amp;1\n  assert_contains &quot;$output&quot; &quot;Starting test&quot; &quot;Should contain info&quot;\n  assert_contains &quot;$output&quot; &quot;Running test&quot; &quot;Should contain test&quot;\n  assert_contains &quot;$output&quot; &quot;All done&quot; &quot;Should contain success&quot;\n}\n\n# Test: error handling\ntest_error_handling() {\n\n  set +e\n  false\n  result=$?\n  set -e\n  assert_equals 1 $result &quot;Should capture failure&quot;\n}\n\n# Test: assertion functions work\ntest_assertions_work() {\n\n  # Test assert_equals\n  assert_equals &quot;a&quot; &quot;a&quot; &quot;Equals should work&quot;\n  # Test assert_contains\n  assert_contains &quot;hello world&quot; &quot;world&quot; &quot;Contains should work&quot;\n  # Test assert_true\n  assert_true &quot;true&quot; &quot;True should work&quot;\n  # Test assert_false\n  assert_false &quot;false&quot; &quot;False should work&quot;\n}\n\n# Test: capture output functionality\ntest_capture_functionality() {\n\n  output=$(capture_output &quot;echo test&quot;)\n  assert_equals &quot;test&quot; &quot;$output&quot; &quot;Should capture command output&quot;\n}\n\n# Test: normalize output function\ntest_normalize_output() {\n\n  input=&quot;  test  \n    with spaces  &quot;\n  output=$(normalize_output &quot;$input&quot;)\n  # Just verify it produces some output\n  assert_true &quot;[[ -n \\&quot;$output\\&quot; ]]&quot; &quot;Should produce normalized output&quot;\n}\n\n# Run all tests\nrun_tests() {\n  log_section &quot;Integration Tests&quot;\n\n  test_complete_lifecycle\n  test_logging_sequence\n  test_error_handling\n  test_assertions_work\n  test_capture_functionality\n  test_normalize_output\n}\n\nexport -f run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-judge-environment.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/__tests/test-judge-environment.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for judge.sh test environment utilities\n\n# Test: cleanup_test_env handles missing directory\ntest_cleanup_missing_dir() {\n\n  set +e\n  cleanup_test_env &gt;/dev/null 2&gt;&amp;1\n  result=$?\n  set -e\n  assert_equals 0 $result &quot;Should handle missing directory gracefully&quot;\n}\n\n# Test: capture_output captures stdout\ntest_capture_stdout() {\n\n  output=$(capture_output &quot;echo &#39;test output&#39;&quot;)\n  assert_equals &quot;test output&quot; &quot;$output&quot; &quot;Should capture stdout&quot;\n}\n\n# Test: capture_output captures stderr\ntest_capture_stderr() {\n\n  output=$(capture_output &quot;echo &#39;error output&#39; &gt;&amp;2&quot;)\n  assert_equals &quot;error output&quot; &quot;$output&quot; &quot;Should capture stderr&quot;\n}\n\n# Test: capture_output with successful command\ntest_capture_success() {\n\n  output=$(capture_output &quot;echo success; exit 0&quot;)\n  assert_equals &quot;success&quot; &quot;$output&quot; &quot;Should capture output from successful command&quot;\n}\n\n# Test: capture_output with failed command\ntest_capture_failure() {\n\n  output=$(capture_output &quot;echo failure; exit 1&quot; || true)\n  assert_equals &quot;failure&quot; &quot;$output&quot; &quot;Should capture output from failed command&quot;\n}\n\n# Test: capture_output handles complex commands\ntest_capture_complex() {\n\n  output=$(capture_output &quot;echo line1; echo line2; echo line3&quot;)\n  assert_contains &quot;$output&quot; &quot;line1&quot; &quot;Should contain line1&quot;\n  assert_contains &quot;$output&quot; &quot;line2&quot; &quot;Should contain line2&quot;\n  assert_contains &quot;$output&quot; &quot;line3&quot; &quot;Should contain line3&quot;\n}\n\n# Test: capture_output handles pipes\ntest_capture_pipes() {\n\n  output=$(capture_output &quot;echo &#39;test&#39; | tr &#39;a-z&#39; &#39;A-Z&#39;&quot;)\n  assert_equals &quot;TEST&quot; &quot;$output&quot; &quot;Should handle pipes&quot;\n}\n\n# Test: environment functions exported\ntest_exported_functions() {\n\n  assert_true &quot;type log_info &gt; /dev/null 2&gt;&amp;1&quot; &quot;log_info should be exported&quot;\n  assert_true &quot;type capture_output &gt; /dev/null 2&gt;&amp;1&quot; &quot;capture_output should be exported&quot;\n  assert_true &quot;type setup_test_env &gt; /dev/null 2&gt;&amp;1&quot; &quot;setup_test_env should be exported&quot;\n  assert_true &quot;type cleanup_test_env &gt; /dev/null 2&gt;&amp;1&quot; &quot;cleanup_test_env should be exported&quot;\n}\n\n# Run all tests\nrun_tests() {\n  log_section &quot;Environment Tests&quot;\n\n  test_capture_stdout\n  test_capture_stderr\n  test_capture_success\n  test_capture_failure\n  test_capture_complex\n  test_capture_pipes\n  test_exported_functions\n}\n\nexport -f run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-config.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/__tests/test-config.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test configuration for judge.sh test suite\n# This file is sourced by test files to set common configuration\n\nexport TEST_ROOT=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\n\n# Test directory structure\nexport JUDGE_SH_ROOT=&quot;$(dirname &quot;$TEST_ROOT&quot;)&quot;\nexport JUDGE_SH=&quot;${JUDGE_SH_ROOT}/judge.sh&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-judge-logging.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/__tests/test-judge-logging.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for judge.sh logging and output functions\n\n# Test: log_test produces output\ntest_log_test_output() {\n\n  output=$(log_test &quot;Test message&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Test message&quot; &quot;Should contain message&quot;\n  assert_contains &quot;$output&quot; &quot;TEST&quot; &quot;Should have TEST prefix&quot;\n}\n\n# Test: log_pass produces output\ntest_log_pass_output() {\n\n  output=$(log_pass &quot;Pass message&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Pass message&quot; &quot;Should contain message&quot;\n  assert_contains &quot;$output&quot; &quot;PASS&quot; &quot;Should have PASS prefix&quot;\n}\n\n# Test: log_fail produces output\ntest_log_fail_output() {\n\n  output=$(log_fail &quot;Fail message&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Fail message&quot; &quot;Should contain message&quot;\n  assert_contains &quot;$output&quot; &quot;FAIL&quot; &quot;Should have FAIL prefix&quot;\n}\n\n# Test: log_skip produces output\ntest_log_skip_output() {\n\n  output=$(log_skip &quot;Skip message&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Skip message&quot; &quot;Should contain message&quot;\n  assert_contains &quot;$output&quot; &quot;SKIP&quot; &quot;Should have SKIP prefix&quot;\n}\n\n# Test: log_info produces output\ntest_log_info_output() {\n\n  output=$(log_info &quot;Info message&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Info message&quot; &quot;Should contain message&quot;\n  assert_contains &quot;$output&quot; &quot;INFO&quot; &quot;Should have INFO prefix&quot;\n}\n\n# Test: log_warning produces output\ntest_log_warning_output() {\n\n  output=$(log_warning &quot;Warning message&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Warning message&quot; &quot;Should contain message&quot;\n  assert_contains &quot;$output&quot; &quot;WARN&quot; &quot;Should have WARN prefix&quot;\n}\n\n# Test: log_error produces output\ntest_log_error_output() {\n\n  output=$(log_error &quot;Error message&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Error message&quot; &quot;Should contain message&quot;\n  assert_contains &quot;$output&quot; &quot;ERROR&quot; &quot;Should have ERROR prefix&quot;\n}\n\n# Test: log_success produces output\ntest_log_success_output() {\n\n  output=$(log_success &quot;Success message&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Success message&quot; &quot;Should contain message&quot;\n}\n\n# Test: log_section produces formatted output\ntest_log_section_output() {\n\n  output=$(log_section &quot;Section Title&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Section Title&quot; &quot;Should contain title&quot;\n  assert_contains &quot;$output&quot; &quot;═&quot; &quot;Should have separator&quot;\n}\n\n# Test: logging functions handle empty strings\ntest_log_empty_strings() {\n\n  set +e\n  log_info &quot;&quot; 2&gt;&amp;1 &gt;/dev/null\n  log_warning &quot;&quot; 2&gt;&amp;1 &gt;/dev/null\n  log_error &quot;&quot; 2&gt;&amp;1 &gt;/dev/null\n  result=$?\n  set -e\n  assert_equals 0 $result &quot;Should handle empty strings&quot;\n}\n\n# Test: logging functions handle special characters\ntest_log_special_characters() {\n\n  output=$(log_info &quot;Test with \\$special &amp; &lt;characters&gt;&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;special&quot; &quot;Should handle special characters&quot;\n}\n\n# Test: print_test_summary shows counters\ntest_print_summary() {\n\n  # Write isolated test script\n  cat &gt;test_script.sh &lt;&lt;&#39;SCRIPT_END&#39;\n#!/usr/bin/env bash\n\nTESTS_RUN=10\nTESTS_PASSED=8\nTESTS_FAILED=2\noutput=$(print_test_summary 2&gt;&amp;1)\nif [[ &quot;$output&quot; == *&quot;Total Tests:&quot;* ]] &amp;&amp; \\\n   [[ &quot;$output&quot; == *&quot;Passed:&quot;* ]] &amp;&amp; \\\n   [[ &quot;$output&quot; == *&quot;Failed:&quot;* ]]; then\n    echo &quot;pass&quot;\nelse\n    echo &quot;fail&quot;\nfi\nSCRIPT_END\n\n  result=$(bash test_script.sh)\n  assert_equals &quot;pass&quot; &quot;$result&quot; &quot;Summary should show counters&quot;\n}\n\n# Test: print_test_summary returns success when all pass\ntest_summary_success_return() {\n\n  # Write isolated test script\n  cat &gt;test_script.sh &lt;&lt;&#39;SCRIPT_END&#39;\n#!/usr/bin/env bash\n\nTESTS_RUN=5\nTESTS_PASSED=5\nTESTS_FAILED=0\nprint_test_summary &gt; /dev/null 2&gt;&amp;1\necho $?\nSCRIPT_END\n\n  result=$(bash test_script.sh)\n  assert_equals &quot;0&quot; &quot;$result&quot; &quot;Should return 0 when all pass&quot;\n}\n\n# Test: print_test_summary returns failure when tests fail\ntest_summary_failure_return() {\n\n  # Write isolated test script\n  cat &gt;test_script.sh &lt;&lt;&#39;SCRIPT_END&#39;\n#!/usr/bin/env bash\n\nTESTS_RUN=5\nTESTS_PASSED=3\nTESTS_FAILED=2\nprint_test_summary &gt; /dev/null 2&gt;&amp;1\necho $?\nSCRIPT_END\n\n  result=$(bash test_script.sh)\n  assert_true &quot;[[ $result -ne 0 ]]&quot; &quot;Should return non-zero when tests fail&quot;\n}\n\n# Test: print_test_summary handles zero tests\ntest_summary_zero_tests() {\n\n  # Write isolated test script\n  cat &gt;test_script.sh &lt;&lt;&#39;SCRIPT_END&#39;\n#!/usr/bin/env bash\n\nTESTS_RUN=0\nTESTS_PASSED=0\nTESTS_FAILED=0\noutput=$(print_test_summary 2&gt;&amp;1)\nif [[ &quot;$output&quot; == *&quot;Total Tests:  0&quot;* ]]; then\n    echo &quot;pass&quot;\nelse\n    echo &quot;fail&quot;\nfi\nSCRIPT_END\n\n  result=$(bash test_script.sh)\n  assert_equals &quot;pass&quot; &quot;$result&quot; &quot;Should handle zero tests&quot;\n}\n\n# Test: print_test_summary calculates pass rate\ntest_summary_pass_rate() {\n\n  # Write isolated test script\n  cat &gt;test_script.sh &lt;&lt;&#39;SCRIPT_END&#39;\n#!/usr/bin/env bash\n\nTESTS_RUN=10\nTESTS_PASSED=8\nTESTS_FAILED=2\noutput=$(print_test_summary 2&gt;&amp;1)\nif [[ &quot;$output&quot; == *&quot;80%&quot;* ]]; then\n    echo &quot;pass&quot;\nelse\n    echo &quot;fail&quot;\nfi\nSCRIPT_END\n\n  result=$(bash test_script.sh)\n  assert_equals &quot;pass&quot; &quot;$result&quot; &quot;Should show 80% pass rate&quot;\n}\n\n# Test: logging functions are exported\ntest_functions_exported() {\n\n  assert_true &quot;type log_info &gt; /dev/null 2&gt;&amp;1&quot; &quot;log_info should be available&quot;\n  assert_true &quot;type log_pass &gt; /dev/null 2&gt;&amp;1&quot; &quot;log_pass should be available&quot;\n  assert_true &quot;type log_fail &gt; /dev/null 2&gt;&amp;1&quot; &quot;log_fail should be available&quot;\n  assert_true &quot;type log_section &gt; /dev/null 2&gt;&amp;1&quot; &quot;log_section should be available&quot;\n}\n\n# Run all tests\nrun_tests() {\n  log_section &quot;Logging Tests&quot;\n\n  test_log_test_output\n  test_log_pass_output\n  test_log_fail_output\n  test_log_skip_output\n  test_log_info_output\n  test_log_warning_output\n  test_log_error_output\n  test_log_success_output\n  test_log_section_output\n  test_log_empty_strings\n  test_log_special_characters\n  test_print_summary\n  test_summary_success_return\n  test_summary_failure_return\n  test_summary_zero_tests\n  test_summary_pass_rate\n  test_functions_exported\n}\n\nexport -f run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-judge-cli.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/judge.sh/__tests/test-judge-cli.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for judge.sh CLI interface and commands\n\n# Test: judge without arguments shows usage\ntest_no_args_shows_usage() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;USAGE:&quot; &quot;Should show usage&quot;\n  assert_contains &quot;$output&quot; &quot;COMMANDS:&quot; &quot;Should show commands&quot;\n\n}\n\n# Test: judge help shows usage\ntest_help_command() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;USAGE:&quot; &quot;Should show usage&quot;\n  assert_contains &quot;$output&quot; &quot;COMMANDS:&quot; &quot;Should show commands&quot;\n\n}\n\n# Test: judge --help shows usage\ntest_help_flag() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; --help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;USAGE:&quot; &quot;Should show usage&quot;\n\n}\n\n# Test: judge -h shows usage\ntest_help_short_flag() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; -h 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;USAGE:&quot; &quot;Should show usage&quot;\n\n}\n\n# Test: unknown command shows error\ntest_unknown_command() {\n  set +e\n  output=$(bash &quot;$JUDGE_SH&quot; nonexistent-command 2&gt;&amp;1)\n  exit_code=$?\n  set -e\n  assert_true &quot;[[ $exit_code -ne 0 ]]&quot; &quot;Unknown command should fail&quot;\n  assert_contains &quot;$output&quot; &quot;Unknown command&quot; &quot;Should show error message&quot;\n\n}\n\n# Test: judge run command exists\ntest_run_command_exists() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;run&quot; &quot;Should show run command&quot;\n\n}\n\n# Test: judge setup command exists\ntest_setup_command_exists() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;setup&quot; &quot;Should show setup command&quot;\n\n}\n\n# Test: judge snap command exists\ntest_snap_command_exists() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;snap&quot; &quot;Should show snap command&quot;\n\n}\n\n# Test: usage shows examples\ntest_usage_shows_examples() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;EXAMPLES:&quot; &quot;Should show examples&quot;\n\n}\n\n# Test: usage describes run command\ntest_usage_describes_run() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Run all tests&quot; &quot;Should describe run command&quot;\n\n}\n\n# Test: usage describes setup command\ntest_usage_describes_setup() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;snapshot&quot; &quot;Should describe setup command&quot;\n\n}\n\n# Test: usage describes snap command\ntest_usage_describes_snap() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;Manage snapshots&quot; &quot;Should describe snap command&quot;\n\n}\n\n# Test: command examples shown in help\ntest_command_examples_shown() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;judge.sh run&quot; &quot;Should show run example&quot;\n  assert_contains &quot;$output&quot; &quot;judge.sh setup&quot; &quot;Should show setup example&quot;\n  assert_contains &quot;$output&quot; &quot;judge.sh snap&quot; &quot;Should show snap example&quot;\n\n}\n\n# Test: detailed command help referenced\ntest_detailed_help_referenced() {\n\n  output=$(bash &quot;$JUDGE_SH&quot; help 2&gt;&amp;1)\n  assert_contains &quot;$output&quot; &quot;For detailed command help&quot; &quot;Should mention detailed help&quot;\n\n}\n\n# Run all tests\nrun_tests() {\n  log_section &quot;CLI Tests&quot;\n\n  test_no_args_shows_usage\n  test_help_command\n  test_help_flag\n  test_help_short_flag\n  test_unknown_command\n  test_run_command_exists\n  test_setup_command_exists\n  test_snap_command_exists\n  test_usage_shows_examples\n  test_usage_describes_run\n  test_usage_describes_setup\n  test_usage_describes_snap\n  test_command_examples_shown\n  test_detailed_help_referenced\n}\n\nexport -f run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">leaf-asciinema-addon.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/leaf-asciinema-addon.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# leaf.sh - Beautiful documentation generator with asciinema support\n# Version: 2.2.0\n# Generated by hammer.sh\n\nset -euo pipefail\n\n# Colors for output - only use colors if output is to a terminal or if FORCE_COLOR is set\nexport FORCE_COLOR=${FORCE_COLOR:-}\nif [[ -z &quot;$FORCE_COLOR&quot; ]]; then\n\t\tif [[ &quot;$FORCE_COLOR&quot; = &quot;1&quot; ]]; then\n\t\t\texport RED=&#39;\\033[0;31m&#39;\n\t\t\texport GREEN=&#39;\\033[0;32m&#39;\n\t\t\texport YELLOW=&#39;\\033[1;33m&#39;\n\t\t\texport BLUE=&#39;\\033[0;34m&#39;\n\t\t\texport CYAN=&#39;\\033[0;36m&#39;\n\t\t\texport MAGENTA=&#39;\\033[0;35m&#39;\n\t\t\texport BOLD=&#39;\\033[1m&#39;\n\t\t\texport NC=&#39;\\033[0m&#39;\n\n\t\telse\n\t\t\texport RED=&#39;&#39;\n\t\t\texport GREEN=&#39;&#39;\n\t\t\texport YELLOW=&#39;&#39;\n\t\t\texport BLUE=&#39;&#39;\n\t\t\texport CYAN=&#39;&#39;\n\t\t\texport MAGENTA=&#39;&#39;\n\t\t\texport BOLD=&#39;&#39;\n\t\t\texport NC=&#39;&#39;\n\t\tfi\nelif [[ -t 1 ]] &amp;&amp; [[ -t 2 ]]; then\n\t\texport RED=&#39;\\033[0;31m&#39;\n\t\texport GREEN=&#39;\\033[0;32m&#39;\n\t\texport YELLOW=&#39;\\033[1;33m&#39;\n\t\texport BLUE=&#39;\\033[0;34m&#39;\n\t\texport CYAN=&#39;\\033[0;36m&#39;\n\t\texport MAGENTA=&#39;\\033[0;35m&#39;\n\t\texport BOLD=&#39;\\033[1m&#39;\n\t\texport NC=&#39;\\033[0m&#39;\nelse\n    export RED=&#39;&#39;\n    export GREEN=&#39;&#39;\n    export YELLOW=&#39;&#39;\n    export BLUE=&#39;&#39;\n    export CYAN=&#39;&#39;\n\t\texport MAGENTA=&#39;&#39;\n\t\texport BOLD=&#39;&#39;\n\t\texport NC=&#39;&#39;\nfi\n\n# Default configuration\nPROJECT_DIR=&quot;${1:-.}&quot;\nOUTPUT_DIR=&quot;${PROJECT_DIR}/docs&quot;\nMODE=&quot;docs&quot; # docs or landing\nLOGO_PATH=&quot;&quot;\nBASE_PATH=&quot;/&quot;\nGITHUB_URL=&quot;https://github.com/butter-sh&quot;\nPRIMARY_COLOR=&quot;#86efac&quot;\nSECONDARY_COLOR=&quot;#4ade80&quot;\nDEMOS_DIR=&quot;${PROJECT_DIR}/demos&quot;\n\n# Helper functions (abbreviated for space)\nlog_info() { echo -e &quot;${BLUE}ℹ${NC} $1&quot;; }\nlog_success() { echo -e &quot;${GREEN}✓${NC} $1&quot;; }\nlog_warn() { echo -e &quot;${YELLOW}⚠${NC} $1&quot;; }\nlog_error() { echo -e &quot;${RED}✗${NC} $1&quot;; }\n\n# Show banner\nshow_banner() {\n\tcat &lt;&lt;&#39;EOF&#39;\n╔═══════════════════════════════════════════╗\n║                                           ║\n║  🍃 leaf.sh - Documentation Generator     ║\n║  Now with asciinema demo support! 🎬      ║\n║                                           ║\n╚═══════════════════════════════════════════╝\nEOF\n}\n\n# Show usage\nshow_usage() {\n\tcat &lt;&lt;EOF\n${CYAN}leaf.sh${NC} v2.2.0 - Documentation &amp; Landing Page Generator\n\n${GREEN}COMMANDS:${NC}\n    leaf.sh [project-dir]        Generate documentation\n    leaf.sh --landing            Generate landing page\n    \n    ${YELLOW}# asciinema commands${NC}\n    leaf.sh cast list            List all .cast files in project\n    leaf.sh cast embed &lt;file&gt;    Generate embed code for README\n    leaf.sh cast play &lt;file&gt;     Play a recording\n\n${GREEN}OPTIONS:${NC}\n    --logo PATH              Custom logo file\n    --output DIR             Output directory (default: docs)\n    --base-path PATH         Base path for URLs\n    --github URL             GitHub organization URL\n    --include-demos          Include asciinema demos in docs\n    -h, --help               Show this help\n\n${GREEN}ASCIINEMA INTEGRATION:${NC}\n    leaf.sh automatically detects .cast files in:\n      • demos/ directory\n      • project root\n    \n    Use --include-demos to embed them in documentation\n\n${GREEN}EXAMPLES:${NC}\n    ${YELLOW}# Generate docs with demos${NC}\n    leaf.sh . --include-demos\n    \n    ${YELLOW}# List all recordings${NC}\n    leaf.sh cast list\n    \n    ${YELLOW}# Get embed code for README${NC}\n    leaf.sh cast embed demos/my-demo.cast\n\nEOF\n}\n\n# Check if command exists\ncommand_exists() {\n\tcommand -v &quot;$1&quot; &amp;&gt;/dev/null\n}\n\n# =====================================================\n# ASCIINEMA FUNCTIONS\n# =====================================================\n\ncast_list() {\n\tlog_info &quot;Searching for .cast files...&quot;\n\n\tlocal found=0\n\tlocal search_dirs=(&quot;$PROJECT_DIR&quot; &quot;$DEMOS_DIR&quot;)\n\n\tfor dir in &quot;${search_dirs[@]}&quot;; do\n\t\tif [[ ! -d &quot;$dir&quot; ]]; then\n\t\t\tcontinue\n\t\tfi\n\n\t\twhile IFS= read -r -d &#39;&#39; cast_file; do\n\t\t\tif [[ -f &quot;$cast_file&quot; ]]; then\n\t\t\t\tlocal rel_path=&quot;${cast_file#${PROJECT_DIR}/}&quot;\n\t\t\t\tlocal size=$(du -h &quot;$cast_file&quot; | cut -f1)\n\t\t\t\tlocal date=$(date -r &quot;$cast_file&quot; &quot;+%Y-%m-%d %H:%M&quot; 2&gt;/dev/null || echo &quot;unknown&quot;)\n\t\t\t\techo -e &quot;  ${GREEN}•${NC} $rel_path  ${CYAN}($size, $date)${NC}&quot;\n\t\t\t\tfound=1\n\t\t\tfi\n\t\tdone &lt; &lt;(find &quot;$dir&quot; -maxdepth 2 -name &quot;*.cast&quot; -print0 2&gt;/dev/null || true)\n\tdone\n\n\tif [[ $found -eq 0 ]]; then\n\t\tlog_info &quot;No .cast files found&quot;\n\t\techo &quot;&quot;\n\t\tlog_info &quot;Create recordings with: init.sh rec my-demo&quot;\n\tfi\n}\n\ncast_embed() {\n\tlocal cast_file=&quot;$1&quot;\n\n\tif [[ -z &quot;$cast_file&quot; ]]; then\n\t\tlog_error &quot;Usage: leaf.sh cast embed &lt;cast-file&gt;&quot;\n\t\treturn 1\n\tfi\n\n\t# Check if file exists (try relative and absolute paths)\n\tif [[ ! -f &quot;$cast_file&quot; ]]; then\n\t\tif [[ -f &quot;$PROJECT_DIR/$cast_file&quot; ]]; then\n\t\t\tcast_file=&quot;$PROJECT_DIR/$cast_file&quot;\n\t\telif [[ -f &quot;$DEMOS_DIR/$cast_file&quot; ]]; then\n\t\t\tcast_file=&quot;$DEMOS_DIR/$cast_file&quot;\n\t\telse\n\t\t\tlog_error &quot;File not found: $cast_file&quot;\n\t\t\treturn 1\n\t\tfi\n\tfi\n\n\tlocal filename=$(basename &quot;$cast_file&quot;)\n\n\tlog_info &quot;Embed code for: $filename&quot;\n\techo &quot;&quot;\n\techo &quot;After uploading to asciinema.org, use:&quot;\n\techo &quot;&quot;\n\tcat &lt;&lt;&#39;EOF&#39;\n&lt;!-- Replace YOUR-ID with your asciinema recording ID --&gt;\n&lt;a href=&quot;https://asciinema.org/a/YOUR-ID&quot; target=&quot;_blank&quot;&gt;\n  &lt;img src=&quot;https://asciinema.org/a/YOUR-ID.svg&quot; width=&quot;600&quot;/&gt;\n&lt;/a&gt;\nEOF\n\techo &quot;&quot;\n\tlog_info &quot;Upload with: init.sh upload $filename&quot;\n}\n\ncast_play() {\n\tlocal cast_file=&quot;$1&quot;\n\n\tif [[ -z &quot;$cast_file&quot; ]]; then\n\t\tlog_error &quot;Usage: leaf.sh cast play &lt;cast-file&gt;&quot;\n\t\treturn 1\n\tfi\n\n\tif ! command_exists &quot;asciinema&quot;; then\n\t\tlog_error &quot;asciinema not installed&quot;\n\t\tlog_info &quot;Install: brew install asciinema&quot;\n\t\treturn 1\n\tfi\n\n\t# Try different paths\n\tif [[ ! -f &quot;$cast_file&quot; ]]; then\n\t\tif [[ -f &quot;$PROJECT_DIR/$cast_file&quot; ]]; then\n\t\t\tcast_file=&quot;$PROJECT_DIR/$cast_file&quot;\n\t\telif [[ -f &quot;$DEMOS_DIR/$cast_file&quot; ]]; then\n\t\t\tcast_file=&quot;$DEMOS_DIR/$cast_file&quot;\n\t\telse\n\t\t\tlog_error &quot;File not found: $cast_file&quot;\n\t\t\treturn 1\n\t\tfi\n\tfi\n\n\tlog_info &quot;Playing: $cast_file&quot;\n\tasciinema play &quot;$cast_file&quot;\n}\n\n# Scan for asciinema demos\nscan_demos() {\n\tlocal demos=()\n\n\tif [[ ! -d &quot;$DEMOS_DIR&quot; ]]; then\n\t\treturn\n\tfi\n\n\twhile IFS= read -r -d &#39;&#39; cast_file; do\n\t\tif [[ -f &quot;$cast_file&quot; ]]; then\n\t\t\tdemos+=(&quot;$cast_file&quot;)\n\t\tfi\n\tdone &lt; &lt;(find &quot;$DEMOS_DIR&quot; -name &quot;*.cast&quot; -print0 2&gt;/dev/null || true)\n\n\tprintf &#39;%s\\n&#39; &quot;${demos[@]}&quot;\n}\n\n# Generate demo section HTML\ngenerate_demos_section() {\n\tlocal include_demos=&quot;${1:-false}&quot;\n\n\tif [[ &quot;$include_demos&quot; != &quot;true&quot; ]]; then\n\t\techo &quot;&quot;\n\t\treturn\n\tfi\n\n\tlocal demo_files=($(scan_demos))\n\n\tif [[ ${#demo_files[@]} -eq 0 ]]; then\n\t\tlog_warn &quot;No demo files found in $DEMOS_DIR&quot;\n\t\techo &quot;&quot;\n\t\treturn\n\tfi\n\n\tlog_success &quot;Found ${#demo_files[@]} demo recordings&quot;\n\n\tcat &lt;&lt;&#39;EOF&#39;\n    &lt;section id=&quot;demos&quot; class=&quot;py-16 px-4&quot;&gt;\n        &lt;div class=&quot;max-w-7xl mx-auto&quot;&gt;\n            &lt;h2 class=&quot;text-4xl font-bold mb-12 text-center text-slate-900 dark:text-white&quot;&gt;🎬 Demos&lt;/h2&gt;\n            &lt;div class=&quot;grid gap-8&quot;&gt;\nEOF\n\n\tfor demo_file in &quot;${demo_files[@]}&quot;; do\n\t\tlocal demo_name=$(basename &quot;$demo_file&quot; .cast)\n\t\tlocal rel_path=&quot;${demo_file#${PROJECT_DIR}/}&quot;\n\n\t\tcat &lt;&lt;EOF\n                &lt;div class=&quot;bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden&quot;&gt;\n                    &lt;div class=&quot;bg-gradient-to-r from-purple-500 to-purple-600 px-6 py-4&quot;&gt;\n                        &lt;h3 class=&quot;text-xl font-semibold text-white&quot;&gt;${demo_name}&lt;/h3&gt;\n                        &lt;p class=&quot;text-purple-100 text-sm&quot;&gt;${rel_path}&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div class=&quot;p-6&quot;&gt;\n                        &lt;p class=&quot;text-slate-600 dark:text-slate-300 mb-4&quot;&gt;\n                            Terminal recording demonstrating ${demo_name}\n                        &lt;/p&gt;\n                        &lt;div class=&quot;bg-slate-100 dark:bg-slate-900 rounded-lg p-4&quot;&gt;\n                            &lt;p class=&quot;text-sm text-slate-500 dark:text-slate-400&quot;&gt;\n                                📁 File: &lt;code class=&quot;text-purple-600 dark:text-purple-400&quot;&gt;${rel_path}&lt;/code&gt;\n                            &lt;/p&gt;\n                            &lt;p class=&quot;text-sm text-slate-500 dark:text-slate-400 mt-2&quot;&gt;\n                                🎬 Play: &lt;code class=&quot;text-green-600 dark:text-green-400&quot;&gt;asciinema play ${rel_path}&lt;/code&gt;\n                            &lt;/p&gt;\n                            &lt;p class=&quot;text-sm text-slate-500 dark:text-slate-400 mt-2&quot;&gt;\n                                ☁️  Upload to embed: &lt;code class=&quot;text-blue-600 dark:text-blue-400&quot;&gt;init.sh upload ${rel_path}&lt;/code&gt;\n                            &lt;/p&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\nEOF\n\tdone\n\n\tcat &lt;&lt;&#39;EOF&#39;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\nEOF\n}\n\n# Main documentation generation (abbreviated - keeping core structure)\n# [Previous leaf.sh functions would go here but abbreviated for space...]\n\n# Main function\nmain() {\n\t# Handle cast commands first\n\tif [[ $# -gt 0 ]]; then\n\t\tcase $1 in\n\t\tcast)\n\t\t\tshift\n\t\t\tcase &quot;${1:-list}&quot; in\n\t\t\tlist | ls)\n\t\t\t\tcast_list\n\t\t\t\texit 0\n\t\t\t\t;;\n\t\t\tembed)\n\t\t\t\tshift\n\t\t\t\tcast_embed &quot;$@&quot;\n\t\t\t\texit 0\n\t\t\t\t;;\n\t\t\tplay)\n\t\t\t\tshift\n\t\t\t\tcast_play &quot;$@&quot;\n\t\t\t\texit 0\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tlog_error &quot;Unknown cast command: $1&quot;\n\t\t\t\tshow_usage\n\t\t\t\texit 1\n\t\t\t\t;;\n\t\t\tesac\n\t\t\t;;\n\t\t-h | --help)\n\t\t\tshow_usage\n\t\t\texit 0\n\t\t\t;;\n\t\tesac\n\tfi\n\n\tshow_banner\n\n\t# Parse other arguments and generate docs...\n\t# [Rest of leaf.sh logic would go here...]\n\n\tlog_success &quot;Generation complete!&quot;\n}\n\n# Run main function\nmain &quot;$@&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">leaf.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/leaf.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# leaf.sh - Beautiful documentation and landing page generator\n# Version: 2.2.0 - Now using myst.sh templating engine\n# Generated by hammer.sh\n\n# Only set strict mode when running directly (not sourced)\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n\tset -euo pipefail\nfi\n\n# Get script directory\nif command -v dirname &gt;/dev/null 2&gt;&amp;1; then\n\tSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nelse\n\t# Fallback if dirname is not available\n\tSCRIPT_DIR=&quot;$(cd &quot;${BASH_SOURCE[0]%/*}&quot; &amp;&amp; pwd)&quot;\nfi\nREAL_BASH_SOURCE=&quot;$(readlink -f &quot;${BASH_SOURCE[0]}&quot;)&quot;\nREAL_SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${REAL_BASH_SOURCE}&quot;)&quot; &amp;&amp; pwd)&quot;\nTEMPLATES_DIR=&quot;${REAL_SCRIPT_DIR}/templates&quot;\n\n# Colors for output\nexport FORCE_COLOR=${FORCE_COLOR:-}\nif [[ -n &quot;$FORCE_COLOR&quot; ]] &amp;&amp; [[ &quot;$FORCE_COLOR&quot; = &quot;1&quot; ]]; then\n\texport RED=&#39;\\033[0;31m&#39;\n\texport GREEN=&#39;\\033[0;32m&#39;\n\texport YELLOW=&#39;\\033[1;33m&#39;\n\texport BLUE=&#39;\\033[0;34m&#39;\n\texport CYAN=&#39;\\033[0;36m&#39;\n\texport MAGENTA=&#39;\\033[0;35m&#39;\n\texport BOLD=&#39;\\033[1m&#39;\n\texport NC=&#39;\\033[0m&#39;\nelif [[ -t 1 ]] &amp;&amp; [[ -t 2 ]]; then\n\texport RED=&#39;\\033[0;31m&#39;\n\texport GREEN=&#39;\\033[0;32m&#39;\n\texport YELLOW=&#39;\\033[1;33m&#39;\n\texport BLUE=&#39;\\033[0;34m&#39;\n\texport CYAN=&#39;\\033[0;36m&#39;\n\texport MAGENTA=&#39;\\033[0;35m&#39;\n\texport BOLD=&#39;\\033[1m&#39;\n\texport NC=&#39;\\033[0m&#39;\nelse\n\texport RED=&#39;&#39;\n\texport GREEN=&#39;&#39;\n\texport YELLOW=&#39;&#39;\n\texport BLUE=&#39;&#39;\n\texport CYAN=&#39;&#39;\n\texport MAGENTA=&#39;&#39;\n\texport BOLD=&#39;&#39;\n\texport NC=&#39;&#39;\nfi\n\n# Default configuration\nPROJECT_DIR=&quot;&quot;\nOUTPUT_DIR=&quot;&quot;\nMODE=&quot;docs&quot;\nLOGO_PATH=&quot;&quot;\nBASE_PATH=&quot;/&quot;\nGITHUB_URL=&quot;https://github.com/butter-sh&quot;\nPROJECTS_FILE=&quot;&quot;\nPROJECTS_JSON=&quot;&quot;\n\n# Helper functions\nlog_info() {\n\techo -e &quot;${BLUE}ℹ${NC} $1&quot;\n}\n\nlog_success() {\n\techo -e &quot;${GREEN}✓${NC} $1&quot;\n}\n\nlog_warn() {\n\techo -e &quot;${YELLOW}⚠${NC} $1&quot;\n}\n\nlog_error() {\n\techo -e &quot;${RED}✗${NC} $1&quot;\n}\n\nlog_debug() {\n\tif [[ &quot;${DEBUG:-0}&quot; == &quot;1&quot; ]]; then\n\t\techo -e &quot;${MAGENTA}🔍${NC} $1&quot; &gt;&amp;2\n\tfi\n}\n\n# Find myst.sh\nfind_myst() {\n\tlocal myst_path=&quot;&quot;\n\t\n\t# Try .arty/bin/myst first\n\tif [[ -x &quot;${PWD}/.arty/bin/myst&quot; ]]; then\n\t\tmyst_path=&quot;${PWD}/.arty/bin/myst&quot;\n\t# Try sibling myst directory\n\telif [[ -x &quot;${PWD}/../myst/myst.sh&quot; ]]; then\n\t\tmyst_path=&quot;${PWD}/../myst/myst.sh&quot;\n\t# Try system myst\n\telif command -v myst &amp;&gt;/dev/null; then\n\t\tmyst_path=&quot;myst&quot;\n\telse\n\t\tlog_error &quot;myst.sh not found. Please install it or run &#39;arty deps&#39; in leaf.sh directory&quot;\n\t\treturn 1\n\tfi\n\t\n\techo &quot;$myst_path&quot;\n}\n\n# Render template with myst\nrender_with_myst() {\n\tlocal template=&quot;$1&quot;\n\tlocal output=&quot;$2&quot;\n\tlocal json_file=&quot;$3&quot;\n\t\n\tlocal myst_path=$(find_myst)\n\t[[ -z &quot;$myst_path&quot; ]] &amp;&amp; return 1\n\t\n\tlog_debug &quot;Using myst: $myst_path&quot;\n\tlog_debug &quot;Template: $template&quot;\n\tlog_debug &quot;Output: $output&quot;\n\tlog_debug &quot;JSON file: $json_file&quot;\n\t\n\t# Create output directory\n\tmkdir -p &quot;$(dirname &quot;$output&quot;)&quot;\n\t\n\t# Check if template exists\n\tif [[ ! -f &quot;$template&quot; ]]; then\n\t\tlog_error &quot;Template not found: $template&quot;\n\t\treturn 1\n\tfi\n\t\n\t# Check if JSON file exists\n\tif [[ ! -f &quot;$json_file&quot; ]]; then\n\t\tlog_error &quot;JSON data file not found: $json_file&quot;\n\t\treturn 1\n\tfi\n\t\n\t# Render with myst - capture both stdout and stderr\n\tlocal myst_output\n\tlocal myst_exit_code\n\t\n\tif myst_output=$(bash &quot;$myst_path&quot; \\\n\t\t-j &quot;$json_file&quot; \\\n\t\t-p &quot;${TEMPLATES_DIR}/partials&quot; \\\n\t\t-o &quot;$output&quot; \\\n\t\t&quot;$template&quot; 2&gt;&amp;1); then\n\t\tmyst_exit_code=0\n\telse\n\t\tmyst_exit_code=$?\n\tfi\n\t\n\t# Show myst output only if debug is enabled or if there was an error\n\tif [[ &quot;${DEBUG:-0}&quot; == &quot;1&quot; ]] || [[ $myst_exit_code -ne 0 ]]; then\n\t\techo &quot;$myst_output&quot; | grep -v &quot;^\\[&quot; || true\n\tfi\n\t\n\tif [[ $myst_exit_code -ne 0 ]]; then\n\t\tlog_error &quot;Myst rendering failed with exit code $myst_exit_code&quot;\n\t\treturn $myst_exit_code\n\tfi\n\t\n\t# Verify output was created\n\tif [[ ! -f &quot;$output&quot; ]]; then\n\t\tlog_error &quot;Myst did not create output file: $output&quot;\n\t\treturn 1\n\tfi\n\t\n\treturn 0\n}\n\n# Check dependencies\ncheck_dependencies() {\n\tlocal missing_deps=()\n\n\tif ! command -v yq &amp;&gt;/dev/null; then\n\t\tmissing_deps+=(&quot;yq&quot;)\n\tfi\n\n\tif ! command -v jq &amp;&gt;/dev/null; then\n\t\tmissing_deps+=(&quot;jq&quot;)\n\tfi\n\n\tif [ ${#missing_deps[@]} -gt 0 ]; then\n\t\tlog_error &quot;Missing required dependencies: ${missing_deps[*]}&quot;\n\t\tlog_info &quot;Install yq: https://github.com/mikefarah/yq#install&quot;\n\t\tlog_info &quot;Install jq: https://stedolan.github.io/jq/download/&quot;\n\t\treturn 1\n\tfi\n\n\t# Check for myst\n\tif ! find_myst &gt;/dev/null 2&gt;&amp;1; then\n\t\tlog_error &quot;myst.sh not found&quot;\n\t\tlog_info &quot;Run &#39;arty deps&#39; in the leaf.sh directory to install dependencies&quot;\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\n# Show usage\nshow_usage() {\n\tcat &lt;&lt;EOF\n${CYAN}╔═══════════════════════════════════════════╗${NC}\n${CYAN}║                                           ║${NC}\n${CYAN}║   🌿 leaf.sh - Documentation Generator   ║${NC}\n${CYAN}║                                           ║${NC}\n${CYAN}╚═══════════════════════════════════════════╝${NC}\n\n${GREEN}DESCRIPTION:${NC}\n    leaf.sh generates beautiful static HTML documentation from arty.sh projects\n    and creates stylish landing pages for butter.sh with modern design.\n    \n    ${CYAN}Now powered by myst.sh templating engine!${NC}\n\n${GREEN}USAGE:${NC}\n    ${CYAN}# Generate documentation for arty.sh project${NC}\n    leaf.sh [project-dir] [options]\n    \n    ${CYAN}# Generate butter.sh landing page${NC}\n    leaf.sh --landing [options]\n\n${GREEN}OPTIONS:${NC}\n    ${YELLOW}--landing${NC}              Generate butter.sh landing page instead of docs\n    ${YELLOW}--logo${NC} PATH            Path to logo/icon file\n    ${YELLOW}--base-path${NC} PATH       Base path for HTML links (default: /)\n    ${YELLOW}--github${NC} URL           GitHub organization URL\n    ${YELLOW}--projects${NC} JSON        JSON array of projects for landing page\n    ${YELLOW}--projects-file${NC} FILE   JSON file containing projects array\n    ${YELLOW}-o, --output${NC} DIR       Output directory (default: docs)\n    ${YELLOW}-h, --help${NC}             Show this help message\n    ${YELLOW}--version${NC}              Show version information\n    ${YELLOW}--debug${NC}                Enable debug output\n\n${GREEN}DOCUMENTATION MODE:${NC}\n    Generates beautiful static HTML documentation from an arty.sh project\n    including README, source files, examples, and project metadata.\n\n    ${CYAN}Features:${NC}\n    • Modern, responsive design with Tailwind CSS\n    • Syntax highlighting for code blocks\n    • Dark/light theme toggle\n    • Mobile-friendly layout\n    • Reads project metadata from arty.yml\n\n${GREEN}LANDING PAGE MODE:${NC}\n    Generates a stylish landing page for butter.sh with carbon theme.\n\n    ${CYAN}Features:${NC}\n    • Modern minimalistic theme\n    • Hero section with gradient CTA buttons\n    • Responsive header with mobile menu\n    • Theme switcher (dark/light mode)\n    • Project cards with hover effects\n    • Customizable project list via JSON\n\n${GREEN}EXAMPLES:${NC}\n    ${CYAN}# Generate docs for current directory${NC}\n    leaf.sh\n\n    ${CYAN}# Generate docs for specific project${NC}\n    leaf.sh /path/to/project --logo ./icon.svg\n\n    ${CYAN}# Generate with custom output directory${NC}\n    leaf.sh /path/to/project -o ./public\n\n    ${CYAN}# Generate butter.sh landing page${NC}\n    leaf.sh --landing --github https://github.com/my-org\n\n    ${CYAN}# Generate landing with projects from file${NC}\n    leaf.sh --landing --projects-file ./projects.json\n\n${GREEN}DEPENDENCIES:${NC}\n    • ${YELLOW}yq${NC} - YAML parser (required)\n      Install: https://github.com/mikefarah/yq#install\n    • ${YELLOW}jq${NC} - JSON processor (required)\n      Install: https://stedolan.github.io/jq/download/\n    • ${YELLOW}myst.sh${NC} - Templating engine (required)\n      Install: Run &#39;arty deps&#39; in leaf.sh directory\n\n${GREEN}PROJECT STRUCTURE:${NC}\n    For best results, structure your arty.sh project like this:\n    \n    your-project/\n    ├── arty.yml           ${BLUE}# Project metadata${NC}\n    ├── README.md          ${BLUE}# Main documentation${NC}\n    ├── LICENSE            ${BLUE}# License file${NC}\n    ├── main.sh            ${BLUE}# Source files${NC}\n    ├── _assets/\n    │   └── icon/\n    │       └── icon.svg   ${BLUE}# Project icon${NC}\n    └── examples/\n        └── usage.sh       ${BLUE}# Example files${NC}\n\n${GREEN}PROJECTS JSON FORMAT:${NC}\n    For landing page mode, projects JSON should be an array:\n    [\n      {\n        &quot;url&quot;: &quot;https://project.com&quot;,\n        &quot;label&quot;: &quot;Project Name&quot;,\n        &quot;desc&quot;: &quot;Project description&quot;,\n        &quot;class&quot;: &quot;card-project&quot;\n      }\n    ]\n\n${GREEN}SUPPORTED FILE TYPES:${NC}\n    Shell (.sh, .bash), JavaScript (.js), Python (.py), Ruby (.rb),\n    Go (.go), Rust (.rs), Java (.java), C/C++ (.c, .h, .cpp, .hpp)\n\n${GREEN}VERSION:${NC}\n    leaf.sh v2.2.0\n\nEOF\n}\n\n# Show version\nshow_version() {\n\tcat &lt;&lt;EOF\n${CYAN}leaf.sh${NC} version ${GREEN}2.2.0${NC}\nPart of the ${CYAN}butter.sh${NC} ecosystem\n\n${BLUE}Powered by:${NC}\n  • myst.sh templating engine\n  • yq YAML parser\n  • jq JSON processor\n\n${BLUE}GitHub:${NC} https://github.com/butter-sh/leaf.sh\nEOF\n}\n\n# Parse command line arguments\nparse_args() {\n\tlocal projects_json=&quot;&quot;\n\tPROJECTS_JSON=&quot;&quot;\n\n\twhile [[ $# -gt 0 ]]; do\n\t\tcase $1 in\n\t\t-h | --help)\n\t\t\tshow_usage\n\t\t\texit 0\n\t\t\t;;\n\t\t--version)\n\t\t\tshow_version\n\t\t\texit 0\n\t\t\t;;\n\t\t--debug)\n\t\t\tDEBUG=1\n\t\t\tshift\n\t\t\t;;\n\t\t--landing)\n\t\t\tMODE=&quot;landing&quot;\n\t\t\tshift\n\t\t\t;;\n\t\t--logo)\n\t\t\tLOGO_PATH=&quot;$2&quot;\n\t\t\tshift 2\n\t\t\t;;\n\t\t--base-path)\n\t\t\tBASE_PATH=&quot;$2&quot;\n\t\t\tshift 2\n\t\t\t;;\n\t\t--github)\n\t\t\tGITHUB_URL=&quot;$2&quot;\n\t\t\tshift 2\n\t\t\t;;\n\t\t--projects)\n\t\t\tprojects_json=&quot;$2&quot;\n\t\t\tshift 2\n\t\t\t;;\n\t\t--projects-file)\n\t\t\tPROJECTS_FILE=&quot;$2&quot;\n\t\t\tshift 2\n\t\t\t;;\n\t\t-o | --output)\n\t\t\tOUTPUT_DIR=&quot;$2&quot;\n\t\t\tshift 2\n\t\t\t;;\n\t\t-*)\n\t\t\tlog_error &quot;Unknown option: $1&quot;\n\t\t\techo\n\t\t\tshow_usage\n\t\t\texit 1\n\t\t\t;;\n\t\t*)\n\t\t\tPROJECT_DIR=&quot;$1&quot;\n\t\t\tshift\n\t\t\t;;\n\t\tesac\n\tdone\n\n\tif [[ -n &quot;$projects_json&quot; ]]; then\n\t\tPROJECTS_JSON=&quot;$projects_json&quot;\n\tfi\n\t\n\t# Set defaults after parsing\n\tif [[ -z &quot;$PROJECT_DIR&quot; ]]; then\n\t\tPROJECT_DIR=&quot;.&quot;\n\tfi\n\tif [[ -z &quot;$OUTPUT_DIR&quot; ]]; then\n\t\tif [[ &quot;$MODE&quot; == &quot;landing&quot; ]]; then\n\t\t\tOUTPUT_DIR=&quot;output&quot;\n\t\telse\n\t\t\tOUTPUT_DIR=&quot;${PROJECT_DIR}/docs&quot;\n\t\tfi\n\tfi\n}\n\n# Parse YAML using yq\nparse_yaml() {\n\tlocal file=&quot;$1&quot;\n\tlocal key=&quot;$2&quot;\n\n\tif [[ ! -f &quot;$file&quot; ]]; then\n\t\tlog_debug &quot;YAML file not found: $file&quot;\n\t\techo &quot;&quot;\n\t\treturn\n\tfi\n\n\tlocal value=$(yq eval &quot;.${key}&quot; &quot;$file&quot; 2&gt;/dev/null | grep -v &#39;^null$&#39; || echo &quot;&quot;)\n\tlog_debug &quot;Parsed ${key} from ${file}: ${value}&quot;\n\techo &quot;$value&quot;\n}\n\n# Validate and parse JSON\nparse_json() {\n\tlocal json_input=&quot;$1&quot;\n\tlocal query=&quot;${2:-.}&quot;\n\n\tlog_debug &quot;Parsing JSON with query: $query&quot;\n\n\tlocal result\n\tlocal jq_error\n\tif ! result=$(echo &quot;$json_input&quot; | jq -r &quot;$query&quot; 2&gt;&amp;1); then\n\t\techo &quot;Invalid JSON format&quot; &gt;&amp;2\n\t\treturn 1\n\tfi\n\t\n\t# Check if jq returned an error message\n\tif [[ &quot;$result&quot; =~ &quot;parse error&quot; ]]; then\n\t\techo &quot;Invalid JSON format&quot; &gt;&amp;2\n\t\treturn 1\n\tfi\n\t\n\tlog_debug &quot;JSON parsed successfully&quot;\n\techo &quot;$result&quot;\n\treturn 0\n}\n\n# Validate projects JSON\nvalidate_projects_json() {\n\tlocal json=&quot;$1&quot;\n\n\tlog_debug &quot;Validating projects JSON structure&quot;\n\tlog_debug &quot;JSON content: $json&quot;\n\tlog_debug &quot;JSON length: ${#json}&quot;\n\n\tif ! echo &quot;$json&quot; | jq -e &#39;type == &quot;array&quot;&#39; &gt;/dev/null 2&gt;&amp;1; then\n\t\techo &quot;Projects JSON must be an array&quot; &gt;&amp;2\n\t\tlog_debug &quot;Failed validation check&quot;\n\t\treturn 1\n\tfi\n\n\tlocal count=$(echo &quot;$json&quot; | jq &#39;length&#39;)\n\tif [[ &quot;$count&quot; -eq 0 ]]; then\n\t\tlog_warn &quot;Projects JSON array is empty&quot;\n\tfi\n\n\tlog_debug &quot;Found $count project(s) in JSON&quot;\n\treturn 0\n}\n\n# Read JSON from file\nread_json_file() {\n\tlocal file=&quot;$1&quot;\n\n\tif [[ ! -f &quot;$file&quot; ]]; then\n\t\techo &quot;JSON file not found: $file&quot; &gt;&amp;2\n\t\treturn 1\n\tfi\n\n\t# Redirect all output to stderr to avoid contaminating return value\n\texec 3&gt;&amp;1  # Save stdout\n\texec 1&gt;&amp;2  # Redirect stdout to stderr\n\n\tlog_debug &quot;Reading JSON from file: $file&quot;\n\n\tlocal json\n\tif json=$(jq -c &#39;.&#39; &quot;$file&quot; 2&gt;/dev/null); then\n\t\tlog_debug &quot;Raw JSON output: &#39;$json&#39;&quot;\n\t\tlog_debug &quot;JSON length: ${#json} chars&quot;\n\t\tlog_success &quot;JSON file loaded successfully&quot;\n\t\t\n\t\t# Restore stdout and output JSON\n\t\texec 1&gt;&amp;3\n\t\techo &quot;$json&quot;\n\t\treturn 0\n\telse\n\t\techo &quot;Failed to parse JSON file: $file&quot; &gt;&amp;2\n\t\tlog_debug &quot;jq exit code: $?&quot;\n\t\texec 1&gt;&amp;3  # Restore stdout\n\t\treturn 1\n\tfi\n}\n\n# Read file safely\nread_file() {\n\tlocal file=&quot;$1&quot;\n\tif [[ -f &quot;$file&quot; ]]; then\n\t\tcat &quot;$file&quot;\n\telse\n\t\tlog_debug &quot;File not found: $file&quot;\n\t\techo &quot;&quot;\n\tfi\n}\n\n# Detect language from file extension\ndetect_language() {\n\tlocal file=&quot;$1&quot;\n\tlocal ext=&quot;${file##*.}&quot;\n\n\tcase &quot;$ext&quot; in\n\tsh | bash) echo &quot;bash&quot; ;;\n\tjs) echo &quot;javascript&quot; ;;\n\tts) echo &quot;typescript&quot; ;;\n\tpy) echo &quot;python&quot; ;;\n\trb) echo &quot;ruby&quot; ;;\n\tgo) echo &quot;go&quot; ;;\n\trs) echo &quot;rust&quot; ;;\n\tjava) echo &quot;java&quot; ;;\n\tc | h) echo &quot;c&quot; ;;\n\tcpp | cc | cxx | hpp) echo &quot;cpp&quot; ;;\n\t*) echo &quot;plaintext&quot; ;;\n\tesac\n}\n\n# Get icon path\nget_icon() {\n\tif [[ -n &quot;$LOGO_PATH&quot; &amp;&amp; -f &quot;$LOGO_PATH&quot; ]]; then\n\t\tlog_debug &quot;Using custom logo: $LOGO_PATH&quot;\n\t\techo &quot;$LOGO_PATH&quot;\n\t\treturn\n\tfi\n\n\tlocal icon_dir=&quot;${PROJECT_DIR}/_assets/icon&quot;\n\tlocal icon_files=(&quot;icon.svg&quot; &quot;icon-v2.svg&quot; &quot;icon-simple.svg&quot; &quot;icon.png&quot;)\n\n\tfor icon_file in &quot;${icon_files[@]}&quot;; do\n\t\tif [[ -f &quot;${icon_dir}/${icon_file}&quot; ]]; then\n\t\t\tlog_debug &quot;Found icon: ${icon_dir}/${icon_file}&quot;\n\t\t\techo &quot;${icon_dir}/${icon_file}&quot;\n\t\t\treturn\n\t\tfi\n\tdone\n\n\techo &quot;&quot;\n}\n\n# Scan source files\nscan_source_files() {\n\tlocal files=()\n\n\tlog_debug &quot;Scanning source files in: $PROJECT_DIR&quot;\n\n\twhile IFS= read -r -d $&#39;\\0&#39; file; do\n\t\tlocal rel_path=&quot;${file#${PROJECT_DIR}/}&quot;\n\t\tif [[ &quot;$rel_path&quot; =~ ^(docs|examples|node_modules|\\.git|\\.)|\\\\.min\\\\. ]]; then\n\t\t\tcontinue\n\t\tfi\n\t\tfiles+=(&quot;$file&quot;)\n\t\tlog_debug &quot;Found source file: $rel_path&quot;\n\tdone &lt; &lt;(find &quot;$PROJECT_DIR&quot; -type f \\( -name &quot;*.sh&quot; -o -name &quot;*.bash&quot; -o -name &quot;*.js&quot; -o -name &quot;*.py&quot; -o -name &quot;*.rb&quot; -o -name &quot;*.go&quot; -o -name &quot;*.rs&quot; \\) -print0 2&gt;/dev/null || true)\n\n\tprintf &#39;%s\\n&#39; &quot;${files[@]}&quot;\n}\n\n# Scan example files\nscan_examples() {\n\tlocal examples_dir=&quot;${PROJECT_DIR}/examples&quot;\n\tlocal examples=()\n\n\tif [[ ! -d &quot;$examples_dir&quot; ]]; then\n\t\tlog_debug &quot;Examples directory not found: $examples_dir&quot;\n\t\treturn\n\tfi\n\n\tlog_debug &quot;Scanning examples in: $examples_dir&quot;\n\n\twhile IFS= read -r -d $&#39;\\0&#39; file; do\n\t\texamples+=(&quot;$file&quot;)\n\t\tlog_debug &quot;Found example: ${file#${examples_dir}/}&quot;\n\tdone &lt; &lt;(find &quot;$examples_dir&quot; -type f -print0 2&gt;/dev/null || true)\n\n\tprintf &#39;%s\\n&#39; &quot;${examples[@]}&quot;\n}\n\n# Generate source files HTML\ngenerate_source_html() {\n\tlocal sources=(&quot;$@&quot;)\n\tlocal html=&quot;&quot;\n\n\tfor file in &quot;${sources[@]}&quot;; do\n\t\t[[ ! -f &quot;$file&quot; ]] &amp;&amp; continue\n\t\tlocal name=$(basename &quot;$file&quot;)\n\t\tlocal rel=&quot;${file#${PROJECT_DIR}/}&quot;\n\t\tlocal lang=$(detect_language &quot;$file&quot;)\n\t\tlocal code=$(cat &quot;$file&quot; | jq -Rs .)\n\t\t\n\t\thtml+=&quot;&lt;div class=\\&quot;bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\\&quot;&gt;&quot;\n\t\thtml+=&quot;&lt;div class=\\&quot;bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\\&quot;&gt;&quot;\n\t\thtml+=&quot;&lt;h3 class=\\&quot;text-xl font-semibold text-white\\&quot;&gt;${name}&lt;/h3&gt;&quot;\n\t\thtml+=&quot;&lt;p class=\\&quot;text-blue-100 text-sm\\&quot;&gt;${rel}&lt;/p&gt;&lt;/div&gt;&quot;\n\t\thtml+=&quot;&lt;div class=\\&quot;p-6\\&quot;&gt;&lt;pre&gt;&lt;code class=\\&quot;language-${lang}\\&quot;&gt;${code}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&quot;\n\tdone\n\n\t[[ -z &quot;$html&quot; ]] &amp;&amp; html=&quot;&lt;p class=\\&quot;text-center text-slate-600\\&quot;&gt;No source files found.&lt;/p&gt;&quot;\n\techo &quot;$html&quot;\n}\n\n# Generate examples HTML\ngenerate_examples_html() {\n\tlocal examples=(&quot;$@&quot;)\n\tlocal html=&quot;&quot;\n\n\tfor file in &quot;${examples[@]}&quot;; do\n\t\t[[ ! -f &quot;$file&quot; ]] &amp;&amp; continue\n\t\tlocal name=$(basename &quot;$file&quot;)\n\t\tlocal lang=$(detect_language &quot;$file&quot;)\n\t\tlocal code=$(cat &quot;$file&quot; | jq -Rs .)\n\t\t\n\t\thtml+=&quot;&lt;div class=\\&quot;bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\\&quot;&gt;&quot;\n\t\thtml+=&quot;&lt;div class=\\&quot;bg-gradient-to-r from-green-500 to-green-600 px-6 py-4\\&quot;&gt;&quot;\n\t\thtml+=&quot;&lt;h3 class=\\&quot;text-xl font-semibold text-white\\&quot;&gt;${name}&lt;/h3&gt;&lt;/div&gt;&quot;\n\t\thtml+=&quot;&lt;div class=\\&quot;p-6\\&quot;&gt;&lt;pre&gt;&lt;code class=\\&quot;language-${lang}\\&quot;&gt;${code}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&quot;\n\tdone\n\n\t[[ -z &quot;$html&quot; ]] &amp;&amp; html=&quot;&lt;p class=\\&quot;text-center text-slate-600\\&quot;&gt;No examples found.&lt;/p&gt;&quot;\n\techo &quot;$html&quot;\n}\n\n# Generate documentation page\ngenerate_docs_page() {\n\tlog_info &quot;Generating documentation...&quot;\n\tlog_info &quot;Parsing project files...&quot;\n\n\tlocal arty_yml=&quot;${PROJECT_DIR}/arty.yml&quot;\n\tlocal readme_md=&quot;${PROJECT_DIR}/README.md&quot;\n\n\t# Parse project metadata\n\tlocal project_name=$(parse_yaml &quot;$arty_yml&quot; &quot;name&quot;)\n\tlocal project_version=$(parse_yaml &quot;$arty_yml&quot; &quot;version&quot;)\n\tlocal project_desc=$(parse_yaml &quot;$arty_yml&quot; &quot;description&quot;)\n\n\t[[ -z &quot;$project_name&quot; ]] &amp;&amp; project_name=$(basename &quot;$PROJECT_DIR&quot;)\n\n\tlog_debug &quot;Project: $project_name v$project_version&quot;\n\n\t# Read README\n\tlocal readme_content=$(read_file &quot;$readme_md&quot;)\n\tif [[ -z &quot;$readme_content&quot; ]]; then\n\t\tlog_warn &quot;README.md not found, using placeholder&quot;\n\t\treadme_content=&quot;No README.md file found in project.&quot;\n\tfi\n\n\t# Get icon\n\tlocal icon_path=$(get_icon)\n\tlocal icon_svg=&quot;&quot;\n\tif [[ -n &quot;$icon_path&quot; ]]; then\n\t\ticon_svg=$(cat &quot;$icon_path&quot;)\n\t\tlog_success &quot;Loaded icon from: ${icon_path#${PROJECT_DIR}/}&quot;\n\telse\n\t\tlog_warn &quot;No icon found, using default&quot;\n\t\ticon_svg=&#39;&lt;svg class=&quot;w-full h-full&quot; fill=&quot;currentColor&quot; viewBox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13 2L3 14h9l-1 8 10-12h-9l1-8z&quot;/&gt;&lt;/svg&gt;&#39;\n\tfi\n\n\t# Scan files\n\tlocal source_files=($(scan_source_files))\n\tlocal example_files=($(scan_examples))\n\n\tlog_info &quot;Found ${#source_files[@]} source files and ${#example_files[@]} examples&quot;\n\n\t# Generate HTML for sources and examples\n\tlocal src_html=$(generate_source_html &quot;${source_files[@]}&quot;)\n\tlocal ex_html=$(generate_examples_html &quot;${example_files[@]}&quot;)\n\n\t# Create JSON data file for myst\n\tlocal data_file=&quot;/tmp/leaf_docs_$.json&quot;\n\t# Escape icon SVG for JSON\n\tlocal icon_json=$(echo &quot;$icon_svg&quot; | jq -Rs .)\n\tlocal readme_json=$(echo &quot;$readme_content&quot; | jq -Rs .)\n\tlocal src_html_json=$(echo &quot;$src_html&quot; | jq -Rs .)\n\tlocal ex_html_json=$(echo &quot;$ex_html&quot; | jq -Rs .)\n\t\n\tjq -n \\\n\t\t--arg name &quot;$project_name&quot; \\\n\t\t--arg version &quot;${project_version:-1.0.0}&quot; \\\n\t\t--arg desc &quot;${project_desc:-Documentation}&quot; \\\n\t\t--argjson icon &quot;$icon_json&quot; \\\n\t\t--argjson readme &quot;$readme_json&quot; \\\n\t\t--arg github &quot;$GITHUB_URL&quot; \\\n\t\t--arg base &quot;$BASE_PATH&quot; \\\n\t\t--argjson src_html &quot;$src_html_json&quot; \\\n\t\t--argjson ex_html &quot;$ex_html_json&quot; \\\n\t\t&#39;{\n\t\t\tpage_title: ($name + &quot; - Documentation&quot;),\n\t\t\tpage_description: $desc,\n\t\t\tbase_path: $base,\n\t\t\tproject_name: $name,\n\t\t\tproject_version: $version,\n\t\t\tproject_description: $desc,\n\t\t\ticon: $icon,\n\t\t\treadme_content: $readme,\n\t\t\tgithub_url: $github,\n\t\t\tsource_files_html: $src_html,\n\t\t\texamples_html: $ex_html,\n\t\t\tmyst_enabled: &quot;true&quot;\n\t\t}&#39; &gt; &quot;$data_file&quot;\n\n\t# Render with myst\n\tif ! render_with_myst \\\n\t\t&quot;${TEMPLATES_DIR}/docs.html.myst&quot; \\\n\t\t&quot;${OUTPUT_DIR}/index.html&quot; \\\n\t\t&quot;$data_file&quot;; then\n\t\tlog_error &quot;Failed to render documentation&quot;\n\t\trm -f &quot;$data_file&quot;\n\t\treturn 1\n\tfi\n\n\trm -f &quot;$data_file&quot;\n\tlog_success &quot;Documentation generated at: ${OUTPUT_DIR}/index.html&quot;\n}\n\n# Generate landing page\ngenerate_landing_page() {\n\tlog_info &quot;Generating butter.sh landing page...&quot;\n\n\tmkdir -p &quot;$OUTPUT_DIR&quot;\n\n\t# Default projects\n\tlocal projects_default=&#39;[{&quot;url&quot;:&quot;https://hammer.sh&quot;,&quot;label&quot;:&quot;hammer.sh&quot;,&quot;desc&quot;:&quot;Configurable bash project generator&quot;,&quot;class&quot;:&quot;card-project&quot;},{&quot;url&quot;:&quot;https://arty.sh&quot;,&quot;label&quot;:&quot;arty.sh&quot;,&quot;desc&quot;:&quot;Bash library repository manager&quot;,&quot;class&quot;:&quot;card-project&quot;},{&quot;url&quot;:&quot;https://leaf.sh&quot;,&quot;label&quot;:&quot;leaf.sh&quot;,&quot;desc&quot;:&quot;Beautiful documentation generator&quot;,&quot;class&quot;:&quot;card-project&quot;}]&#39;\n\n\tlocal projects=&quot;&quot;\n\n\t# Load projects (priority: file &gt; arg &gt; default)\n\tif [[ -n &quot;$PROJECTS_FILE&quot; ]]; then\n\t\tlog_info &quot;Loading projects from file: $PROJECTS_FILE&quot;\n\t\tif projects=$(read_json_file &quot;$PROJECTS_FILE&quot;); then\n\t\t\tlog_success &quot;Projects JSON loaded&quot;\n\t\t\tif validate_projects_json &quot;$projects&quot;; then\n\t\t\t\tlocal count=$(echo &quot;$projects&quot; | jq &#39;length&#39;)\n\t\t\t\tlog_info &quot;Found $count project(s)&quot;\n\t\t\telse\n\t\t\t\treturn 1\n\t\t\tfi\n\t\telse\n\t\t\treturn 1\n\t\tfi\n\telif [[ -n &quot;$PROJECTS_JSON&quot; ]]; then\n\t\tlog_info &quot;Using projects from command line&quot;\n\t\tif parse_json &quot;$PROJECTS_JSON&quot; &gt;/dev/null; then\n\t\t\tprojects=&quot;$PROJECTS_JSON&quot;\n\t\t\tlog_success &quot;Projects JSON loaded&quot;\n\t\t\tif validate_projects_json &quot;$projects&quot;; then\n\t\t\t\tlocal count=$(echo &quot;$projects&quot; | jq &#39;length&#39;)\n\t\t\t\tlog_info &quot;Found $count project(s)&quot;\n\t\t\telse\n\t\t\t\treturn 1\n\t\t\tfi\n\t\telse\n\t\t\treturn 1\n\t\tfi\n\telse\n\t\tlog_info &quot;Using default butter.sh projects&quot;\n\t\tprojects=&quot;$projects_default&quot;\n\t\tlog_success &quot;Projects JSON loaded&quot;\n\t\tlocal count=$(echo &quot;$projects&quot; | jq &#39;length&#39;)\n\t\tlog_info &quot;Found $count project(s)&quot;\n\tfi\n\n\t# Get logo\n\tlocal logo_svg=&quot;&quot;\n\tif [[ -n &quot;$LOGO_PATH&quot; &amp;&amp; -f &quot;$LOGO_PATH&quot; ]]; then\n\t\tlogo_svg=$(cat &quot;$LOGO_PATH&quot;)\n\t\tlog_success &quot;Using custom logo: $LOGO_PATH&quot;\n\telse\n\t\tlocal butter_logo=&quot;${SCRIPT_DIR}/../butter.sh/_assets/brand/cube-carbon-light.svg&quot;\n\t\tif [[ -f &quot;$butter_logo&quot; ]]; then\n\t\t\tlogo_svg=$(cat &quot;$butter_logo&quot;)\n\t\t\tlog_success &quot;Using butter.sh brand logo&quot;\n\t\telse\n\t\t\tlog_warn &quot;Using default fallback logo&quot;\n\t\t\tlogo_svg=&#39;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;64&quot; height=&quot;64&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot;&gt;&lt;path d=&quot;M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z&quot;/&gt;&lt;polyline points=&quot;3.27 6.96 12 12.01 20.73 6.96&quot;/&gt;&lt;line x1=&quot;12&quot; y1=&quot;22.08&quot; x2=&quot;12&quot; y2=&quot;12&quot;/&gt;&lt;/svg&gt;&#39;\n\t\tfi\n\tfi\n\n\t# Create JSON data file for myst\n\tlocal data_file\n\tdata_file=&quot;/tmp/leaf_landing_$.json&quot;\n\t# Escape logo SVG for JSON\n\tlocal logo_json=$(echo &quot;$logo_svg&quot; | jq -Rs .)\n\t\n\tjq -n \\\n\t\t--argjson logo &quot;$logo_json&quot; \\\n\t\t--arg base &quot;$BASE_PATH&quot; \\\n\t\t--arg github &quot;$GITHUB_URL&quot; \\\n\t\t--argjson projects_json_data &quot;$projects&quot; \\\n\t\t&#39;{\n\t\t\tpage_title: &quot;butter.sh - Modern Bash Development Ecosystem&quot;,\n\t\t\tpage_description: &quot;A collection of modern bash development tools&quot;,\n\t\t\tbase_path: $base,\n\t\t\tlogo: $logo,\n\t\t\tsite_name: &quot;butter.sh&quot;,\n\t\t\tgithub_url: $github,\n\t\t\thero_tagline: &quot;Modern bash development tools for the command line renaissance&quot;,\n\t\t\tprimary_cta_text: &quot;Explore Projects&quot;,\n\t\t\tprimary_cta_url: $github,\n\t\t\tsecondary_cta_text: &quot;Learn More&quot;,\n\t\t\tsecondary_cta_url: &quot;#projects&quot;,\n\t\t\tprojects_section_title: &quot;Our Projects&quot;,\n\t\t\tprojects_json: $projects_json_data,\n\t\t\tfooter_tagline: &quot;Building the future of bash development&quot;,\n\t\t\tgenerator_credit: &quot;true&quot;,\n\t\t\tmyst_enabled: &quot;true&quot;\n\t\t}&#39; &gt; &quot;$data_file&quot;\n\n\t# Render with myst\n\tif ! render_with_myst \\\n\t\t&quot;${TEMPLATES_DIR}/landing.html.myst&quot; \\\n\t\t&quot;${OUTPUT_DIR}/index.html&quot; \\\n\t\t&quot;$data_file&quot;; then\n\t\tlog_error &quot;Failed to render landing page&quot;\n\t\trm -f &quot;$data_file&quot;\n\t\treturn 1\n\tfi\n\n\trm -f &quot;$data_file&quot;\n\tlog_success &quot;Landing page generated at: ${OUTPUT_DIR}/index.html&quot;\n}\n\n# Main function\nmain() {\n\t# Show help if no arguments provided\n\tif [[ $# -eq 0 ]]; then\n\t\tshow_usage\n\t\texit 0\n\tfi\n\t\n\tparse_args &quot;$@&quot;\n\n\t# Check dependencies after parsing args (so --help works without dependencies)\n\tif ! check_dependencies; then\n\t\texit 1\n\tfi\n\n\t# Only show banner if not in test mode\n\tif [[ &quot;${LEAF_TEST_MODE:-0}&quot; != &quot;1&quot; ]]; then\n\t\techo -e &quot;${CYAN}&quot;\n\t\techo &quot;╔═══════════════════════════════════════════╗&quot;\n\t\techo &quot;║                                           ║&quot;\n\t\techo &quot;║      🌿 leaf.sh Generator v2.2 🌿        ║&quot;\n\t\techo &quot;║      Powered by myst.sh templating       ║&quot;\n\t\techo &quot;║                                           ║&quot;\n\t\techo &quot;╚═══════════════════════════════════════════╝&quot;\n\t\techo -e &quot;${NC}&quot;\n\t\techo\n\tfi\n\n\tif [[ &quot;$MODE&quot; == &quot;landing&quot; ]]; then\n\t\tgenerate_landing_page\n\telse\n\t\t# Documentation mode\n\t\tif [[ ! -d &quot;$PROJECT_DIR&quot; ]]; then\n\t\t\tlog_error &quot;Project directory not found: $PROJECT_DIR&quot;\n\t\t\texit 1\n\t\tfi\n\n\t\tlog_info &quot;Scanning project: $PROJECT_DIR&quot;\n\t\tgenerate_docs_page\n\tfi\n\n\t# Only show completion message if not in test mode\n\tif [[ &quot;${LEAF_TEST_MODE:-0}&quot; != &quot;1&quot; ]]; then\n\t\techo\n\t\techo -e &quot;${GREEN}═══════════════════════════════════════════${NC}&quot;\n\t\techo -e &quot;${GREEN}Generation complete! 🎉${NC}&quot;\n\t\techo -e &quot;${GREEN}═══════════════════════════════════════════${NC}&quot;\n\t\techo\n\t\techo -e &quot;📂 Output: ${CYAN}${OUTPUT_DIR}/index.html${NC}&quot;\n\t\techo -e &quot;🌐 Open: ${BLUE}file://${OUTPUT_DIR}/index.html${NC}&quot;\n\t\techo\n\tfi\n}\n\n# Run main function only if script is executed directly (not sourced)\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n\tmain &quot;$@&quot;\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-templates.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/templates/test-templates.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# test-templates.sh - Test myst templates for leaf.sh\nset -euo pipefail\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nTEMPLATES_DIR=&quot;${SCRIPT_DIR}&quot;\nEXAMPLES_DIR=&quot;${TEMPLATES_DIR}/examples&quot;\nOUTPUT_DIR=&quot;${SCRIPT_DIR}/test-output&quot;\n\n# Colors\nGREEN=&#39;\\033[0;32m&#39;\nBLUE=&#39;\\033[0;34m&#39;\nYELLOW=&#39;\\033[1;33m&#39;\nNC=&#39;\\033[0m&#39;\n\necho -e &quot;${BLUE}Testing leaf.sh Myst Templates${NC}&quot;\necho &quot;========================================&quot;\necho\n\n# Check if myst.sh is available\nif ! command -v myst &gt;/dev/null 2&gt;&amp;1; then\n    # Try to find myst.sh in parent directories\n    MYST_PATH=&quot;&quot;\n    if [[ -f &quot;${SCRIPT_DIR}/../../myst/myst.sh&quot; ]]; then\n        MYST_PATH=&quot;${SCRIPT_DIR}/../../myst/myst.sh&quot;\n    elif [[ -f &quot;${SCRIPT_DIR}/../../../myst.sh/myst.sh&quot; ]]; then\n        MYST_PATH=&quot;${SCRIPT_DIR}/../../../myst.sh/myst.sh&quot;\n    else\n        echo -e &quot;${YELLOW}Warning: myst.sh not found in PATH or nearby directories${NC}&quot;\n        echo &quot;Please install myst.sh or add it to PATH&quot;\n        echo\n        echo &quot;You can test manually with:&quot;\n        echo &quot;  myst render templates/landing.html.myst -p templates/partials -j examples/landing-data.json -o output.html&quot;\n        exit 1\n    fi\n    \n    MYST_CMD=&quot;bash ${MYST_PATH}&quot;\nelse\n    MYST_CMD=&quot;myst&quot;\nfi\n\necho -e &quot;${GREEN}✓${NC} Found myst: $MYST_CMD&quot;\necho\n\n# Create output directory\nmkdir -p &quot;$OUTPUT_DIR&quot;\n\n# Test 1: Landing page\necho -e &quot;${BLUE}[Test 1]${NC} Rendering landing.html.myst...&quot;\n$MYST_CMD render &quot;${TEMPLATES_DIR}/landing.html.myst&quot; \\\n    -p &quot;${TEMPLATES_DIR}/partials&quot; \\\n    -j &quot;${EXAMPLES_DIR}/landing-data.json&quot; \\\n    -o &quot;${OUTPUT_DIR}/landing.html&quot; 2&gt;&amp;1 | grep -v &quot;^\\[&quot; || true\n\nif [[ -f &quot;${OUTPUT_DIR}/landing.html&quot; ]]; then\n    echo -e &quot;${GREEN}✓${NC} Generated: ${OUTPUT_DIR}/landing.html&quot;\nelse\n    echo -e &quot;${YELLOW}✗${NC} Failed to generate landing.html&quot;\nfi\necho\n\n# Test 2: Project page\necho -e &quot;${BLUE}[Test 2]${NC} Rendering project.html.myst...&quot;\n$MYST_CMD render &quot;${TEMPLATES_DIR}/project.html.myst&quot; \\\n    -p &quot;${TEMPLATES_DIR}/partials&quot; \\\n    -j &quot;${EXAMPLES_DIR}/project-data.json&quot; \\\n    -o &quot;${OUTPUT_DIR}/project.html&quot; 2&gt;&amp;1 | grep -v &quot;^\\[&quot; || true\n\nif [[ -f &quot;${OUTPUT_DIR}/project.html&quot; ]]; then\n    echo -e &quot;${GREEN}✓${NC} Generated: ${OUTPUT_DIR}/project.html&quot;\nelse\n    echo -e &quot;${YELLOW}✗${NC} Failed to generate project.html&quot;\nfi\necho\n\n# Summary\necho &quot;========================================&quot;\necho -e &quot;${GREEN}Testing Complete!${NC}&quot;\necho\necho &quot;Generated files:&quot;\nls -lh &quot;$OUTPUT_DIR&quot;\necho\necho &quot;To view the generated pages:&quot;\necho -e &quot;  ${BLUE}file://${OUTPUT_DIR}/landing.html${NC}&quot;\necho -e &quot;  ${BLUE}file://${OUTPUT_DIR}/project.html${NC}&quot;\necho\necho &quot;Or start a local server:&quot;\necho -e &quot;  ${YELLOW}cd ${OUTPUT_DIR} &amp;&amp; python3 -m http.server 8080${NC}&quot;\necho</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-helpers.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-helpers.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for leaf.sh helper functions and utilities\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    export LEAF_TEST_MODE=1\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: check_dependencies detects missing yq\ntest_check_dependencies_missing_yq() {\n    setup\n    \n    # Create a minimal test project\n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Test with PATH that doesn&#39;t have yq\n    set +e\n    output=$(PATH=&quot;/bin:/usr/bin&quot; bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    # Should fail or warn about missing dependencies\n    assert_true &quot;[[ $exit_code -ne 0 ]]&quot; &quot;Should detect missing yq&quot;\n    \n    teardown\n}\n\n# Test: check_dependencies detects missing jq\ntest_check_dependencies_missing_jq() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Test with PATH that doesn&#39;t have jq\n    set +e\n    output=$(PATH=&quot;/bin:/usr/bin&quot; bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    # Should fail or warn about missing dependencies\n    assert_true &quot;[[ $exit_code -ne 0 ]]&quot; &quot;Should detect missing jq&quot;\n    \n    teardown\n}\n\n# Test: detect_language correctly identifies file types\ntest_detect_language() {\n    setup\n    \n    # Test via actual file processing\n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &quot;#!/bin/bash&quot; &gt; test-project/test.sh\n    echo &quot;print(&#39;test&#39;)&quot; &gt; test-project/test.py\n    echo &quot;console.log(&#39;test&#39;)&quot; &gt; test-project/test.js\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;language-bash&quot; &quot;Should detect bash&quot;\n    assert_contains &quot;$html&quot; &quot;language-python&quot; &quot;Should detect python&quot;\n    assert_contains &quot;$html&quot; &quot;language-javascript&quot; &quot;Should detect javascript&quot;\n    \n    teardown\n}\n\n# Test: get_icon finds icon in standard location\ntest_get_icon_standard_location() {\n    setup\n    \n    mkdir -p test-project/_assets/icon\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &#39;&lt;svg&gt;&lt;/svg&gt;&#39; &gt; test-project/_assets/icon/icon.svg\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;Loaded icon from&quot; &quot;Should find standard icon&quot;\n    \n    teardown\n}\n\n# Test: get_icon prioritizes custom logo path\ntest_get_icon_custom_logo() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &#39;&lt;svg id=&quot;custom&quot;&gt;&lt;/svg&gt;&#39; &gt; custom-logo.svg\n    \n    bash &quot;$LEAF_SH&quot; test-project --logo custom-logo.svg -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;custom&quot; &quot;Should use custom logo&quot;\n    \n    teardown\n}\n\n# Test: get_icon tries alternate icon names\ntest_get_icon_alternate_names() {\n    setup\n    \n    mkdir -p test-project/_assets/icon\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &#39;&lt;svg&gt;&lt;/svg&gt;&#39; &gt; test-project/_assets/icon/icon-v2.svg\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;Loaded icon from&quot; &quot;Should find alternate icon&quot;\n    \n    teardown\n}\n\n# Test: get_icon handles missing icon directory\ntest_get_icon_missing_directory() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;No icon found, using default&quot; &quot;Should warn about missing icon&quot;\n    \n    teardown\n}\n\n# Test: logging functions produce output\ntest_logging_functions() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    # Check for various log symbols\n    assert_contains &quot;$output&quot; &quot;ℹ&quot; &quot;Should have info messages&quot;\n    assert_contains &quot;$output&quot; &quot;✓&quot; &quot;Should have success messages&quot;\n    \n    teardown\n}\n\n# Test: logging with DEBUG enabled\ntest_logging_debug_enabled() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    output=$(DEBUG=1 bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;🔍&quot; &quot;Should show debug output when enabled&quot;\n    \n    teardown\n}\n\n# Test: find_myst locates myst in .arty/bin\ntest_find_myst_arty_bin() {\n    setup\n    \n    # This test checks that myst is found if available\n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # If myst is available, generation should succeed\n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should work with myst&quot;\n    \n    teardown\n}\n\n# Test: scan_source_files finds shell scripts\ntest_scan_source_files_shell() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &#39;#!/bin/bash&#39; &gt; test-project/script.sh\n    echo &#39;#!/bin/bash&#39; &gt; test-project/other.bash\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;script.sh&quot; &quot;Should find .sh files&quot;\n    assert_contains &quot;$html&quot; &quot;other.bash&quot; &quot;Should find .bash files&quot;\n    \n    teardown\n}\n\n# Test: scan_source_files finds multiple language files\ntest_scan_source_files_multiple_languages() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &#39;#!/bin/bash&#39; &gt; test-project/script.sh\n    echo &#39;print(&quot;hi&quot;)&#39; &gt; test-project/script.py\n    echo &#39;console.log(&quot;hi&quot;)&#39; &gt; test-project/script.js\n    echo &#39;package main&#39; &gt; test-project/main.go\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;Found 4 source files&quot; &quot;Should find all language files&quot;\n    \n    teardown\n}\n\n# Test: scan_source_files excludes docs directory\ntest_scan_source_files_excludes_docs() {\n    setup\n    \n    mkdir -p test-project/docs\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &#39;#!/bin/bash&#39; &gt; test-project/main.sh\n    echo &#39;#!/bin/bash&#39; &gt; test-project/docs/generated.sh\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;main.sh&quot; &quot;Should find main file&quot;\n    assert_not_contains &quot;$html&quot; &quot;docs/generated.sh&quot; &quot;Should exclude docs directory&quot;\n    \n    teardown\n}\n\n# Test: scan_source_files excludes node_modules\ntest_scan_source_files_excludes_node_modules() {\n    setup\n    \n    mkdir -p test-project/node_modules\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &#39;#!/bin/bash&#39; &gt; test-project/main.sh\n    echo &#39;module.exports = {}&#39; &gt; test-project/node_modules/dep.js\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;main.sh&quot; &quot;Should find main file&quot;\n    assert_not_contains &quot;$html&quot; &quot;node_modules&quot; &quot;Should exclude node_modules&quot;\n    \n    teardown\n}\n\n# Test: scan_examples finds example files\ntest_scan_examples() {\n    setup\n    \n    mkdir -p test-project/examples\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &#39;example 1&#39; &gt; test-project/examples/ex1.sh\n    echo &#39;example 2&#39; &gt; test-project/examples/ex2.py\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;Found 0 source files and 2 examples&quot; &quot;Should find examples&quot;\n    \n    teardown\n}\n\n# Test: scan_examples handles missing examples directory\ntest_scan_examples_missing_directory() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;Found 0 source files and 0 examples&quot; &quot;Should handle missing examples&quot;\n    \n    teardown\n}\n\n# Test: validate_projects_json accepts valid array\ntest_validate_projects_json_valid() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;,&quot;label&quot;:&quot;Test&quot;,&quot;desc&quot;:&quot;Desc&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should validate correct JSON&quot;\n    \n    teardown\n}\n\n# Test: validate_projects_json rejects non-array\ntest_validate_projects_json_not_array() {\n    setup\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects &#39;{&quot;url&quot;:&quot;test&quot;}&#39; -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should reject non-array&quot;\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_check_dependencies_missing_yq\n    test_check_dependencies_missing_jq\n    test_detect_language\n    test_get_icon_standard_location\n    test_get_icon_custom_logo\n    test_get_icon_alternate_names\n    test_get_icon_missing_directory\n    test_logging_functions\n    test_logging_debug_enabled\n    test_find_myst_arty_bin\n    test_scan_source_files_shell\n    test_scan_source_files_multiple_languages\n    test_scan_source_files_excludes_docs\n    test_scan_source_files_excludes_node_modules\n    test_scan_examples\n    test_scan_examples_missing_directory\n    test_validate_projects_json_valid\n    test_validate_projects_json_not_array\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-docs-generation.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-docs-generation.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for leaf.sh documentation generation functionality\n# Updated to match client-side rendering and myst templating\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    export LEAF_TEST_MODE=1\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: generate_docs_page creates output file\ntest_generate_docs_creates_output() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\ndescription: &quot;A test project&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should create index.html&quot;\n    \n    teardown\n}\n\n# Test: generated docs include project name\ntest_docs_include_project_name() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;my-awesome-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;my-awesome-project&quot; &quot;Should include project name&quot;\n    \n    teardown\n}\n\n# Test: generated docs include version\ntest_docs_include_version() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;2.5.7&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;2.5.7&quot; &quot;Should include version&quot;\n    \n    teardown\n}\n\n# Test: generated docs include description\ntest_docs_include_description() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\ndescription: &quot;This is a unique test description&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;unique test description&quot; &quot;Should include description&quot;\n    \n    teardown\n}\n\n# Test: generated docs include README content area\ntest_docs_include_readme() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/README.md &lt;&lt; &#39;EOF&#39;\n# Test Project\n\nThis is unique README content that should appear.\n\n## Features\n- Feature 1\n- Feature 2\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    # README content is passed to template\n    assert_contains &quot;$html&quot; &quot;Test Project&quot; &quot;Should include README title&quot;\n    \n    teardown\n}\n\n# Test: generated docs list source files\ntest_docs_list_source_files() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/main.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\necho &quot;Main script&quot;\nEOF\n    \n    cat &gt; test-project/helper.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\necho &quot;Helper script&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;main.sh&quot; &quot;Should list main.sh&quot;\n    assert_contains &quot;$html&quot; &quot;helper.sh&quot; &quot;Should list helper.sh&quot;\n    \n    teardown\n}\n\n# Test: generated docs include source file content\ntest_docs_include_source_content() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/script.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\n# This is unique script content\necho &quot;Hello World&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;unique script content&quot; &quot;Should include script content&quot;\n    \n    teardown\n}\n\n# Test: generated docs list examples\ntest_docs_list_examples() {\n    setup\n    \n    mkdir -p test-project/examples\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/examples/example1.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\necho &quot;Example 1&quot;\nEOF\n    \n    cat &gt; test-project/examples/example2.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\necho &quot;Example 2&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;example1.sh&quot; &quot;Should list example1&quot;\n    assert_contains &quot;$html&quot; &quot;example2.sh&quot; &quot;Should list example2&quot;\n    \n    teardown\n}\n\n# Test: generated docs include example content\ntest_docs_include_example_content() {\n    setup\n    \n    mkdir -p test-project/examples\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/examples/usage.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\n# Unique example usage\n./script.sh --option value\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;Unique example usage&quot; &quot;Should include example content&quot;\n    \n    teardown\n}\n\n# Test: generated docs use syntax highlighting classes\ntest_docs_syntax_highlighting() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/script.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\necho &quot;test&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;language-bash&quot; &quot;Should mark bash code blocks&quot;\n    \n    teardown\n}\n\n# Test: generated docs handle Python files\ntest_docs_handle_python() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/script.py &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env python3\nprint(&quot;Hello from Python&quot;)\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;script.py&quot; &quot;Should include Python file&quot;\n    assert_contains &quot;$html&quot; &quot;language-python&quot; &quot;Should mark as Python&quot;\n    \n    teardown\n}\n\n# Test: generated docs handle JavaScript files\ntest_docs_handle_javascript() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/script.js &lt;&lt; &#39;EOF&#39;\nconsole.log(&quot;Hello from JavaScript&quot;);\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;script.js&quot; &quot;Should include JavaScript file&quot;\n    assert_contains &quot;$html&quot; &quot;language-javascript&quot; &quot;Should mark as JavaScript&quot;\n    \n    teardown\n}\n\n# Test: generated docs use custom icon\ntest_docs_use_custom_icon() {\n    setup\n    \n    mkdir -p test-project/_assets/icon\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/_assets/icon/icon.svg &lt;&lt; &#39;EOF&#39;\n&lt;svg&gt;&lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; fill=&quot;blue&quot;/&gt;&lt;/svg&gt;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;&lt;svg&gt;&quot; &quot;Should include SVG icon&quot;\n    assert_contains &quot;$html&quot; &quot;circle&quot; &quot;Should include icon content&quot;\n    \n    teardown\n}\n\n# Test: generated docs use default icon when none provided\ntest_docs_use_default_icon() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;&lt;svg&quot; &quot;Should include default SVG icon&quot;\n    \n    teardown\n}\n\n# Test: generated docs respect base path\ntest_docs_respect_base_path() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project --base-path /custom/path/ -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &#39;base href=&quot;/custom/path/&quot;&#39; &quot;Should set base path&quot;\n    \n    teardown\n}\n\n# Test: generated docs include GitHub link when provided\ntest_docs_include_github_link() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project --github https://github.com/test/repo -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;github.com/test/repo&quot; &quot;Should include GitHub link&quot;\n    \n    teardown\n}\n\n# Test: generated docs handle project with no source files\ntest_docs_no_source_files() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output even without source files&quot;\n    assert_contains &quot;$html&quot; &quot;No source files found&quot; &quot;Should mention no source files&quot;\n    \n    teardown\n}\n\n# Test: generated docs handle project with no examples\ntest_docs_no_examples() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;No examples found&quot; &quot;Should mention no examples&quot;\n    \n    teardown\n}\n\n# Test: generated docs use directory name when no project name\ntest_docs_use_directory_name() {\n    setup\n    \n    mkdir -p my-special-project\n    cat &gt; my-special-project/arty.yml &lt;&lt; &#39;EOF&#39;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; my-special-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;my-special-project&quot; &quot;Should use directory name&quot;\n    \n    teardown\n}\n\n# Test: generated docs handle missing arty.yml\ntest_docs_missing_arty_yml() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/README.md &lt;&lt; &#39;EOF&#39;\n# Test Project\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    # Should still generate with defaults\n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output without arty.yml&quot;\n    \n    teardown\n}\n\n# Test: generated docs have valid HTML structure\ntest_docs_html_structure() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;&lt;!DOCTYPE html&gt;&quot; &quot;Should have DOCTYPE&quot;\n    assert_contains &quot;$html&quot; &quot;&lt;html&quot; &quot;Should have html tag&quot;\n    assert_contains &quot;$html&quot; &quot;&lt;head&gt;&quot; &quot;Should have head section&quot;\n    assert_contains &quot;$html&quot; &quot;&lt;body&quot; &quot;Should have body tag&quot;\n    \n    teardown\n}\n\n# Test: generated docs include Tailwind CSS\ntest_docs_include_tailwind() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;tailwindcss&quot; &quot;Should include Tailwind CSS&quot;\n    \n    teardown\n}\n\n# Test: generated docs output to correct location\ntest_docs_output_location() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o custom/output/dir 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;custom/output/dir/index.html&quot; &quot;Should create in custom location&quot;\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_generate_docs_creates_output\n    test_docs_include_project_name\n    test_docs_include_version\n    test_docs_include_description\n    test_docs_include_readme\n    test_docs_list_source_files\n    test_docs_include_source_content\n    test_docs_list_examples\n    test_docs_include_example_content\n    test_docs_syntax_highlighting\n    test_docs_handle_python\n    test_docs_handle_javascript\n    test_docs_use_custom_icon\n    test_docs_use_default_icon\n    test_docs_respect_base_path\n    test_docs_include_github_link\n    test_docs_no_source_files\n    test_docs_no_examples\n    test_docs_use_directory_name\n    test_docs_missing_arty_yml\n    test_docs_html_structure\n    test_docs_include_tailwind\n    test_docs_output_location\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-integration.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-integration.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Integration tests for leaf.sh - complete workflows\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Strip ANSI color codes\nstrip_colors() {\n    sed &#39;s/\\x1b\\[[0-9;]*m//g&#39;\n}\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: complete docs generation workflow\ntest_complete_docs_workflow() {\n    setup\n    \n    # Create a complete arty.sh project\n    mkdir -p my-project/{examples,_assets/icon}\n    \n    cat &gt; my-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;my-project&quot;\nversion: &quot;1.2.3&quot;\ndescription: &quot;A complete test project&quot;\nauthor: &quot;Test Author&quot;\nlicense: &quot;MIT&quot;\nreferences:\n  - https://github.com/user/dep1.git\n  - https://github.com/user/dep2.git\nEOF\n    \n    cat &gt; my-project/README.md &lt;&lt; &#39;EOF&#39;\n# My Project\n\nThis is a **complete** test project with all features.\n\n## Installation\n\n```bash\n./install.sh\n```\n\n## Usage\n\nRun the main script:\n\n```bash\n./main.sh\n```\nEOF\n    \n    cat &gt; my-project/main.sh &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\necho &quot;Hello from my-project&quot;\nEOF\n    \n    cat &gt; my-project/helpers.sh &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\nhelper_function() {\n    echo &quot;Helper&quot;\n}\nEOF\n    \n    cat &gt; my-project/examples/basic.sh &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\n# Basic usage example\n./main.sh\nEOF\n    \n    cat &gt; my-project/_assets/icon/icon.svg &lt;&lt; &#39;EOF&#39;\n&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 100 100&quot;&gt;\n  &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; fill=&quot;blue&quot;/&gt;\n&lt;/svg&gt;\nEOF\n    \n    # Generate docs\n    bash &quot;$LEAF_SH&quot; my-project -o docs 2&gt;&amp;1 &gt;/dev/null\n    \n    # Verify output\n    assert_file_exists &quot;docs/index.html&quot; &quot;Should create docs&quot;\n    \n    html=$(cat docs/index.html)\n    assert_contains &quot;$html&quot; &quot;my-project&quot; &quot;Should include project name&quot;\n    assert_contains &quot;$html&quot; &quot;1.2.3&quot; &quot;Should include version&quot;\n    assert_contains &quot;$html&quot; &quot;complete test project&quot; &quot;Should include description&quot;\n    assert_contains &quot;$html&quot; &quot;Hello from my-project&quot; &quot;Should include main.sh content&quot;\n    assert_contains &quot;$html&quot; &quot;helper_function&quot; &quot;Should include helpers.sh content&quot;\n    assert_contains &quot;$html&quot; &quot;basic.sh&quot; &quot;Should include example&quot;\n    \n    output=$(bash &quot;$LEAF_SH&quot; my-project -o docs 2&gt;&amp;1 | strip_colors)\n    assert_contains &quot;$output&quot; &quot;Found 2 source files&quot; &quot;Should report source files&quot;\n    assert_contains &quot;$output&quot; &quot;1 examples&quot; &quot;Should report examples&quot;\n    \n    teardown\n}\n\n# Test: complete landing page workflow\ntest_complete_landing_workflow() {\n    setup\n    \n    # Create projects JSON file\n    cat &gt; projects.json &lt;&lt; &#39;EOF&#39;\n[\n  {\n    &quot;url&quot;: &quot;https://tool1.sh&quot;,\n    &quot;label&quot;: &quot;tool1.sh&quot;,\n    &quot;desc&quot;: &quot;First tool in the ecosystem&quot;,\n    &quot;class&quot;: &quot;card-project&quot;\n  },\n  {\n    &quot;url&quot;: &quot;https://tool2.sh&quot;,\n    &quot;label&quot;: &quot;tool2.sh&quot;,\n    &quot;desc&quot;: &quot;Second tool in the ecosystem&quot;,\n    &quot;class&quot;: &quot;card-project&quot;\n  },\n  {\n    &quot;url&quot;: &quot;https://tool3.sh&quot;,\n    &quot;label&quot;: &quot;tool3.sh&quot;,\n    &quot;desc&quot;: &quot;Third tool in the ecosystem&quot;,\n    &quot;class&quot;: &quot;card-project&quot;\n  }\n]\nEOF\n    \n    # Create custom logo\n    cat &gt; logo.svg &lt;&lt; &#39;EOF&#39;\n&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 100 100&quot;&gt;\n  &lt;rect width=&quot;100&quot; height=&quot;100&quot; fill=&quot;green&quot;/&gt;\n&lt;/svg&gt;\nEOF\n    \n    # Generate landing page\n    output=$(bash &quot;$LEAF_SH&quot; --landing \\\n        --projects-file projects.json \\\n        --logo logo.svg \\\n        --github https://github.com/my-org \\\n        --base-path /landing/ \\\n        -o website 2&gt;&amp;1)\n    \n    # Verify output\n    assert_file_exists &quot;website/index.html&quot; &quot;Should create landing page&quot;\n    \n    html=$(cat website/index.html)\n    assert_contains &quot;$html&quot; &quot;tool1.sh&quot; &quot;Should include tool1&quot;\n    assert_contains &quot;$html&quot; &quot;tool2.sh&quot; &quot;Should include tool2&quot;\n    assert_contains &quot;$html&quot; &quot;tool3.sh&quot; &quot;Should include tool3&quot;\n    assert_contains &quot;$html&quot; &quot;github.com/my-org&quot; &quot;Should include custom GitHub&quot;\n    assert_contains &quot;$html&quot; &#39;base href=&quot;/landing/&quot;&#39; &quot;Should include base path&quot;\n    \n    assert_contains &quot;$output&quot; &quot;Projects JSON loaded&quot; &quot;Should report JSON loaded&quot;\n    assert_contains &quot;$output&quot; &quot;Found 3 project&quot; &quot;Should report project count&quot;\n    \n    teardown\n}\n\n# Test: regenerating docs overwrites existing\ntest_regenerate_docs() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Generate first time\n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    first_content=$(cat output/index.html)\n    \n    # Update project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;2.0.0&quot;\ndescription: &quot;Updated description&quot;\nEOF\n    \n    # Regenerate\n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    second_content=$(cat output/index.html)\n    \n    assert_not_equals &quot;$first_content&quot; &quot;$second_content&quot; &quot;Should overwrite with new content&quot;\n    assert_contains &quot;$second_content&quot; &quot;2.0.0&quot; &quot;Should have new version&quot;\n    assert_contains &quot;$second_content&quot; &quot;Updated description&quot; &quot;Should have new description&quot;\n    \n    teardown\n}\n\n# Test: docs and landing in same directory\ntest_docs_and_landing_separate() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Generate docs with custom GitHub URL to avoid butter.sh\n    bash &quot;$LEAF_SH&quot; test-project --github https://github.com/test-org -o output/docs 2&gt;&amp;1\n    \n    # Generate landing\n    bash &quot;$LEAF_SH&quot; --landing -o output/landing 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/docs/index.html&quot; &quot;Should create docs&quot;\n    assert_file_exists &quot;output/landing/index.html&quot; &quot;Should create landing&quot;\n    \n    docs_html=$(cat output/docs/index.html)\n    landing_html=$(cat output/landing/index.html)\n    \n    assert_contains &quot;$docs_html&quot; &quot;test-project&quot; &quot;Docs should have project name&quot;\n    assert_contains &quot;$landing_html&quot; &quot;butter.sh&quot; &quot;Landing should have butter.sh&quot;\n    assert_not_contains &quot;$docs_html&quot; &quot;butter.sh&quot; &quot;Docs should not have butter.sh&quot;\n    \n    teardown\n}\n\n# Test: multiple file types in source\ntest_multiple_file_types() {\n    setup\n    \n    mkdir -p test-project/src\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &quot;#!/usr/bin/env bash&quot; &gt; test-project/script.sh\n    echo &quot;console.log(&#39;test&#39;);&quot; &gt; test-project/src/app.js\n    echo &quot;print(&#39;hello&#39;)&quot; &gt; test-project/src/util.py\n    echo &#39;puts &quot;ruby&quot;&#39; &gt; test-project/src/helper.rb\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;script.sh&quot; &quot;Should include shell file&quot;\n    assert_contains &quot;$html&quot; &quot;app.js&quot; &quot;Should include JavaScript file&quot;\n    assert_contains &quot;$html&quot; &quot;util.py&quot; &quot;Should include Python file&quot;\n    assert_contains &quot;$html&quot; &quot;helper.rb&quot; &quot;Should include Ruby file&quot;\n    \n    teardown\n}\n\n# Test: debug mode provides verbose output\ntest_debug_mode() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project --debug -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;🔍&quot; &quot;Should show debug symbols&quot;\n    assert_contains &quot;$output&quot; &quot;Parsing&quot; &quot;Should show parsing info&quot;\n    \n    teardown\n}\n\n# Test: project with special directory names\ntest_special_directory_names() {\n    setup\n    \n    mkdir -p &quot;test project with spaces&quot;\n    cat &gt; &quot;test project with spaces/arty.yml&quot; &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; &quot;test project with spaces&quot; -o output 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle spaces in directory name&quot;\n    \n    teardown\n}\n\n# Test: large project with many files\ntest_large_project() {\n    setup\n    \n    mkdir -p test-project/{src,lib,examples}\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;large-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Create 20 source files\n    for i in {1..20}; do\n        echo &quot;#!/usr/bin/env bash&quot; &gt; &quot;test-project/src/file${i}.sh&quot;\n        echo &quot;echo &#39;file $i&#39;&quot; &gt;&gt; &quot;test-project/src/file${i}.sh&quot;\n    done\n    \n    # Create 10 examples\n    for i in {1..10}; do\n        echo &quot;#!/usr/bin/env bash&quot; &gt; &quot;test-project/examples/example${i}.sh&quot;\n    done\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle large project&quot;\n    assert_contains &quot;$output&quot; &quot;20 source files&quot; &quot;Should report all source files&quot;\n    assert_contains &quot;$output&quot; &quot;10 examples&quot; &quot;Should report all examples&quot;\n    \n    teardown\n}\n\n# Test: end-to-end with all options\ntest_all_options_combined() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/main.sh &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\necho &quot;main&quot;\nEOF\n    \n    cat &gt; logo.svg &lt;&lt; &#39;EOF&#39;\n&lt;svg&gt;&lt;circle/&gt;&lt;/svg&gt;\nEOF\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project \\\n        --logo logo.svg \\\n        --base-path /docs/ \\\n        --github https://github.com/custom \\\n        --debug \\\n        -o final-output 2&gt;&amp;1)\n    \n    assert_file_exists &quot;final-output/index.html&quot; &quot;Should create output&quot;\n    \n    html=$(cat final-output/index.html)\n    assert_contains &quot;$html&quot; &#39;base href=&quot;/docs/&quot;&#39; &quot;Should have base path&quot;\n    assert_contains &quot;$html&quot; &quot;circle&quot; &quot;Should have custom logo&quot;\n    assert_contains &quot;$html&quot; &quot;github.com/custom&quot; &quot;Should have custom GitHub&quot;\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_complete_docs_workflow\n    test_complete_landing_workflow\n    test_regenerate_docs\n    test_docs_and_landing_separate\n    test_multiple_file_types\n    test_debug_mode\n    test_special_directory_names\n    test_large_project\n    test_all_options_combined\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-cli.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-cli.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for leaf.sh CLI interface and commands\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: leaf without arguments shows usage\ntest_no_args_shows_usage() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;leaf.sh&quot; &quot;Should show leaf.sh name&quot;\n    assert_contains &quot;$output&quot; &quot;USAGE:&quot; &quot;Should show usage&quot;\n    assert_contains &quot;$output&quot; &quot;OPTIONS:&quot; &quot;Should show options&quot;\n    \n    teardown\n}\n\n# Test: leaf --help shows usage\ntest_help_flag() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; --help 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;USAGE:&quot; &quot;Should show usage&quot;\n    assert_contains &quot;$output&quot; &quot;DOCUMENTATION MODE:&quot; &quot;Should show documentation mode&quot;\n    assert_contains &quot;$output&quot; &quot;LANDING PAGE MODE:&quot; &quot;Should show landing page mode&quot;\n    \n    teardown\n}\n\n# Test: leaf -h shows usage\ntest_help_short_flag() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; -h 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;USAGE:&quot; &quot;Should show usage&quot;\n    \n    teardown\n}\n\n# Test: leaf --version shows version\ntest_version_flag() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; --version 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;leaf.sh version&quot; &quot;Should show version&quot;\n    assert_contains &quot;$output&quot; &quot;2.2.0&quot; &quot;Should show version number&quot;\n    \n    teardown\n}\n\n# Test: leaf --landing switches to landing mode\ntest_landing_mode_flag() {\n    setup\n    \n    mkdir -p docs\n    output=$(bash &quot;$LEAF_SH&quot; --landing -o docs 2&gt;&amp;1)\n    \n    assert_file_exists &quot;docs/index.html&quot; &quot;Should create landing page&quot;\n    assert_contains &quot;$(cat docs/index.html)&quot; &quot;butter.sh&quot; &quot;Landing page should contain butter.sh&quot;\n    \n    teardown\n}\n\n# Test: leaf --output sets custom output directory\ntest_output_flag() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\ndescription: &quot;Test project&quot;\nEOF\n    \n    cat &gt; test-project/README.md &lt;&lt; &#39;EOF&#39;\n# Test Project\nThis is a test.\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project --output custom-output 2&gt;&amp;1\n    \n    assert_file_exists &quot;custom-output/index.html&quot; &quot;Should create output in custom directory&quot;\n    \n    teardown\n}\n\n# Test: leaf -o short flag works\ntest_output_short_flag() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o short-output 2&gt;&amp;1\n    \n    assert_file_exists &quot;short-output/index.html&quot; &quot;Should work with -o flag&quot;\n    \n    teardown\n}\n\n# Test: leaf --logo accepts custom logo path\ntest_logo_flag() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    echo &#39;&lt;svg&gt;&lt;/svg&gt;&#39; &gt; custom-logo.svg\n    \n    bash &quot;$LEAF_SH&quot; test-project --logo custom-logo.svg -o output 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output with custom logo&quot;\n    \n    teardown\n}\n\n# Test: leaf --base-path sets base path\ntest_base_path_flag() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project --base-path /docs/ -o output 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output&quot;\n    assert_contains &quot;$(cat output/index.html)&quot; &#39;base href=&quot;/docs/&quot;&#39; &quot;Should set base path&quot;\n    \n    teardown\n}\n\n# Test: leaf --github sets GitHub URL\ntest_github_flag() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing --github https://github.com/custom-org -o output 2&gt;&amp;1\n    \n    assert_contains &quot;$(cat output/index.html)&quot; &quot;github.com/custom-org&quot; &quot;Should set custom GitHub URL&quot;\n    \n    teardown\n}\n\n# Test: leaf --debug enables debug output\ntest_debug_flag() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project --debug -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;🔍&quot; &quot;Should show debug output&quot;\n    \n    teardown\n}\n\n# Test: unknown option shows error\ntest_unknown_option() {\n    setup\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --unknown-option 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should return error for unknown option&quot;\n    assert_contains &quot;$output&quot; &quot;Unknown option&quot; &quot;Should show unknown option error&quot;\n    \n    teardown\n}\n\n# Test: usage shows examples\ntest_usage_shows_examples() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; --help 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;EXAMPLES:&quot; &quot;Should show examples section&quot;\n    assert_contains &quot;$output&quot; &quot;leaf.sh&quot; &quot;Should show leaf.sh usage examples&quot;\n    \n    teardown\n}\n\n# Test: usage shows dependencies\ntest_usage_shows_dependencies() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; --help 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;DEPENDENCIES:&quot; &quot;Should show dependencies&quot;\n    assert_contains &quot;$output&quot; &quot;yq&quot; &quot;Should mention yq dependency&quot;\n    assert_contains &quot;$output&quot; &quot;jq&quot; &quot;Should mention jq dependency&quot;\n    \n    teardown\n}\n\n# Test: usage shows project structure\ntest_usage_shows_project_structure() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; --help 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;PROJECT STRUCTURE:&quot; &quot;Should show project structure&quot;\n    assert_contains &quot;$output&quot; &quot;arty.yml&quot; &quot;Should mention arty.yml&quot;\n    \n    teardown\n}\n\n# Test: usage shows projects JSON format\ntest_usage_shows_json_format() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; --help 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;PROJECTS JSON FORMAT:&quot; &quot;Should show JSON format&quot;\n    assert_contains &quot;$output&quot; &#39;&quot;url&quot;&#39; &quot;Should show JSON structure&quot;\n    \n    teardown\n}\n\n# Test: usage shows supported file types\ntest_usage_shows_file_types() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; --help 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;SUPPORTED FILE TYPES:&quot; &quot;Should show file types&quot;\n    assert_contains &quot;$output&quot; &quot;Shell&quot; &quot;Should mention shell files&quot;\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_no_args_shows_usage\n    test_help_flag\n    test_help_short_flag\n    test_version_flag\n    test_landing_mode_flag\n    test_output_flag\n    test_output_short_flag\n    test_logo_flag\n    test_base_path_flag\n    test_github_flag\n    test_debug_flag\n    test_unknown_option\n    test_usage_shows_examples\n    test_usage_shows_dependencies\n    test_usage_shows_project_structure\n    test_usage_shows_json_format\n    test_usage_shows_file_types\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-config.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-config.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test configuration for leaf.sh test suite\n# This file is sourced by test files to set common configuration\nexport TEST_ROOT=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\n\n# Test directory structure\nexport LEAF_SH_ROOT=&quot;$PWD&quot;\n\n# Test behavior flags\nexport LEAF_TEST_MODE=1\nexport LEAF_SKIP_YQ_CHECK=0  # Set to 1 to skip yq availability check in tests\nexport LEAF_SKIP_JQ_CHECK=0  # Set to 1 to skip jq availability check in tests\n\n# Color output in tests (set to 0 to disable)\nexport LEAF_TEST_COLORS=1\n\n# Snapshot configuration\nexport SNAPSHOT_UPDATE=&quot;${UPDATE_SNAPSHOTS:-0}&quot;\nexport SNAPSHOT_VERBOSE=&quot;${VERBOSE:-0}&quot;\n\n# Auto-discover all test files matching test-*.sh pattern\nshopt -s nullglob\nTEST_FILES_ARRAY=()\nfor test_file in ${TEST_ROOT}/test-leaf-*.sh; do\n    if [[ -f &quot;$test_file&quot; ]]; then\n        TEST_FILES_ARRAY+=(&quot;$(basename &quot;$test_file&quot;)&quot;)\n    fi\ndone\nexport TEST_FILES=(&quot;${TEST_FILES_ARRAY[@]}&quot;)\nshopt -u nullglob</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-errors.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-errors.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for leaf.sh error handling and edge cases\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    export LEAF_TEST_MODE=1\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: leaf handles missing project directory\ntest_missing_project_directory() {\n    setup\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; /nonexistent/directory -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should return error for missing directory&quot;\n    assert_contains &quot;$output&quot; &quot;not found&quot; &quot;Should report directory not found&quot;\n    \n    teardown\n}\n\n# Test: leaf handles corrupted YAML\ntest_corrupted_yaml() {\n    setup\n    \n    mkdir -p test-project\n    echo &quot;this is not valid yaml: [[[&quot; &gt; test-project/arty.yml\n    \n    # Should still try to generate with defaults\n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_true &quot;true&quot; &quot;Should handle corrupted YAML&quot;\n    \n    teardown\n}\n\n# Test: leaf handles empty arty.yml\ntest_empty_yaml() {\n    setup\n    \n    mkdir -p test-project\n    touch test-project/arty.yml\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    \n    # Should still generate output with defaults\n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle empty YAML&quot;\n    \n    teardown\n}\n\n# Test: leaf handles missing README\ntest_missing_readme() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;no-readme-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output without README&quot;\n    assert_contains &quot;$output&quot; &quot;README.md not found&quot; &quot;Should warn about missing README&quot;\n    \n    teardown\n}\n\n# Test: leaf handles README with special characters\ntest_readme_special_characters() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;special-chars&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/README.md &lt;&lt; &#39;EOF&#39;\n# Project with special chars\nSpecial characters: &lt; &gt; &amp; &quot; &#39; $ ` \\\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle special characters in README&quot;\n    \n    teardown\n}\n\n# Test: leaf handles extremely long README\ntest_extremely_long_readme() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;long-readme&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Create a very long README\n    {\n        echo &quot;# Long README&quot;\n        for i in {1..1000}; do\n            echo &quot;This is line $i with some content to make it realistic.&quot;\n        done\n    } &gt; test-project/README.md\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle long README&quot;\n    html=$(cat output/index.html)\n    # Check that content is included (may be truncated or processed)\n    assert_contains &quot;$html&quot; &quot;Long README&quot; &quot;Should include README title&quot;\n    \n    teardown\n}\n\n# Test: leaf handles invalid logo path\ntest_invalid_logo_path() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    output=$(bash &quot;$LEAF_SH&quot; test-project --logo /nonexistent/logo.svg -o output 2&gt;&amp;1)\n    \n    # Should still generate with default logo\n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output with invalid logo path&quot;\n    assert_contains &quot;$output&quot; &quot;default&quot; &quot;Should mention using default&quot;\n    \n    teardown\n}\n\n# Test: leaf handles invalid projects JSON\ntest_invalid_projects_json() {\n    setup\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects &#39;not valid json&#39; -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should fail on invalid JSON&quot;\n    assert_contains &quot;$output&quot; &quot;Invalid JSON format&quot; &quot;Should report invalid JSON&quot;\n    \n    teardown\n}\n\n# Test: leaf handles missing projects file\ntest_missing_projects_file() {\n    setup\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects-file nonexistent.json -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should fail on missing projects file&quot;\n    assert_contains &quot;$output&quot; &quot;not found&quot; &quot;Should report file not found&quot;\n    \n    teardown\n}\n\n# Test: leaf handles projects file with invalid JSON\ntest_projects_file_invalid_json() {\n    setup\n    \n    echo &quot;not valid json&quot; &gt; projects.json\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects-file projects.json -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should fail on invalid JSON in file&quot;\n    assert_contains &quot;$output&quot; &quot;Failed to parse&quot; &quot;Should report parse failure&quot;\n    \n    teardown\n}\n\n# Test: leaf handles output directory creation\ntest_output_directory_creation() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output/nested/deep 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/nested/deep/index.html&quot; &quot;Should create nested directories&quot;\n    \n    teardown\n}\n\n# Test: leaf handles source files with syntax errors\ntest_source_files_with_errors() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/broken.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\n# This script has syntax errors\nfunction broken {\n    echo &quot;missing closing brace&quot;\n# Missing }\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    \n    # Should still generate documentation with broken files\n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle files with syntax errors&quot;\n    assert_contains &quot;$(cat output/index.html)&quot; &quot;broken.sh&quot; &quot;Should include broken file&quot;\n    \n    teardown\n}\n\n# Test: leaf handles empty source files\ntest_empty_source_files() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    touch test-project/empty.sh\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle empty source files&quot;\n    \n    teardown\n}\n\n# Test: leaf handles YAML with unicode characters\ntest_yaml_unicode_characters() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;unicode-project&quot;\nversion: &quot;1.0.0&quot;\ndescription: &quot;Project with émojis 🚀 and spëcial chârs&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle unicode in YAML&quot;\n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;🚀&quot; &quot;Should include emoji&quot;\n    \n    teardown\n}\n\n# Test: leaf handles base path with special characters\ntest_base_path_special_chars() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project --base-path &#39;/my-docs/v1.0/&#39; -o output 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle special chars in base path&quot;\n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &#39;my-docs&#39; &quot;Should include base path&quot;\n    \n    teardown\n}\n\n# Test: leaf handles README with code blocks containing special chars\ntest_readme_code_blocks() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/README.md &lt;&lt; &#39;EOF&#39;\n# Project\n\n```bash\necho &quot;String with $VAR and `backticks`&quot;\nsed &#39;s/find/replace/&#39; file\n```\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle code blocks with special chars&quot;\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_missing_project_directory\n    test_corrupted_yaml\n    test_empty_yaml\n    test_missing_readme\n    test_readme_special_characters\n    test_extremely_long_readme\n    test_invalid_logo_path\n    test_invalid_projects_json\n    test_missing_projects_file\n    test_projects_file_invalid_json\n    test_output_directory_creation\n    test_source_files_with_errors\n    test_empty_source_files\n    test_yaml_unicode_characters\n    test_base_path_special_chars\n    test_readme_code_blocks\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-dependencies.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-dependencies.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for leaf.sh dependency checking\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: check_dependencies detects missing yq\ntest_check_dependencies_missing_yq() {\n    setup\n    \n    # Create a test script that modifies PATH to hide yq\n    cat &gt; &quot;$TEST_DIR/test_no_yq.sh&quot; &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\nPATH=&quot;/nonexistent&quot;\nsource &quot;${1}&quot;\ncheck_dependencies 2&gt;&amp;1 || true\nEOF\n    \n    output=$(bash &quot;$TEST_DIR/test_no_yq.sh&quot; &quot;$LEAF_SH&quot;)\n    \n    assert_contains &quot;$output&quot; &quot;yq&quot; &quot;Should detect missing yq&quot;\n    assert_contains &quot;$output&quot; &quot;Missing required dependencies&quot; &quot;Should report missing dependencies&quot;\n    \n    teardown\n}\n\n# Test: check_dependencies detects missing jq\ntest_check_dependencies_missing_jq() {\n    setup\n    \n    # Create a test script that hides jq but keeps yq\n    cat &gt; &quot;$TEST_DIR/test_no_jq.sh&quot; &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\n# Create a fake yq that does nothing\nmkdir -p fake_bin\necho &#39;#!/usr/bin/env bash&#39; &gt; fake_bin/yq\nchmod +x fake_bin/yq\nPATH=&quot;$(pwd)/fake_bin:/nonexistent&quot;\nsource &quot;${1}&quot;\ncheck_dependencies 2&gt;&amp;1 || true\nEOF\n    \n    output=$(bash &quot;$TEST_DIR/test_no_jq.sh&quot; &quot;$LEAF_SH&quot;)\n    \n    assert_contains &quot;$output&quot; &quot;jq&quot; &quot;Should detect missing jq&quot;\n    \n    teardown\n}\n\n# Test: check_dependencies succeeds when both present\ntest_check_dependencies_success() {\n    setup\n    \n    # Only run if both yq and jq are available\n    if command -v yq &amp;&gt;/dev/null &amp;&amp; command -v jq &amp;&gt;/dev/null; then\n        cat &gt; &quot;$TEST_DIR/test_deps_ok.sh&quot; &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\nsource &quot;${1}&quot;\nif check_dependencies 2&gt;&amp;1; then\n    echo &quot;success&quot;\nelse\n    echo &quot;failure&quot;\nfi\nEOF\n        \n        output=$(bash &quot;$TEST_DIR/test_deps_ok.sh&quot; &quot;$LEAF_SH&quot;)\n        \n        assert_equals &quot;success&quot; &quot;$output&quot; &quot;Should succeed when dependencies present&quot;\n    else\n        log_skip &quot;Skipping test - yq or jq not available&quot;\n    fi\n    \n    teardown\n}\n\n# Test: dependency check shows installation links\ntest_dependency_install_links() {\n    setup\n    \n    cat &gt; &quot;$TEST_DIR/test_links.sh&quot; &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\nPATH=&quot;/nonexistent&quot;\nsource &quot;${1}&quot;\ncheck_dependencies 2&gt;&amp;1 || true\nEOF\n    \n    output=$(bash &quot;$TEST_DIR/test_links.sh&quot; &quot;$LEAF_SH&quot;)\n    \n    assert_contains &quot;$output&quot; &quot;https://github.com/mikefarah/yq&quot; &quot;Should show yq install link&quot;\n    assert_contains &quot;$output&quot; &quot;https://stedolan.github.io/jq&quot; &quot;Should show jq install link&quot;\n    \n    teardown\n}\n\n# Test: dependency check returns proper exit code\ntest_dependency_exit_code() {\n    setup\n    \n    cat &gt; &quot;$TEST_DIR/test_exit.sh&quot; &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\nPATH=&quot;/nonexistent&quot;\nsource &quot;${1}&quot;\ncheck_dependencies &gt;/dev/null 2&gt;&amp;1\necho $?\nEOF\n    \n    output=$(bash &quot;$TEST_DIR/test_exit.sh&quot; &quot;$LEAF_SH&quot;)\n    \n    assert_equals &quot;1&quot; &quot;$output&quot; &quot;Should return exit code 1 when dependencies missing&quot;\n    \n    teardown\n}\n\n# Test: main function exits when dependencies missing\ntest_main_exits_on_missing_deps() {\n    setup\n    \n    # Create a wrapper script that hides dependencies but keeps bash\n    cat &gt; &quot;$TEST_DIR/test_main_exit.sh&quot; &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\nPATH=&quot;/usr/bin:/bin&quot;\nexport PATH\n&quot;$BASH&quot; &quot;${1}&quot; --help 2&gt;&amp;1 || echo &quot;exited with $?&quot;\nEOF\n    \n    output=$(bash &quot;$TEST_DIR/test_main_exit.sh&quot; &quot;$LEAF_SH&quot;)\n    \n    # With PATH limited, yq/jq won&#39;t be found, but --help is processed before dependency check\n    # So we need to test without --help flag\n    cat &gt; &quot;$TEST_DIR/test_main_exit2.sh&quot; &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\nPATH=&quot;/usr/bin:/bin&quot;\nexport PATH\n&quot;$BASH&quot; &quot;${1}&quot; test-project -o output 2&gt;&amp;1 || true\nEOF\n    \n    output=$(bash &quot;$TEST_DIR/test_main_exit2.sh&quot; &quot;$LEAF_SH&quot;)\n    \n    # Should contain either missing yq or missing jq message\n    if echo &quot;$output&quot; | grep -q &quot;Missing required dependencies\\|yq\\|jq\\|myst&quot;; then\n        assert_true &quot;true&quot; &quot;Should report missing deps&quot;\n    else\n        assert_contains &quot;$output&quot; &quot;Missing required dependencies&quot; &quot;Should report missing deps&quot;\n    fi\n    \n    teardown\n}\n\n# Test: dependency check is called early\ntest_dependency_check_early() {\n    setup\n    \n    # Dependency check should happen before any real work\n    cat &gt; &quot;$TEST_DIR/test_early.sh&quot; &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\nPATH=&quot;/usr/bin:/bin&quot;\nexport PATH\noutput=$(&quot;$BASH&quot; &quot;${1}&quot; test-project 2&gt;&amp;1 || true)\n# Should fail on deps before trying to access project\necho &quot;$output&quot;\nEOF\n    \n    output=$(bash &quot;$TEST_DIR/test_early.sh&quot; &quot;$LEAF_SH&quot;)\n    \n    # Should contain dependency error (yq, jq, or myst missing)\n    if echo &quot;$output&quot; | grep -q &quot;Missing required dependencies\\|yq\\|jq\\|myst&quot;; then\n        assert_true &quot;true&quot; &quot;Should check dependencies first&quot;\n    else\n        assert_contains &quot;$output&quot; &quot;Missing required dependencies&quot; &quot;Should check dependencies first&quot;\n    fi\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_check_dependencies_missing_yq\n    test_check_dependencies_missing_jq\n    test_check_dependencies_success\n    test_dependency_install_links\n    test_dependency_exit_code\n    test_main_exits_on_missing_deps\n    test_dependency_check_early\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-landing-generation.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-landing-generation.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for leaf.sh landing page generation functionality\n# Updated with better error handling and debugging\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    export LEAF_TEST_MODE=1\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: landing page mode creates output file\ntest_landing_creates_output() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should create landing page&quot;\n    \n    teardown\n}\n\n# Test: landing page includes butter.sh branding\ntest_landing_buttersh_branding() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;butter.sh&quot; &quot;Should include butter.sh branding&quot;\n    \n    teardown\n}\n\n# Test: landing page includes default projects in JSON\ntest_landing_default_projects() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    # Projects are in JSON for JavaScript to render\n    assert_contains &quot;$html&quot; &quot;hammer.sh&quot; &quot;Should include hammer.sh in data&quot;\n    assert_contains &quot;$html&quot; &quot;arty.sh&quot; &quot;Should include arty.sh in data&quot;\n    assert_contains &quot;$html&quot; &quot;leaf.sh&quot; &quot;Should include leaf.sh in data&quot;\n    \n    teardown\n}\n\n# Test: landing page uses custom projects from argument\ntest_landing_custom_projects_argument() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://custom.com&quot;,&quot;label&quot;:&quot;Custom Project&quot;,&quot;desc&quot;:&quot;Custom description&quot;,&quot;class&quot;:&quot;card-project&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    # Check data is in the output (will be in JSON)\n    assert_contains &quot;$html&quot; &quot;custom.com&quot; &quot;Should include custom project URL&quot;\n    assert_contains &quot;$html&quot; &quot;Custom Project&quot; &quot;Should include custom label&quot;\n    \n    teardown\n}\n\n# Test: landing page uses projects from file\ntest_landing_projects_from_file() {\n    setup\n    \n    # Create projects file in test directory\n    cat &gt; projects.json &lt;&lt; &#39;EOF&#39;\n[\n  {\n    &quot;url&quot;: &quot;https://file-project.com&quot;,\n    &quot;label&quot;: &quot;File Project&quot;,\n    &quot;desc&quot;: &quot;From JSON file&quot;,\n    &quot;class&quot;: &quot;card-project&quot;\n  }\n]\nEOF\n    \n    # Verify file exists\n    if ! assert_file_exists &quot;projects.json&quot; &quot;Projects file should exist&quot;; then\n        teardown\n        return 1\n    fi\n    \n    # Run with error capture\n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects-file projects.json -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    # Debug output if failed\n    if [[ $exit_code -ne 0 ]]; then\n        echo &quot;Error: Command failed with exit code $exit_code&quot;\n        echo &quot;Output: $output&quot;\n    fi\n    \n    # Check if output was created\n    if [[ ! -f &quot;output/index.html&quot; ]]; then\n        echo &quot;Output file not created. Leaf.sh output:&quot;\n        echo &quot;$output&quot;\n        assert_file_exists &quot;output/index.html&quot; &quot;Should create output with projects file&quot;\n        teardown\n        return 1\n    fi\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;file-project.com&quot; &quot;Should include project from file&quot;\n    assert_contains &quot;$html&quot; &quot;File Project&quot; &quot;Should include label from file&quot;\n    \n    teardown\n}\n\n# Test: landing page prioritizes file over argument\ntest_landing_file_priority() {\n    setup\n    \n    # Create projects file\n    cat &gt; projects.json &lt;&lt; &#39;EOF&#39;\n[\n  {&quot;url&quot;:&quot;https://from-file.com&quot;,&quot;label&quot;:&quot;From File&quot;,&quot;desc&quot;:&quot;File&quot;,&quot;class&quot;:&quot;card&quot;}\n]\nEOF\n    \n    # Verify file exists\n    if ! assert_file_exists &quot;projects.json&quot; &quot;Projects file should exist&quot;; then\n        teardown\n        return 1\n    fi\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://from-arg.com&quot;,&quot;label&quot;:&quot;From Arg&quot;,&quot;desc&quot;:&quot;Arg&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    # Run with error capture\n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; --projects-file projects.json -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    # Debug output if failed\n    if [[ $exit_code -ne 0 ]]; then\n        echo &quot;Error: Command failed with exit code $exit_code&quot;\n        echo &quot;Output: $output&quot;\n    fi\n    \n    # Check if output was created\n    if [[ ! -f &quot;output/index.html&quot; ]]; then\n        echo &quot;Output file not created. Leaf.sh output:&quot;\n        echo &quot;$output&quot;\n        assert_file_exists &quot;output/index.html&quot; &quot;Should create output&quot;\n        teardown\n        return 1\n    fi\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;from-file.com&quot; &quot;Should use file&quot;\n    assert_not_contains &quot;$html&quot; &quot;from-arg.com&quot; &quot;Should not use argument&quot;\n    \n    teardown\n}\n\n# Test: landing page includes custom GitHub URL\ntest_landing_custom_github() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing --github https://github.com/custom-org -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;github.com/custom-org&quot; &quot;Should include custom GitHub URL&quot;\n    \n    teardown\n}\n\n# Test: landing page uses custom logo\ntest_landing_custom_logo() {\n    setup\n    \n    cat &gt; logo.svg &lt;&lt; &#39;EOF&#39;\n&lt;svg&gt;&lt;rect width=&quot;100&quot; height=&quot;100&quot; fill=&quot;red&quot;/&gt;&lt;/svg&gt;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; --landing --logo logo.svg -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;&lt;rect&quot; &quot;Should include custom logo SVG&quot;\n    \n    teardown\n}\n\n# Test: landing page respects base path\ntest_landing_base_path() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing --base-path /custom/ -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &#39;base href=&quot;/custom/&quot;&#39; &quot;Should set base path&quot;\n    \n    teardown\n}\n\n# Test: landing page includes multiple projects\ntest_landing_multiple_projects() {\n    setup\n    \n    projects=&#39;[\n      {&quot;url&quot;:&quot;https://proj1.com&quot;,&quot;label&quot;:&quot;Project 1&quot;,&quot;desc&quot;:&quot;First&quot;,&quot;class&quot;:&quot;card&quot;},\n      {&quot;url&quot;:&quot;https://proj2.com&quot;,&quot;label&quot;:&quot;Project 2&quot;,&quot;desc&quot;:&quot;Second&quot;,&quot;class&quot;:&quot;card&quot;},\n      {&quot;url&quot;:&quot;https://proj3.com&quot;,&quot;label&quot;:&quot;Project 3&quot;,&quot;desc&quot;:&quot;Third&quot;,&quot;class&quot;:&quot;card&quot;}\n    ]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;proj1.com&quot; &quot;Should include first project&quot;\n    assert_contains &quot;$html&quot; &quot;proj2.com&quot; &quot;Should include second project&quot;\n    assert_contains &quot;$html&quot; &quot;proj3.com&quot; &quot;Should include third project&quot;\n    \n    teardown\n}\n\n# Test: landing page includes project descriptions\ntest_landing_project_descriptions() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;,&quot;label&quot;:&quot;Test&quot;,&quot;desc&quot;:&quot;Unique project description&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;Unique project description&quot; &quot;Should include description in data&quot;\n    \n    teardown\n}\n\n# Test: landing page has valid HTML structure\ntest_landing_html_structure() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;&lt;!DOCTYPE html&gt;&quot; &quot;Should have DOCTYPE&quot;\n    assert_contains &quot;$html&quot; &quot;&lt;html&quot; &quot;Should have html tag&quot;\n    assert_contains &quot;$html&quot; &quot;&lt;head&gt;&quot; &quot;Should have head section&quot;\n    assert_contains &quot;$html&quot; &quot;&lt;body&quot; &quot;Should have body tag&quot;\n    \n    teardown\n}\n\n# Test: landing page includes meta tags\ntest_landing_meta_tags() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;&lt;meta&quot; &quot;Should include meta tags&quot;\n    assert_contains &quot;$html&quot; &quot;viewport&quot; &quot;Should include viewport meta&quot;\n    \n    teardown\n}\n\n# Test: landing page includes title\ntest_landing_title() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;&lt;title&gt;&quot; &quot;Should include title tag&quot;\n    assert_contains &quot;$html&quot; &quot;butter.sh&quot; &quot;Title should mention butter.sh&quot;\n    \n    teardown\n}\n\n# Test: landing page includes Tailwind CSS\ntest_landing_tailwind() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;tailwindcss&quot; &quot;Should include Tailwind CSS&quot;\n    \n    teardown\n}\n\n# Test: landing page includes responsive design elements\ntest_landing_responsive() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    # Check for Tailwind responsive classes\n    assert_contains &quot;$html&quot; &quot;md:&quot; &quot;Should have medium breakpoint classes&quot;\n    \n    teardown\n}\n\n# Test: landing page output to custom directory\ntest_landing_custom_output() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o custom/landing 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;custom/landing/index.html&quot; &quot;Should create in custom directory&quot;\n    \n    teardown\n}\n\n# Test: landing page handles empty projects array\ntest_landing_empty_projects() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects &#39;[]&#39; -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;empty&quot; &quot;Should warn about empty projects&quot;\n    assert_file_exists &quot;output/index.html&quot; &quot;Should still create output&quot;\n    \n    teardown\n}\n\n# Test: landing page handles projects with special characters\ntest_landing_special_chars_in_projects() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;,&quot;label&quot;:&quot;Project &amp; Co.&quot;,&quot;desc&quot;:&quot;Description with quotes&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle special characters&quot;\n    \n    teardown\n}\n\n# Test: landing page includes hero section\ntest_landing_hero_section() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    # Check for hero section content in template variables\n    assert_contains &quot;$html&quot; &quot;Modern bash development&quot; &quot;Should include hero content&quot;\n    \n    teardown\n}\n\n# Test: landing page includes CTA buttons\ntest_landing_cta_buttons() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;Explore&quot; &quot;Should include CTA text&quot;\n    \n    teardown\n}\n\n# Test: landing page includes script tag with projects JSON\ntest_landing_projects_json_script() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;,&quot;label&quot;:&quot;Test&quot;,&quot;desc&quot;:&quot;Desc&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    # Check that JavaScript will receive the projects data\n    assert_contains &quot;$html&quot; &quot;&lt;script&quot; &quot;Should include script tags&quot;\n    assert_contains &quot;$html&quot; &quot;projects&quot; &quot;Should reference projects in script&quot;\n    \n    teardown\n}\n\n# Test: landing page data format for JavaScript\ntest_landing_javascript_data() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    # Verify JSON structure for JavaScript (myst injects as variable)\n    assert_contains &quot;$html&quot; &quot;const projects&quot; &quot;Should define projects variable&quot;\n    \n    teardown\n}\n\n# Test: landing page uses myst templating\ntest_landing_uses_myst() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output using myst&quot;\n    \n    teardown\n}\n\n# Test: landing page handles very long project descriptions\ntest_landing_long_descriptions() {\n    setup\n    \n    long_desc=&quot;This is a very long project description that goes on and on and includes many details about the project and what it does and why it&#39;s useful&quot;\n    projects=&quot;[{\\&quot;url\\&quot;:\\&quot;https://test.com\\&quot;,\\&quot;label\\&quot;:\\&quot;Test\\&quot;,\\&quot;desc\\&quot;:\\&quot;$long_desc\\&quot;,\\&quot;class\\&quot;:\\&quot;card\\&quot;}]&quot;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;very long project description&quot; &quot;Should handle long descriptions&quot;\n    \n    teardown\n}\n\n# Test: landing page handles international characters in projects\ntest_landing_international_chars() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;,&quot;label&quot;:&quot;Prøject Ñame&quot;,&quot;desc&quot;:&quot;Descripción&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle international characters&quot;\n    \n    teardown\n}\n\n# Test: landing page handles projects with emoji\ntest_landing_emoji_in_projects() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;,&quot;label&quot;:&quot;🚀 Rocket Project&quot;,&quot;desc&quot;:&quot;Fast deployment 🔥&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;🚀&quot; &quot;Should include emoji in label&quot;\n    assert_contains &quot;$html&quot; &quot;🔥&quot; &quot;Should include emoji in description&quot;\n    \n    teardown\n}\n\n# Test: landing page JSON is valid\ntest_landing_valid_json_output() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;,&quot;label&quot;:&quot;Test&quot;,&quot;desc&quot;:&quot;Desc&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    # Extract JSON from the script tag to verify it&#39;s valid\n    # Projects JSON should be parseable\n    assert_contains &quot;$html&quot; &#39;&quot;url&quot;&#39; &quot;Should have JSON structure&quot;\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_landing_creates_output\n    test_landing_buttersh_branding\n    test_landing_default_projects\n    test_landing_custom_projects_argument\n    test_landing_projects_from_file\n    test_landing_file_priority\n    test_landing_custom_github\n    test_landing_custom_logo\n    test_landing_base_path\n    test_landing_multiple_projects\n    test_landing_project_descriptions\n    test_landing_html_structure\n    test_landing_meta_tags\n    test_landing_title\n    test_landing_tailwind\n    test_landing_responsive\n    test_landing_custom_output\n    test_landing_empty_projects\n    test_landing_special_chars_in_projects\n    test_landing_hero_section\n    test_landing_cta_buttons\n    test_landing_projects_json_script\n    test_landing_javascript_data\n    test_landing_uses_myst\n    test_landing_long_descriptions\n    test_landing_international_chars\n    test_landing_emoji_in_projects\n    test_landing_valid_json_output\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-yaml.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-yaml.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for leaf.sh YAML parsing functionality\n# Tests YAML parsing through actual documentation generation\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: parse_yaml retrieves simple field through docs generation\ntest_parse_yaml_simple_field() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    # Check if name appears in generated HTML\n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output&quot;\n    assert_contains &quot;$(cat output/index.html)&quot; &quot;test-project&quot; &quot;Should include project name&quot;\n    \n    teardown\n}\n\n# Test: parse_yaml retrieves version\ntest_parse_yaml_version() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;2.5.1&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_contains &quot;$(cat output/index.html)&quot; &quot;2.5.1&quot; &quot;Should include version&quot;\n    \n    teardown\n}\n\n# Test: parse_yaml handles missing file gracefully\ntest_parse_yaml_missing_file() {\n    setup\n    \n    mkdir -p test-project\n    # No arty.yml file\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    # Should still generate output\n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output without arty.yml&quot;\n    \n    teardown\n}\n\n# Test: parse_yaml handles missing field\ntest_parse_yaml_missing_field() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    # Should still generate with defaults\n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output with missing fields&quot;\n    \n    teardown\n}\n\n# Test: parse_yaml handles nested fields\ntest_parse_yaml_nested() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nauthor: &quot;Test Author&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle nested fields&quot;\n    \n    teardown\n}\n\n# Test: parse_yaml handles null values\ntest_parse_yaml_null() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\ndescription: null\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    # Should not crash, should generate output\n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle null values&quot;\n    \n    teardown\n}\n\n# Test: parse_yaml handles quoted strings\ntest_parse_yaml_quoted_strings() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\ndescription: &quot;A project with \\&quot;quotes\\&quot; inside&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle quoted strings&quot;\n    assert_contains &quot;$(cat output/index.html)&quot; &quot;quotes&quot; &quot;Should include content with quotes&quot;\n    \n    teardown\n}\n\n# Test: parse_yaml handles multiline strings\ntest_parse_yaml_multiline() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\ndescription: |\n  This is a\n  multiline description\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle multiline&quot;\n    # The multiline content should be present somewhere in the HTML\n    # It might have newlines converted or escaped, so check for key words\n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;description&quot; &quot;Should include description&quot;\n    \n    teardown\n}\n\n# Test: parse_yaml handles special characters\ntest_parse_yaml_special_chars() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\ndescription: &quot;Special chars: @#$%&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle special characters&quot;\n    \n    teardown\n}\n\n# Test: parse_yaml works with complete project\ntest_parse_yaml_complete() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;complete-project&quot;\nversion: &quot;1.2.3&quot;\ndescription: &quot;A complete test project&quot;\nauthor: &quot;Test Author&quot;\nlicense: &quot;MIT&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;complete-project&quot; &quot;Should include name&quot;\n    assert_contains &quot;$html&quot; &quot;1.2.3&quot; &quot;Should include version&quot;\n    assert_contains &quot;$html&quot; &quot;complete test project&quot; &quot;Should include description&quot;\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_parse_yaml_simple_field\n    test_parse_yaml_version\n    test_parse_yaml_missing_file\n    test_parse_yaml_missing_field\n    test_parse_yaml_nested\n    test_parse_yaml_null\n    test_parse_yaml_quoted_strings\n    test_parse_yaml_multiline\n    test_parse_yaml_special_chars\n    test_parse_yaml_complete\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-myst-integration.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-myst-integration.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for leaf.sh myst.sh integration and template rendering\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    export LEAF_TEST_MODE=1\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: find_myst locates myst.sh successfully\ntest_find_myst_success() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # If myst is available, this should succeed\n    if command -v myst &amp;&gt;/dev/null || [[ -x &quot;${SCRIPT_DIR}/../myst/myst.sh&quot; ]]; then\n        bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n        assert_file_exists &quot;output/index.html&quot; &quot;Should find and use myst&quot;\n    else\n        log_skip &quot;myst.sh not available for test&quot;\n    fi\n    \n    teardown\n}\n\n# Test: render_with_myst creates output file\ntest_render_with_myst_creates_file() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;render-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Myst should create output file&quot;\n    \n    teardown\n}\n\n# Test: myst rendering with docs template\ntest_myst_docs_template() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;docs-template-test&quot;\nversion: &quot;1.0.0&quot;\ndescription: &quot;Testing docs template&quot;\nEOF\n    \n    cat &gt; test-project/README.md &lt;&lt; &#39;EOF&#39;\n# Documentation Template Test\nThis tests the docs template rendering.\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;docs-template-test&quot; &quot;Should render project name&quot;\n    assert_contains &quot;$html&quot; &quot;Documentation Template Test&quot; &quot;Should render README&quot;\n    \n    teardown\n}\n\n# Test: myst rendering with landing template\ntest_myst_landing_template() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;butter.sh&quot; &quot;Should render landing page&quot;\n    \n    teardown\n}\n\n# Test: myst receives correct data for docs\ntest_myst_docs_data() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;data-test&quot;\nversion: &quot;9.8.7&quot;\ndescription: &quot;Testing data passing&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;data-test&quot; &quot;Should pass project name&quot;\n    assert_contains &quot;$html&quot; &quot;9.8.7&quot; &quot;Should pass version&quot;\n    assert_contains &quot;$html&quot; &quot;Testing data passing&quot; &quot;Should pass description&quot;\n    \n    teardown\n}\n\n# Test: myst receives correct data for landing\ntest_myst_landing_data() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://data-test.com&quot;,&quot;label&quot;:&quot;Data Test&quot;,&quot;desc&quot;:&quot;Test data&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; --github https://github.com/test-org -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;data-test.com&quot; &quot;Should pass projects data&quot;\n    assert_contains &quot;$html&quot; &quot;github.com/test-org&quot; &quot;Should pass GitHub URL&quot;\n    \n    teardown\n}\n\n# Test: myst template not found error handling\ntest_myst_template_not_found() {\n    setup\n    \n    # This would require modifying TEMPLATES_DIR which is tricky\n    # We&#39;ll test that the system handles template errors\n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;test-project&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Normal execution should work with templates present\n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle template availability&quot;\n    \n    teardown\n}\n\n# Test: myst JSON data file creation\ntest_myst_json_data_creation() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;json-test&quot;\nversion: &quot;1.0.0&quot;\ndescription: &quot;Testing JSON creation&quot;\nEOF\n    \n    # Enable debug to see data file information\n    DEBUG=1 bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    # If successful, output should exist\n    assert_file_exists &quot;output/index.html&quot; &quot;Should create JSON data and render&quot;\n    \n    teardown\n}\n\n# Test: myst handles special characters in data\ntest_myst_special_chars_in_data() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;special-chars-test&quot;\nversion: &quot;1.0.0&quot;\ndescription: &quot;Testing &lt;special&gt; &amp; \\&quot;characters\\&quot;&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_file_exists &quot;output/index.html&quot; &quot;Should handle special characters&quot;\n    \n    teardown\n}\n\n# Test: myst receives icon data\ntest_myst_icon_data() {\n    setup\n    \n    mkdir -p test-project/_assets/icon\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;icon-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/_assets/icon/icon.svg &lt;&lt; &#39;EOF&#39;\n&lt;svg id=&quot;unique-test-icon&quot;&gt;&lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot;/&gt;&lt;/svg&gt;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;unique-test-icon&quot; &quot;Should pass icon data to myst&quot;\n    \n    teardown\n}\n\n# Test: myst renders README content\ntest_myst_readme_rendering() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;readme-render-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/README.md &lt;&lt; &#39;EOF&#39;\n# Unique README Title\n\nThis is unique content that should be rendered by myst.\n\n## Section\nMore unique content here.\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;Unique README Title&quot; &quot;Should render README title&quot;\n    # Check for README presence - content may be processed/formatted\n    assert_contains &quot;$html&quot; &quot;README&quot; &quot;Should include README content area&quot;\n    \n    teardown\n}\n\n# Test: myst renders source files HTML\ntest_myst_source_files_rendering() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;source-render-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/unique-script.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\n# Unique source file marker\necho &quot;This should be rendered&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;unique-script.sh&quot; &quot;Should render source file name&quot;\n    assert_contains &quot;$html&quot; &quot;Unique source file marker&quot; &quot;Should render source file content&quot;\n    \n    teardown\n}\n\n# Test: myst renders examples HTML\ntest_myst_examples_rendering() {\n    setup\n    \n    mkdir -p test-project/examples\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;examples-render-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    cat &gt; test-project/examples/unique-example.sh &lt;&lt; &#39;EOF&#39;\n#!/bin/bash\n# Unique example marker\necho &quot;Example code here&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;unique-example.sh&quot; &quot;Should render example file name&quot;\n    \n    teardown\n}\n\n# Test: myst error handling\ntest_myst_error_handling() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;error-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Normal case should succeed\n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should complete even with potential myst issues&quot;\n    \n    teardown\n}\n\n# Test: myst partial templates support\ntest_myst_partials_support() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;partials-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Partials directory is passed to myst\n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should work with partials support&quot;\n    \n    teardown\n}\n\n# Test: myst base path handling\ntest_myst_base_path() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;base-path-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project --base-path /docs/v1/ -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &#39;base href=&quot;/docs/v1/&quot;&#39; &quot;Should pass base path to myst&quot;\n    \n    teardown\n}\n\n# Test: myst GitHub URL handling\ntest_myst_github_url() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;github-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project --github https://github.com/myorg/myrepo -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;github.com/myorg/myrepo&quot; &quot;Should pass GitHub URL to myst&quot;\n    \n    teardown\n}\n\n# Test: myst landing page logo rendering\ntest_myst_landing_logo() {\n    setup\n    \n    cat &gt; custom-logo.svg &lt;&lt; &#39;EOF&#39;\n&lt;svg id=&quot;unique-landing-logo&quot;&gt;&lt;rect width=&quot;100&quot; height=&quot;100&quot;/&gt;&lt;/svg&gt;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; --landing --logo custom-logo.svg -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;unique-landing-logo&quot; &quot;Should render custom logo in landing&quot;\n    \n    teardown\n}\n\n# Test: myst landing page projects rendering\ntest_myst_landing_projects() {\n    setup\n    \n    projects=&#39;[\n      {&quot;url&quot;:&quot;https://proj1.unique.com&quot;,&quot;label&quot;:&quot;Unique Proj 1&quot;,&quot;desc&quot;:&quot;First&quot;,&quot;class&quot;:&quot;card&quot;},\n      {&quot;url&quot;:&quot;https://proj2.unique.com&quot;,&quot;label&quot;:&quot;Unique Proj 2&quot;,&quot;desc&quot;:&quot;Second&quot;,&quot;class&quot;:&quot;card&quot;}\n    ]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;proj1.unique.com&quot; &quot;Should render first project&quot;\n    assert_contains &quot;$html&quot; &quot;proj2.unique.com&quot; &quot;Should render second project&quot;\n    assert_contains &quot;$html&quot; &quot;Unique Proj 1&quot; &quot;Should render first label&quot;\n    assert_contains &quot;$html&quot; &quot;Unique Proj 2&quot; &quot;Should render second label&quot;\n    \n    teardown\n}\n\n# Test: myst output verification\ntest_myst_output_verification() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;verify-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    # Verify output exists and is not empty\n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output&quot;\n    \n    size=$(stat -f%z &quot;output/index.html&quot; 2&gt;/dev/null || stat -c%s &quot;output/index.html&quot; 2&gt;/dev/null || echo &quot;1000&quot;)\n    assert_true &quot;[[ $size -gt 100 ]]&quot; &quot;Output should not be empty&quot;\n    \n    teardown\n}\n\n# Test: myst debug output\ntest_myst_debug_output() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;debug-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    output=$(DEBUG=1 bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;myst&quot; &quot;Debug should mention myst&quot;\n    \n    teardown\n}\n\n# Test: myst template resolution\ntest_myst_template_resolution() {\n    setup\n    \n    mkdir -p test-project\n    cat &gt; test-project/arty.yml &lt;&lt; &#39;EOF&#39;\nname: &quot;template-test&quot;\nversion: &quot;1.0.0&quot;\nEOF\n    \n    # Template should be found relative to SCRIPT_DIR\n    bash &quot;$LEAF_SH&quot; test-project -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should resolve templates correctly&quot;\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_find_myst_success\n    test_render_with_myst_creates_file\n    test_myst_docs_template\n    test_myst_landing_template\n    test_myst_docs_data\n    test_myst_landing_data\n    test_myst_template_not_found\n    test_myst_json_data_creation\n    test_myst_special_chars_in_data\n    test_myst_icon_data\n    test_myst_readme_rendering\n    test_myst_source_files_rendering\n    test_myst_examples_rendering\n    test_myst_error_handling\n    test_myst_partials_support\n    test_myst_base_path\n    test_myst_github_url\n    test_myst_landing_logo\n    test_myst_landing_projects\n    test_myst_output_verification\n    test_myst_debug_output\n    test_myst_template_resolution\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-leaf-json.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/leaf.sh/__tests/test-leaf-json.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for leaf.sh JSON parsing and validation\n# Tests JSON through landing page generation\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nLEAF_SH=&quot;${SCRIPT_DIR}/../leaf.sh&quot;\n\n\n# Setup before each test\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\n# Cleanup after each test\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test: Valid JSON is accepted\ntest_parse_json_valid() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;,&quot;label&quot;:&quot;Test&quot;,&quot;desc&quot;:&quot;Description&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output with valid JSON&quot;\n    assert_contains &quot;$(cat output/index.html)&quot; &quot;test.com&quot; &quot;Should include project URL&quot;\n    \n    teardown\n}\n\n# Test: Invalid JSON is rejected\ntest_parse_json_invalid() {\n    setup\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects &#39;not valid json&#39; -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should fail on invalid JSON&quot;\n    assert_contains &quot;$output&quot; &quot;Invalid JSON format&quot; &quot;Should report invalid JSON&quot;\n    \n    teardown\n}\n\n# Test: Empty array is handled\ntest_parse_json_empty() {\n    setup\n    \n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects &#39;[]&#39; -o output 2&gt;&amp;1)\n    \n    assert_contains &quot;$output&quot; &quot;empty&quot; &quot;Should warn about empty array&quot;\n    \n    teardown\n}\n\n# Test: Non-array JSON is rejected\ntest_validate_projects_json_not_array() {\n    setup\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects &#39;{&quot;url&quot;:&quot;test&quot;}&#39; -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should fail on non-array&quot;\n    assert_contains &quot;$output&quot; &quot;must be an array&quot; &quot;Should report must be array&quot;\n    \n    teardown\n}\n\n# Test: Minimal project JSON works (leaf doesn&#39;t validate required fields)\ntest_validate_projects_json_minimal() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should accept minimal JSON&quot;\n    \n    teardown\n}\n\n# Test: Complete project JSON works\ntest_validate_projects_json_complete() {\n    setup\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://test.com&quot;,&quot;label&quot;:&quot;Test&quot;,&quot;desc&quot;:&quot;Desc&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should accept complete projects&quot;\n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;test.com&quot; &quot;Should include URL&quot;\n    assert_contains &quot;$html&quot; &quot;Test&quot; &quot;Should include label&quot;\n    \n    teardown\n}\n\n# Test: Read JSON from valid file\ntest_read_json_file_valid() {\n    setup\n    \n    cat &gt; projects.json &lt;&lt; &#39;EOF&#39;\n[\n  {&quot;url&quot;:&quot;https://file-test.com&quot;,&quot;label&quot;:&quot;FileTest&quot;,&quot;desc&quot;:&quot;From file&quot;,&quot;class&quot;:&quot;card&quot;}\n]\nEOF\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects-file projects.json -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should create output from file&quot;\n    assert_contains &quot;$(cat output/index.html)&quot; &quot;file-test.com&quot; &quot;Should include project from file&quot;\n    \n    teardown\n}\n\n# Test: Missing JSON file is reported\ntest_read_json_file_missing() {\n    setup\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects-file nonexistent.json -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should fail on missing file&quot;\n    assert_contains &quot;$output&quot; &quot;not found&quot; &quot;Should report file not found&quot;\n    \n    teardown\n}\n\n# Test: Invalid JSON in file is reported\ntest_read_json_file_invalid() {\n    setup\n    \n    echo &quot;not valid json&quot; &gt; projects.json\n    \n    set +e\n    output=$(bash &quot;$LEAF_SH&quot; --landing --projects-file projects.json -o output 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    \n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Should fail on invalid JSON in file&quot;\n    \n    teardown\n}\n\n# Test: Multiple projects in array\ntest_parse_json_arrays() {\n    setup\n    \n    projects=&#39;[\n      {&quot;url&quot;:&quot;https://first.com&quot;,&quot;label&quot;:&quot;First&quot;,&quot;desc&quot;:&quot;First project&quot;,&quot;class&quot;:&quot;card&quot;},\n      {&quot;url&quot;:&quot;https://second.com&quot;,&quot;label&quot;:&quot;Second&quot;,&quot;desc&quot;:&quot;Second project&quot;,&quot;class&quot;:&quot;card&quot;}\n    ]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;first.com&quot; &quot;Should include first project&quot;\n    assert_contains &quot;$html&quot; &quot;second.com&quot; &quot;Should include second project&quot;\n    \n    teardown\n}\n\n# Test: Projects file takes priority over projects argument\ntest_projects_file_priority() {\n    setup\n    \n    cat &gt; projects.json &lt;&lt; &#39;EOF&#39;\n[{&quot;url&quot;:&quot;https://from-file.com&quot;,&quot;label&quot;:&quot;FromFile&quot;,&quot;desc&quot;:&quot;File&quot;,&quot;class&quot;:&quot;card&quot;}]\nEOF\n    \n    projects=&#39;[{&quot;url&quot;:&quot;https://from-arg.com&quot;,&quot;label&quot;:&quot;FromArg&quot;,&quot;desc&quot;:&quot;Arg&quot;,&quot;class&quot;:&quot;card&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; --projects-file projects.json -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;from-file.com&quot; &quot;Should use file&quot;\n    assert_not_contains &quot;$html&quot; &quot;from-arg.com&quot; &quot;Should not use argument&quot;\n    \n    teardown\n}\n\n# Test: Default projects used when none provided\ntest_default_projects() {\n    setup\n    \n    bash &quot;$LEAF_SH&quot; --landing -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    html=$(cat output/index.html)\n    assert_contains &quot;$html&quot; &quot;hammer.sh&quot; &quot;Should include hammer.sh&quot;\n    assert_contains &quot;$html&quot; &quot;arty.sh&quot; &quot;Should include arty.sh&quot;\n    assert_contains &quot;$html&quot; &quot;leaf.sh&quot; &quot;Should include leaf.sh&quot;\n    \n    teardown\n}\n\n# Test: JSON validation accepts any valid array structure\ntest_json_validation_flexible() {\n    setup\n    \n    # Array with minimal object - leaf doesn&#39;t enforce field requirements\n    projects=&#39;[{&quot;url&quot;:&quot;https://minimal.com&quot;}]&#39;\n    \n    bash &quot;$LEAF_SH&quot; --landing --projects &quot;$projects&quot; -o output 2&gt;&amp;1 &gt; /dev/null\n    \n    assert_file_exists &quot;output/index.html&quot; &quot;Should accept any object structure in array&quot;\n    \n    teardown\n}\n\n# Run all tests\nrun_tests() {\n    test_parse_json_valid\n    test_parse_json_invalid\n    test_parse_json_empty\n    test_validate_projects_json_not_array\n    test_validate_projects_json_minimal\n    test_validate_projects_json_complete\n    test_read_json_file_valid\n    test_read_json_file_missing\n    test_read_json_file_invalid\n    test_parse_json_arrays\n    test_projects_file_priority\n    test_default_projects\n    test_json_validation_flexible\n}\n\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    run_tests\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">setup.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/setup.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# setup.sh - Setup script for myst.sh\nset -euo pipefail\n\necho &quot;Setting up myst.sh...&quot;\n\n# Check dependencies\ncommand -v jq &gt;/dev/null 2&gt;&amp;1 || { echo &quot;Error: jq is required but not installed.&quot;; exit 1; }\ncommand -v yq &gt;/dev/null 2&gt;&amp;1 || { echo &quot;Warning: yq is not installed. YAML support will be limited.&quot;; }\n\n# Make main script executable\nchmod +x myst.sh\n\necho &quot;✓ Setup complete!&quot;\necho &quot;Run &#39;./myst.sh --help&#39; to get started&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/test.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# test.sh - Basic test suite for myst.sh\nset -euo pipefail\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nMYST=&quot;${SCRIPT_DIR}/myst.sh&quot;\n\n# Colors for output - only use colors if output is to a terminal or if FORCE_COLOR is set\nexport FORCE_COLOR=${FORCE_COLOR:-}\nif [[ -z &quot;$FORCE_COLOR&quot; ]]; then\n\t\tif [[ &quot;$FORCE_COLOR&quot; = &quot;1&quot; ]]; then\n\t\t\texport RED=&#39;\\033[0;31m&#39;\n\t\t\texport GREEN=&#39;\\033[0;32m&#39;\n\t\t\texport YELLOW=&#39;\\033[1;33m&#39;\n\t\t\texport BLUE=&#39;\\033[0;34m&#39;\n\t\t\texport CYAN=&#39;\\033[0;36m&#39;\n\t\t\texport MAGENTA=&#39;\\033[0;35m&#39;\n\t\t\texport BOLD=&#39;\\033[1m&#39;\n\t\t\texport NC=&#39;\\033[0m&#39;\n\n\t\telse\n\t\t\texport RED=&#39;&#39;\n\t\t\texport GREEN=&#39;&#39;\n\t\t\texport YELLOW=&#39;&#39;\n\t\t\texport BLUE=&#39;&#39;\n\t\t\texport CYAN=&#39;&#39;\n\t\t\texport MAGENTA=&#39;&#39;\n\t\t\texport BOLD=&#39;&#39;\n\t\t\texport NC=&#39;&#39;\n\t\tfi\nelif [[ -t 1 ]] &amp;&amp; [[ -t 2 ]]; then\n\t\texport RED=&#39;\\033[0;31m&#39;\n\t\texport GREEN=&#39;\\033[0;32m&#39;\n\t\texport YELLOW=&#39;\\033[1;33m&#39;\n\t\texport BLUE=&#39;\\033[0;34m&#39;\n\t\texport CYAN=&#39;\\033[0;36m&#39;\n\t\texport MAGENTA=&#39;\\033[0;35m&#39;\n\t\texport BOLD=&#39;\\033[1m&#39;\n\t\texport NC=&#39;\\033[0m&#39;\nelse\n    export RED=&#39;&#39;\n    export GREEN=&#39;&#39;\n    export YELLOW=&#39;&#39;\n    export BLUE=&#39;&#39;\n    export CYAN=&#39;&#39;\n\t\texport MAGENTA=&#39;&#39;\n\t\texport BOLD=&#39;&#39;\n\t\texport NC=&#39;&#39;\nfi\n\nTESTS_PASSED=0\nTESTS_FAILED=0\n\n# Test helper\nassert_equals() {\n    local expected=&quot;$1&quot;\n    local actual=&quot;$2&quot;\n    local test_name=&quot;$3&quot;\n    \n    if [[ &quot;$expected&quot; == &quot;$actual&quot; ]]; then\n        echo -e &quot;${GREEN}✓${NC} PASS: $test_name&quot;\n        TESTS_PASSED=$((TESTS_PASSED + 1))\n    else\n        echo -e &quot;${RED}✗${NC} FAIL: $test_name&quot;\n        echo &quot;  Expected: $expected&quot;\n        echo &quot;  Got:      $actual&quot;\n        TESTS_FAILED=$((TESTS_FAILED + 1))\n    fi\n}\n\nassert_contains() {\n    local needle=&quot;$1&quot;\n    local haystack=&quot;$2&quot;\n    local test_name=&quot;$3&quot;\n    \n    if [[ &quot;$haystack&quot; == *&quot;$needle&quot;* ]]; then\n        echo -e &quot;${GREEN}✓${NC} PASS: $test_name&quot;\n        TESTS_PASSED=$((TESTS_PASSED + 1))\n    else\n        echo -e &quot;${RED}✗${NC} FAIL: $test_name&quot;\n        echo &quot;  Expected to contain: $needle&quot;\n        echo &quot;  Got: $haystack&quot;\n        TESTS_FAILED=$((TESTS_FAILED + 1))\n    fi\n}\n\necho &quot;Running myst.sh test suite...&quot;\necho\n\n# Source myst.sh for testing\nsource &quot;$MYST&quot;\n\n#=============================================================================\n# Test 1: Variable interpolation\n#=============================================================================\necho &quot;Test Suite: Variable Interpolation&quot;\necho &quot;-----------------------------------&quot;\n\nmyst_set_var &quot;name&quot; &quot;Alice&quot;\nmyst_set_var &quot;age&quot; &quot;30&quot;\nresult=$(myst_render &quot;Hello, {{name}}! You are {{age}} years old.&quot;)\nassert_equals &quot;Hello, Alice! You are 30 years old.&quot; &quot;$result&quot; &quot;Basic variable interpolation&quot;\n\nresult=$(myst_render &quot;{{missing}} variable&quot;)\nassert_equals &quot; variable&quot; &quot;$result&quot; &quot;Missing variable returns empty string&quot;\n\necho\n\n#=============================================================================\n# Test 2: Conditionals\n#=============================================================================\necho &quot;Test Suite: Conditionals&quot;\necho &quot;------------------------&quot;\n\nmyst_set_var &quot;show&quot; &quot;true&quot;\nresult=$(myst_render &quot;{{#if show}}visible{{/if}}&quot;)\nassert_contains &quot;visible&quot; &quot;$result&quot; &quot;If with truthy value&quot;\n\nmyst_set_var &quot;show&quot; &quot;&quot;\nresult=$(myst_render &quot;{{#if show}}visible{{/if}}&quot;)\nassert_equals &quot;&quot; &quot;$result&quot; &quot;If with falsy value&quot;\n\nmyst_set_var &quot;hide&quot; &quot;&quot;\nresult=$(myst_render &quot;{{#unless hide}}visible{{/unless}}&quot;)\nassert_contains &quot;visible&quot; &quot;$result&quot; &quot;Unless with falsy value&quot;\n\nmyst_set_var &quot;hide&quot; &quot;true&quot;\nresult=$(myst_render &quot;{{#unless hide}}visible{{/unless}}&quot;)\nassert_equals &quot;&quot; &quot;$result&quot; &quot;Unless with truthy value&quot;\n\necho\n\n#=============================================================================\n# Test 3: Loops\n#=============================================================================\necho &quot;Test Suite: Loops&quot;\necho &quot;-----------------&quot;\n\nmyst_set_var &quot;items&quot; &quot;a,b,c&quot;\nresult=$(myst_render &quot;{{#each items}}{{this}},{{/each}}&quot;)\nassert_contains &quot;a,&quot; &quot;$result&quot; &quot;Loop iteration with comma-separated values&quot;\nassert_contains &quot;b,&quot; &quot;$result&quot; &quot;Loop contains all items&quot;\nassert_contains &quot;c,&quot; &quot;$result&quot; &quot;Loop contains all items&quot;\n\necho\n\n#=============================================================================\n# Test 4: JSON Loading\n#=============================================================================\necho &quot;Test Suite: JSON Loading&quot;\necho &quot;------------------------&quot;\n\n# Create temp JSON file\nTMP_JSON=$(mktemp)\necho &#39;{&quot;user&quot;:&quot;Bob&quot;,&quot;email&quot;:&quot;bob@example.com&quot;}&#39; &gt; &quot;$TMP_JSON&quot;\n\n# Reset vars\nMYST_VARS=()\nmyst_load_json &quot;$TMP_JSON&quot;\n\nresult=$(myst_get_var &quot;user&quot;)\nassert_equals &quot;Bob&quot; &quot;$result&quot; &quot;Load variable from JSON&quot;\n\nresult=$(myst_get_var &quot;email&quot;)\nassert_equals &quot;bob@example.com&quot; &quot;$result&quot; &quot;Load email from JSON&quot;\n\nrm &quot;$TMP_JSON&quot;\n\necho\n\n#=============================================================================\n# Test 5: Partials\n#=============================================================================\necho &quot;Test Suite: Partials&quot;\necho &quot;--------------------&quot;\n\nMYST_PARTIALS[&quot;header&quot;]=&quot;&lt;h1&gt;Header&lt;/h1&gt;&quot;\nresult=$(myst_render &quot;{{&gt; header}}&quot;)\nassert_contains &quot;&lt;h1&gt;Header&lt;/h1&gt;&quot; &quot;$result&quot; &quot;Partial inclusion&quot;\n\necho\n\n#=============================================================================\n# Test 6: Environment Variables\n#=============================================================================\necho &quot;Test Suite: Environment Variables&quot;\necho &quot;----------------------------------&quot;\n\nexport MYST_TEST_VAR=&quot;test_value&quot;\nexport MYST_OTHER=&quot;other_value&quot;\n\nMYST_VARS=()\nmyst_load_env &quot;MYST_&quot;\n\nresult=$(myst_get_var &quot;TEST_VAR&quot;)\nassert_equals &quot;test_value&quot; &quot;$result&quot; &quot;Load from environment with prefix&quot;\n\nresult=$(myst_get_var &quot;OTHER&quot;)\nassert_equals &quot;other_value&quot; &quot;$result&quot; &quot;Load multiple env vars&quot;\n\nunset MYST_TEST_VAR MYST_OTHER\n\necho\n\n#=============================================================================\n# Summary\n#=============================================================================\necho &quot;========================================&quot;\necho &quot;Test Results&quot;\necho &quot;========================================&quot;\necho -e &quot;Passed: ${GREEN}$TESTS_PASSED${NC}&quot;\necho -e &quot;Failed: ${RED}$TESTS_FAILED${NC}&quot;\necho &quot;Total:  $((TESTS_PASSED + TESTS_FAILED))&quot;\necho\n\nif [[ $TESTS_FAILED -eq 0 ]]; then\n    echo -e &quot;${GREEN}All tests passed!${NC}&quot;\n    exit 0\nelse\n    echo -e &quot;${RED}Some tests failed.${NC}&quot;\n    exit 1\nfi</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">static-site-generator.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/examples/static-site-generator.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# static-site-generator.sh - Example of using myst.sh as an embedded utility\n# This demonstrates how myst.sh can be integrated into other applications\n\nset -euo pipefail\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\n\n# Source myst.sh as a library\nsource &quot;${SCRIPT_DIR}/../myst.sh&quot;\n\n# Configuration\nPAGES_DIR=&quot;${SCRIPT_DIR}/site/pages&quot;\nLAYOUTS_DIR=&quot;${SCRIPT_DIR}/site/layouts&quot;\nPARTIALS_DIR=&quot;${SCRIPT_DIR}/site/partials&quot;\nDATA_FILE=&quot;${SCRIPT_DIR}/site/data.json&quot;\nOUTPUT_DIR=&quot;${SCRIPT_DIR}/site/dist&quot;\n\necho &quot;🏗️  Static Site Generator (powered by myst.sh)&quot;\necho &quot;================================================&quot;\necho\n\n# Create output directory\nmkdir -p &quot;$OUTPUT_DIR&quot;\n\n# Load global data\nif [[ -f &quot;$DATA_FILE&quot; ]]; then\n    log_info &quot;Loading site data from $DATA_FILE&quot;\n    myst_load_json &quot;$DATA_FILE&quot;\nfi\n\n# Load environment variables\nlog_info &quot;Loading environment variables&quot;\nmyst_load_env &quot;SITE_&quot;\n\n# Set build metadata\nmyst_set_var &quot;build_date&quot; &quot;$(date &#39;+%Y-%m-%d&#39;)&quot;\nmyst_set_var &quot;build_time&quot; &quot;$(date &#39;+%H:%M:%S&#39;)&quot;\nmyst_set_var &quot;generator&quot; &quot;myst.sh static site generator&quot;\n\n# Load all partials\nif [[ -d &quot;$PARTIALS_DIR&quot; ]]; then\n    log_info &quot;Loading partials from $PARTIALS_DIR&quot;\n    myst_load_partials_dir &quot;$PARTIALS_DIR&quot;\nfi\n\n# Load layout\nif [[ -f &quot;${LAYOUTS_DIR}/main.myst&quot; ]]; then\n    log_info &quot;Loading main layout&quot;\n    MYST_LAYOUTS[&quot;main&quot;]=$(cat &quot;${LAYOUTS_DIR}/main.myst&quot;)\nfi\n\n# Process all pages\nif [[ ! -d &quot;$PAGES_DIR&quot; ]]; then\n    die &quot;Pages directory not found: $PAGES_DIR&quot;\nfi\n\npage_count=0\n\nlog_info &quot;Processing pages...&quot;\necho\n\nfor page_file in &quot;$PAGES_DIR&quot;/*.myst; do\n    if [[ ! -f &quot;$page_file&quot; ]]; then\n        continue\n    fi\n    \n    page_name=$(basename &quot;$page_file&quot; .myst)\n    output_file=&quot;${OUTPUT_DIR}/${page_name}.html&quot;\n    \n    # Set page-specific variables\n    myst_set_var &quot;page_name&quot; &quot;$page_name&quot;\n    myst_set_var &quot;page_url&quot; &quot;/${page_name}.html&quot;\n    \n    # Load and render page\n    page_content=$(cat &quot;$page_file&quot;)\n    rendered=$(myst_render &quot;$page_content&quot;)\n    \n    # Save output\n    echo &quot;$rendered&quot; &gt; &quot;$output_file&quot;\n    \n    log_success &quot;Generated: $output_file&quot;\n    page_count=$((page_count + 1))\ndone\n\necho\necho &quot;================================================&quot;\nlog_success &quot;Build complete! Generated $page_count pages&quot;\nlog_info &quot;Output directory: $OUTPUT_DIR&quot;\necho\n\n# Generate index of all pages\nlog_info &quot;Generating site index...&quot;\n\nindex_content=&quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Site Index&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Generated Pages&lt;/h1&gt;\n  &lt;ul&gt;&quot;\n\nfor html_file in &quot;$OUTPUT_DIR&quot;/*.html; do\n    if [[ &quot;$(basename &quot;$html_file&quot;)&quot; != &quot;index.html&quot; ]] &amp;&amp; [[ -f &quot;$html_file&quot; ]]; then\n        name=$(basename &quot;$html_file&quot; .html)\n        index_content+=&quot;\n    &lt;li&gt;&lt;a href=&#39;${name}.html&#39;&gt;$name&lt;/a&gt;&lt;/li&gt;&quot;\n    fi\ndone\n\nindex_content+=&quot;\n  &lt;/ul&gt;\n  &lt;hr&gt;\n  &lt;p&gt;&lt;small&gt;Generated by myst.sh on $(date)&lt;/small&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;&quot;\n\necho &quot;$index_content&quot; &gt; &quot;${OUTPUT_DIR}/index.html&quot;\nlog_success &quot;Generated: ${OUTPUT_DIR}/index.html&quot;\n\necho\necho &quot;🎉 All done! Open ${OUTPUT_DIR}/index.html to view your site.&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">demo.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/examples/demo.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# demo.sh - Comprehensive demonstration of myst.sh features\n# This script showcases all the capabilities of the myst templating engine\n\nset -euo pipefail\n\n# Colors\nGREEN=&#39;\\033[0;32m&#39;\nBLUE=&#39;\\033[0;34m&#39;\nYELLOW=&#39;\\033[1;33m&#39;\nCYAN=&#39;\\033[0;36m&#39;\nNC=&#39;\\033[0m&#39;\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nMYST=&quot;${SCRIPT_DIR}/../myst.sh&quot;\n\necho -e &quot;${CYAN}========================================${NC}&quot;\necho -e &quot;${CYAN}    myst.sh Templating Engine Demo     ${NC}&quot;\necho -e &quot;${CYAN}========================================${NC}&quot;\necho\n\n# Check if myst.sh exists\nif [[ ! -f &quot;$MYST&quot; ]]; then\n    echo -e &quot;${YELLOW}Error: myst.sh not found at $MYST${NC}&quot;\n    exit 1\nfi\n\nchmod +x &quot;$MYST&quot;\n\n#=============================================================================\n# Demo 1: Simple Variable Interpolation\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 1]${NC} Simple Variable Interpolation&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Template:${NC} templates/simple.myst&quot;\necho -e &quot;${BLUE}Command:${NC} myst.sh render simple.myst -v name=Alice -v premium=true -v theme=dark&quot;\necho\n&quot;$MYST&quot; render &quot;${SCRIPT_DIR}/templates/simple.myst&quot; \\\n    -v name=Alice \\\n    -v premium=true \\\n    -v theme=dark\necho\necho\n\n#=============================================================================\n# Demo 2: Loops\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 2]${NC} Loop Structures&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Template:${NC} templates/list.myst&quot;\necho -e &quot;${BLUE}Command:${NC} myst.sh render list.myst -v items=&#39;Apples,Bananas,Oranges&#39; -v count=3&quot;\necho\n&quot;$MYST&quot; render &quot;${SCRIPT_DIR}/templates/list.myst&quot; \\\n    -v items=&quot;Apples,Bananas,Oranges,Grapes&quot; \\\n    -v count=4\necho\necho\n\n#=============================================================================\n# Demo 3: JSON Data Input\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 3]${NC} JSON Data Input&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Data file:${NC} data.json&quot;\necho -e &quot;${BLUE}Template:${NC} templates/simple.myst&quot;\necho -e &quot;${BLUE}Command:${NC} myst.sh render simple.myst -j data.json&quot;\necho\n&quot;$MYST&quot; render &quot;${SCRIPT_DIR}/templates/simple.myst&quot; \\\n    -j &quot;${SCRIPT_DIR}/data.json&quot;\necho\necho\n\n#=============================================================================\n# Demo 4: YAML Data Input (if yq is available)\n#=============================================================================\n\nif command -v yq &gt;/dev/null 2&gt;&amp;1; then\n    echo -e &quot;${GREEN}[Demo 4]${NC} YAML Data Input&quot;\n    echo &quot;-------------------------------------------&quot;\n    echo -e &quot;${BLUE}Data file:${NC} config.yml&quot;\n    echo -e &quot;${BLUE}Template:${NC} templates/simple.myst&quot;\n    echo -e &quot;${BLUE}Command:${NC} myst.sh render simple.myst -y config.yml&quot;\n    echo\n    &quot;$MYST&quot; render &quot;${SCRIPT_DIR}/templates/simple.myst&quot; \\\n        -y &quot;${SCRIPT_DIR}/config.yml&quot;\n    echo\n    echo\nelse\n    echo -e &quot;${YELLOW}[Demo 4]${NC} YAML Data Input - SKIPPED (yq not installed)&quot;\n    echo\nfi\n\n#=============================================================================\n# Demo 5: Partials\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 5]${NC} Template Partials&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Template:${NC} templates/with-partials.myst&quot;\necho -e &quot;${BLUE}Partials:${NC} partials/_header.myst, partials/_footer.myst, partials/_nav.myst&quot;\necho -e &quot;${BLUE}Command:${NC} myst.sh render with-partials.myst -p partials -j data.json&quot;\necho\n&quot;$MYST&quot; render &quot;${SCRIPT_DIR}/templates/with-partials.myst&quot; \\\n    -p &quot;${SCRIPT_DIR}/partials&quot; \\\n    -j &quot;${SCRIPT_DIR}/data.json&quot;\necho\necho\n\n#=============================================================================\n# Demo 6: Template Inheritance\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 6]${NC} Template Inheritance&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Layout:${NC} templates/layout.myst&quot;\necho -e &quot;${BLUE}Child:${NC} templates/page.myst&quot;\necho -e &quot;${BLUE}Command:${NC} myst.sh render page.myst -l layout.myst -j data.json&quot;\necho\n&quot;$MYST&quot; render &quot;${SCRIPT_DIR}/templates/page.myst&quot; \\\n    -l &quot;${SCRIPT_DIR}/templates/layout.myst&quot; \\\n    -j &quot;${SCRIPT_DIR}/data.json&quot;\necho\necho\n\n#=============================================================================\n# Demo 7: Environment Variables\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 7]${NC} Environment Variables&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Setting:${NC} export MYST_name=Bob MYST_premium=false MYST_theme=light&quot;\necho -e &quot;${BLUE}Template:${NC} templates/simple.myst&quot;\necho -e &quot;${BLUE}Command:${NC} myst.sh render simple.myst -e&quot;\necho\nexport MYST_name=Bob\nexport MYST_premium=false\nexport MYST_theme=light\n&quot;$MYST&quot; render &quot;${SCRIPT_DIR}/templates/simple.myst&quot; -e\nunset MYST_name MYST_premium MYST_theme\necho\necho\n\n#=============================================================================\n# Demo 8: Stdin Template\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 8]${NC} Template from Stdin&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Command:${NC} echo &#39;Hello {{name}}, welcome to {{app}}!&#39; | myst.sh render --stdin -v name=Charlie -v app=myst.sh&quot;\necho\necho &#39;Hello {{name}}, welcome to {{app}}!&#39; | &quot;$MYST&quot; render --stdin -v name=Charlie -v app=&quot;myst.sh&quot;\necho\necho\n\n#=============================================================================\n# Demo 9: Combined Data Sources\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 9]${NC} Combined Data Sources&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Description:${NC} Combining JSON, environment, and CLI variables&quot;\necho -e &quot;${BLUE}Command:${NC} Multiple sources with override precedence&quot;\necho\nexport MYST_theme=override_theme\n&quot;$MYST&quot; render &quot;${SCRIPT_DIR}/templates/simple.myst&quot; \\\n    -j &quot;${SCRIPT_DIR}/data.json&quot; \\\n    -e \\\n    -v name=&quot;Override Name&quot; \\\n    -v premium=false\nunset MYST_theme\necho\necho\n\n#=============================================================================\n# Demo 10: Output to File\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 10]${NC} Output to File&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Command:${NC} myst.sh render page.myst -l layout.myst -j data.json -o output.html&quot;\necho\n\nOUTPUT_FILE=&quot;${SCRIPT_DIR}/../output.html&quot;\n&quot;$MYST&quot; render &quot;${SCRIPT_DIR}/templates/page.myst&quot; \\\n    -l &quot;${SCRIPT_DIR}/templates/layout.myst&quot; \\\n    -j &quot;${SCRIPT_DIR}/data.json&quot; \\\n    -o &quot;$OUTPUT_FILE&quot;\n\nif [[ -f &quot;$OUTPUT_FILE&quot; ]]; then\n    echo -e &quot;${GREEN}✓${NC} File created successfully: $OUTPUT_FILE&quot;\n    echo -e &quot;${BLUE}Preview (first 10 lines):${NC}&quot;\n    head -10 &quot;$OUTPUT_FILE&quot;\n    echo &quot;...&quot;\nelse\n    echo -e &quot;${YELLOW}✗${NC} File creation failed&quot;\nfi\necho\necho\n\n#=============================================================================\n# Demo 11: Embedding myst as a library\n#=============================================================================\n\necho -e &quot;${GREEN}[Demo 11]${NC} Embedding myst.sh as a Library&quot;\necho &quot;-------------------------------------------&quot;\necho -e &quot;${BLUE}Description:${NC} Using myst functions in a script&quot;\necho\n\n# Source myst.sh to use it as a library\nsource &quot;$MYST&quot;\n\n# Set variables programmatically\nmyst_set_var &quot;app_name&quot; &quot;MyApp&quot;\nmyst_set_var &quot;version&quot; &quot;1.0.0&quot;\nmyst_set_var &quot;status&quot; &quot;active&quot;\n\n# Create a simple template\ntemplate=&#39;Application: {{app_name}}\nVersion: {{version}}\nStatus: {{#if status}}✓ Active{{/if}}&#39;\n\n# Render it\nresult=$(myst_render &quot;$template&quot;)\n\necho -e &quot;${BLUE}Rendered output:${NC}&quot;\necho &quot;$result&quot;\necho\necho\n\n#=============================================================================\n# Summary\n#=============================================================================\n\necho -e &quot;${CYAN}========================================${NC}&quot;\necho -e &quot;${GREEN}✓ Demo Complete!${NC}&quot;\necho -e &quot;${CYAN}========================================${NC}&quot;\necho\necho &quot;You&#39;ve seen all major features of myst.sh:&quot;\necho &quot;  • Variable interpolation&quot;\necho &quot;  • Conditionals (if/unless)&quot;\necho &quot;  • Loops (each)&quot;\necho &quot;  • Partials&quot;\necho &quot;  • Template inheritance&quot;\necho &quot;  • JSON/YAML input&quot;\necho &quot;  • Environment variables&quot;\necho &quot;  • Stdin input/output&quot;\necho &quot;  • Multiple data sources&quot;\necho &quot;  • Library embedding&quot;\necho\necho &quot;For more information, see:&quot;\necho &quot;  • README.md&quot;\necho &quot;  • DSL_DOCUMENTATION.md&quot;\necho &quot;  • ./myst.sh --help&quot;\necho</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">check-myst-source.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/check-myst-source.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Show lines around the bug in myst source template\n\nFILE=&quot;/home/valknar/Projects/hammer.sh/templates/myst/myst.sh&quot;\n\necho &quot;Lines 575-590 in source myst.sh:&quot;\nsed -n &#39;575,590p&#39; &quot;$FILE&quot;\n\necho &quot;&quot;\necho &quot;Looking for the problematic pattern:&quot;\ngrep -n &#39;if \\[\\[ &quot;$2&quot; =~ \\^MYST_&#39; &quot;$FILE&quot; || echo &quot;Pattern not found&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-config.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/__tests/test-config.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test configuration for myst.sh test suite\n# This file is sourced by test files to set common configuration\n\nexport TEST_ROOT=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\n\n# Test directory structure\nexport MYST_SH_ROOT=&quot;$PWD&quot;\n\n# Test behavior flags\nexport MYST_TEST_MODE=1\nexport MYST_SKIP_YQ_CHECK=0  # Set to 1 to skip yq availability check in tests\nexport MYST_SKIP_JQ_CHECK=0  # Set to 1 to skip jq availability check in tests\n\n# Color output in tests (set to 0 to disable)\nexport MYST_TEST_COLORS=1\n\n# Snapshot configuration\nexport SNAPSHOT_UPDATE=&quot;${UPDATE_SNAPSHOTS:-0}&quot;\nexport SNAPSHOT_VERBOSE=&quot;${VERBOSE:-0}&quot;\n\n# Auto-discover all test files matching test-myst-*.sh pattern\nshopt -s nullglob\nTEST_FILES_ARRAY=()\nfor test_file in ${TEST_ROOT}/test-myst-*.sh; do\n    if [[ -f &quot;$test_file&quot; ]]; then\n        TEST_FILES_ARRAY+=(&quot;$(basename &quot;$test_file&quot;)&quot;)\n    fi\ndone\nexport TEST_FILES=(&quot;${TEST_FILES_ARRAY[@]}&quot;)\nshopt -u nullglob</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-myst-partials.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/__tests/test-myst-partials.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for myst.sh - Partials\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nMYST_SH=&quot;${SCRIPT_DIR}/../myst.sh&quot;\n\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n    mkdir -p partials\n}\n\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test 1: Simple partial\ntest_simple_partial() {\n    setup\n    echo &quot;Header Content&quot; &gt; partials/header.myst\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{&gt; header}}\nBody\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -p partials 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Header Content&quot; &quot;Partial content&quot;\n    assert_contains &quot;$output&quot; &quot;Body&quot; &quot;Body content&quot;\n    teardown\n}\n\n# Test 2: Multiple partials\ntest_multiple_partials() {\n    setup\n    echo &quot;Header&quot; &gt; partials/header.myst\n    echo &quot;Footer&quot; &gt; partials/footer.myst\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{&gt; header}}\nBody\n{{&gt; footer}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -p partials 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Header&quot; &quot;Header partial&quot;\n    assert_contains &quot;$output&quot; &quot;Body&quot; &quot;Body content&quot;\n    assert_contains &quot;$output&quot; &quot;Footer&quot; &quot;Footer partial&quot;\n    teardown\n}\n\n# Test 3: Partial with variables\ntest_partial_with_vars() {\n    setup\n    echo &quot;Hello {{name}}!&quot; &gt; partials/greeting.myst\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{&gt; greeting}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -p partials -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Hello World!&quot; &quot;Partial with variable&quot;\n    teardown\n}\n\n# Test 4: Missing partial\ntest_missing_partial() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\nBefore\n{{&gt; nonexistent}}\nAfter\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -p partials 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Before&quot; &quot;Content before&quot;\n    assert_contains &quot;$output&quot; &quot;After&quot; &quot;Content after&quot;\n    teardown\n}\n\n# Test 5: Partial with spacing\ntest_partial_spacing() {\n    setup\n    echo &quot;Content&quot; &gt; partials/test.myst\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{&gt; test}}\n{{&gt;test}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -p partials 2&gt;&amp;1)\n    # Should contain Content at least once\n    assert_contains &quot;$output&quot; &quot;Content&quot; &quot;Partial renders&quot;\n    teardown\n}\n\n# Test 6: Partial with conditionals\ntest_partial_conditionals() {\n    setup\n    cat &gt; partials/conditional.myst &lt;&lt; &#39;EOF&#39;\n{{#if show}}\nVisible\n{{/if}}\nEOF\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{&gt; conditional}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -p partials -v show=true 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Visible&quot; &quot;Conditional in partial&quot;\n    teardown\n}\n\n# Test 7: Partial with loops\ntest_partial_loops() {\n    setup\n    cat &gt; partials/list.myst &lt;&lt; &#39;EOF&#39;\n{{#each items}}\n- {{this}}\n{{/each}}\nEOF\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{&gt; list}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -p partials -v items=&quot;A,B&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;- A&quot; &quot;Loop in partial A&quot;\n    assert_contains &quot;$output&quot; &quot;- B&quot; &quot;Loop in partial B&quot;\n    teardown\n}\n\n# Test 8: Partial HTML\ntest_partial_html() {\n    setup\n    echo &quot;&lt;nav&gt;Navigation&lt;/nav&gt;&quot; &gt; partials/nav.myst\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{&gt; nav}}\n&lt;main&gt;Content&lt;/main&gt;\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -p partials 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;&lt;nav&gt;Navigation&lt;/nav&gt;&quot; &quot;HTML partial&quot;\n    teardown\n}\n\nrun_tests() {\n    test_simple_partial\n    test_multiple_partials\n    test_partial_with_vars\n    test_missing_partial\n    test_partial_spacing\n    test_partial_conditionals\n    test_partial_loops\n    test_partial_html\n}\n\n[[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]] &amp;&amp; run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-myst-conditionals.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/__tests/test-myst-conditionals.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for myst.sh - Conditionals\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nMYST_SH=&quot;${SCRIPT_DIR}/../myst.sh&quot;\n\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test 1: If with true value\ntest_if_true() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#if show}}\nVisible\n{{/if}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v show=true 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Visible&quot; &quot;If with true&quot;\n    teardown\n}\n\n# Test 2: If with false value\ntest_if_false() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#if show}}\nHidden\n{{/if}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v show=false 2&gt;&amp;1)\n    assert_not_contains &quot;$output&quot; &quot;Hidden&quot; &quot;If with false&quot;\n    teardown\n}\n\n# Test 3: If with undefined variable\ntest_if_undefined() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#if missing}}\nHidden\n{{/if}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst 2&gt;&amp;1)\n    assert_not_contains &quot;$output&quot; &quot;Hidden&quot; &quot;If with undefined&quot;\n    teardown\n}\n\n# Test 4: If with non-empty string\ntest_if_nonempty() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#if name}}\nHello\n{{/if}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Hello&quot; &quot;If with non-empty string&quot;\n    teardown\n}\n\n# Test 5: Unless with false\ntest_unless_false() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#unless show}}\nVisible\n{{/unless}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v show=false 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Visible&quot; &quot;Unless with false&quot;\n    teardown\n}\n\n# Test 6: Unless with true\ntest_unless_true() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#unless show}}\nHidden\n{{/unless}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v show=true 2&gt;&amp;1)\n    assert_not_contains &quot;$output&quot; &quot;Hidden&quot; &quot;Unless with true&quot;\n    teardown\n}\n\n# Test 7: Unless with undefined\ntest_unless_undefined() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#unless missing}}\nVisible\n{{/unless}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Visible&quot; &quot;Unless with undefined&quot;\n    teardown\n}\n\n# Test 8: If with zero\ntest_if_zero() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#if count}}\nHidden\n{{/if}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v count=0 2&gt;&amp;1)\n    assert_not_contains &quot;$output&quot; &quot;Hidden&quot; &quot;If with zero&quot;\n    teardown\n}\n\n# Test 9: If with multiline content\ntest_if_multiline() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#if show}}\nLine 1\nLine 2\n{{/if}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v show=true 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Line 1&quot; &quot;If multiline - line 1&quot;\n    assert_contains &quot;$output&quot; &quot;Line 2&quot; &quot;If multiline - line 2&quot;\n    teardown\n}\n\n# Test 10: Variables inside if block\ntest_variables_in_if() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#if show}}\nHello {{name}}!\n{{/if}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v show=true -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Hello World!&quot; &quot;Variables inside if&quot;\n    teardown\n}\n\n# Test 11: Multiple if blocks\ntest_multiple_ifs() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#if a}}\nA\n{{/if}}\n{{#if b}}\nB\n{{/if}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v a=true -v b=true 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;A&quot; &quot;Multiple ifs - A&quot;\n    assert_contains &quot;$output&quot; &quot;B&quot; &quot;Multiple ifs - B&quot;\n    teardown\n}\n\n# Test 12: Content before and after if\ntest_content_around_if() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\nBefore\n{{#if show}}\nMiddle\n{{/if}}\nAfter\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v show=true 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Before&quot; &quot;Content before&quot;\n    assert_contains &quot;$output&quot; &quot;Middle&quot; &quot;Content middle&quot;\n    assert_contains &quot;$output&quot; &quot;After&quot; &quot;Content after&quot;\n    teardown\n}\n\nrun_tests() {\n    test_if_true\n    test_if_false\n    test_if_undefined\n    test_if_nonempty\n    test_unless_false\n    test_unless_true\n    test_unless_undefined\n    test_if_zero\n    test_if_multiline\n    test_variables_in_if\n    test_multiple_ifs\n    test_content_around_if\n}\n\n[[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]] &amp;&amp; run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-myst-variables.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/__tests/test-myst-variables.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for myst.sh - Variables\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nMYST_SH=&quot;${SCRIPT_DIR}/../myst.sh&quot;\n\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test 1: Simple variable\ntest_simple_variable() {\n    setup\n    echo &quot;Hello {{name}}!&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Hello World!&quot; &quot;Simple variable interpolation&quot;\n    teardown\n}\n\n# Test 2: Multiple variables\ntest_multiple_variables() {\n    setup\n    echo &quot;{{greeting}} {{name}}!&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v greeting=Hello -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Hello World!&quot; &quot;Multiple variables&quot;\n    teardown\n}\n\n# Test 3: Variable with underscore\ntest_variable_underscore() {\n    setup\n    echo &quot;User: {{user_name}}&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v user_name=admin 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;User: admin&quot; &quot;Variable with underscore&quot;\n    teardown\n}\n\n# Test 4: Variable with numbers\ntest_variable_numbers() {\n    setup\n    echo &quot;Version: {{v123}}&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v v123=1.0.0 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Version: 1.0.0&quot; &quot;Variable with numbers&quot;\n    teardown\n}\n\n# Test 5: Missing variable stays unchanged\ntest_missing_variable() {\n    setup\n    echo &quot;Hello {{undefined}}!&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;{{undefined}}&quot; &quot;Missing variable unchanged&quot;\n    teardown\n}\n\n# Test 6: Empty variable value\ntest_empty_variable() {\n    setup\n    echo &quot;Value: {{empty}}&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v empty= 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Value:&quot; &quot;Empty variable&quot;\n    teardown\n}\n\n# Test 7: Variable with special characters\ntest_special_characters() {\n    setup\n    echo &quot;Message: {{msg}}&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v &quot;msg=Hello @World!&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Message: Hello @World!&quot; &quot;Special characters&quot;\n    teardown\n}\n\n# Test 8: Multiple occurrences\ntest_multiple_occurrences() {\n    setup\n    echo &quot;{{name}} says {{name}}&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v name=Bob 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Bob says Bob&quot; &quot;Multiple occurrences&quot;\n    teardown\n}\n\n# Test 9: JSON variables\ntest_json_variables() {\n    setup\n    cat &gt; vars.json &lt;&lt; &#39;EOF&#39;\n{\n  &quot;title&quot;: &quot;Test&quot;,\n  &quot;author&quot;: &quot;John&quot;\n}\nEOF\n    echo &quot;{{title}} by {{author}}&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -j vars.json 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Test by John&quot; &quot;JSON variables&quot;\n    teardown\n}\n\n# Test 10: Numeric values\ntest_numeric_values() {\n    setup\n    echo &quot;Count: {{n}}&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v n=42 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Count: 42&quot; &quot;Numeric values&quot;\n    teardown\n}\n\n# Test 11: Variable with spaces in value\ntest_spaces_in_value() {\n    setup\n    echo &quot;Text: {{msg}}&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v &quot;msg=Hello World&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Text: Hello World&quot; &quot;Spaces in value&quot;\n    teardown\n}\n\nrun_tests() {\n    test_simple_variable\n    test_multiple_variables\n    test_variable_underscore\n    test_variable_numbers\n    test_missing_variable\n    test_empty_variable\n    test_special_characters\n    test_multiple_occurrences\n    test_json_variables\n    test_numeric_values\n    test_spaces_in_value\n}\n\n[[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]] &amp;&amp; run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-myst-loops.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/__tests/test-myst-loops.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for myst.sh - Loops\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nMYST_SH=&quot;${SCRIPT_DIR}/../myst.sh&quot;\n\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test 1: Simple loop\ntest_simple_loop() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#each items}}\n- {{this}}\n{{/each}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v items=&quot;A,B,C&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;- A&quot; &quot;Loop item A&quot;\n    assert_contains &quot;$output&quot; &quot;- B&quot; &quot;Loop item B&quot;\n    assert_contains &quot;$output&quot; &quot;- C&quot; &quot;Loop item C&quot;\n    teardown\n}\n\n# Test 2: Loop with dot syntax\ntest_loop_dot_syntax() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#each items}}\n* {{.}}\n{{/each}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v items=&quot;X,Y,Z&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;* X&quot; &quot;Dot syntax X&quot;\n    assert_contains &quot;$output&quot; &quot;* Y&quot; &quot;Dot syntax Y&quot;\n    assert_contains &quot;$output&quot; &quot;* Z&quot; &quot;Dot syntax Z&quot;\n    teardown\n}\n\n# Test 3: Loop with single item\ntest_single_item() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#each items}}\nItem: {{this}}\n{{/each}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v items=&quot;Single&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Item: Single&quot; &quot;Single item&quot;\n    teardown\n}\n\n# Test 4: Loop with empty array\ntest_empty_array() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\nStart\n{{#each items}}\n- {{this}}\n{{/each}}\nEnd\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v items=&quot;&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Start&quot; &quot;Empty loop start&quot;\n    assert_contains &quot;$output&quot; &quot;End&quot; &quot;Empty loop end&quot;\n    assert_not_contains &quot;$output&quot; &quot;- &quot; &quot;No items rendered&quot;\n    teardown\n}\n\n# Test 5: Loop with spaces in items\ntest_spaces_in_items() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#each items}}\n{{this}}\n{{/each}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v items=&quot;first item, second item&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;first item&quot; &quot;First item with space&quot;\n    assert_contains &quot;$output&quot; &quot;second item&quot; &quot;Second item with space&quot;\n    teardown\n}\n\n# Test 6: Loop with numbers\ntest_numeric_items() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#each nums}}\nNumber: {{this}}\n{{/each}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v nums=&quot;1,2,3&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Number: 1&quot; &quot;Number 1&quot;\n    assert_contains &quot;$output&quot; &quot;Number: 2&quot; &quot;Number 2&quot;\n    assert_contains &quot;$output&quot; &quot;Number: 3&quot; &quot;Number 3&quot;\n    teardown\n}\n\n# Test 7: Loop with HTML\ntest_loop_html() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n&lt;ul&gt;\n{{#each items}}\n&lt;li&gt;{{this}}&lt;/li&gt;\n{{/each}}\n&lt;/ul&gt;\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v items=&quot;A,B&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;&lt;li&gt;A&lt;/li&gt;&quot; &quot;HTML list item A&quot;\n    assert_contains &quot;$output&quot; &quot;&lt;li&gt;B&lt;/li&gt;&quot; &quot;HTML list item B&quot;\n    teardown\n}\n\n# Test 8: Multiple loops\ntest_multiple_loops() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#each list1}}\n{{this}}\n{{/each}}\n{{#each list2}}\n{{this}}\n{{/each}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v list1=&quot;A,B&quot; -v list2=&quot;X,Y&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;A&quot; &quot;First loop A&quot;\n    assert_contains &quot;$output&quot; &quot;B&quot; &quot;First loop B&quot;\n    assert_contains &quot;$output&quot; &quot;X&quot; &quot;Second loop X&quot;\n    assert_contains &quot;$output&quot; &quot;Y&quot; &quot;Second loop Y&quot;\n    teardown\n}\n\n# Test 9: Loop with external variable\ntest_loop_external_var() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\nPrefix: {{prefix}}\n{{#each items}}\n{{this}}\n{{/each}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v prefix=TEST -v items=&quot;A,B&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Prefix: TEST&quot; &quot;External variable&quot;\n    assert_contains &quot;$output&quot; &quot;A&quot; &quot;Loop item A&quot;\n    assert_contains &quot;$output&quot; &quot;B&quot; &quot;Loop item B&quot;\n    teardown\n}\n\n# Test 10: Loop with special characters\ntest_special_chars_in_loop() {\n    setup\n    cat &gt; template.myst &lt;&lt; &#39;EOF&#39;\n{{#each items}}\n- {{this}}\n{{/each}}\nEOF\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v items=&quot;@user,#tag&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;- @user&quot; &quot;Special char @&quot;\n    assert_contains &quot;$output&quot; &quot;- #tag&quot; &quot;Special char #&quot;\n    teardown\n}\n\nrun_tests() {\n    test_simple_loop\n    test_loop_dot_syntax\n    test_single_item\n    test_empty_array\n    test_spaces_in_items\n    test_numeric_items\n    test_loop_html\n    test_multiple_loops\n    test_loop_external_var\n    test_special_chars_in_loop\n}\n\n[[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]] &amp;&amp; run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-myst-errors.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/__tests/test-myst-errors.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for myst.sh - Error Handling\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nMYST_SH=&quot;${SCRIPT_DIR}/../myst.sh&quot;\n\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test 1: Missing template file\ntest_missing_template() {\n    setup\n    set +e\n    output=$(bash &quot;$MYST_SH&quot; render missing.myst 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Missing template exits 1&quot;\n    assert_contains &quot;$output&quot; &quot;not found&quot; &quot;Error message&quot;\n    teardown\n}\n\n# Test 2: Invalid JSON file\ntest_invalid_json() {\n    setup\n    echo &quot;not json&quot; &gt; bad.json\n    echo &quot;Test&quot; &gt; template.myst\n    set +e\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -j bad.json 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Invalid JSON exits 1&quot;\n    teardown\n}\n\n# Test 3: Missing JSON file\ntest_missing_json() {\n    setup\n    echo &quot;Test&quot; &gt; template.myst\n    set +e\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -j missing.json 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Missing JSON exits 1&quot;\n    assert_contains &quot;$output&quot; &quot;not found&quot; &quot;Error message&quot;\n    teardown\n}\n\n# Test 4: Unknown option\ntest_unknown_option() {\n    setup\n    echo &quot;Test&quot; &gt; template.myst\n    set +e\n    output=$(bash &quot;$MYST_SH&quot; render template.myst --badoption 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Unknown option fails&quot;\n    assert_contains &quot;$output&quot; &quot;Unknown option&quot; &quot;Error message&quot;\n    teardown\n}\n\n# Test 5: No template specified\ntest_no_template() {\n    setup\n    set +e\n    output=$(bash &quot;$MYST_SH&quot; render 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    assert_exit_code 1 &quot;$exit_code&quot; &quot;No template fails&quot;\n    assert_contains &quot;$output&quot; &quot;No template&quot; &quot;Error message&quot;\n    teardown\n}\n\n# Test 6: Empty template is OK\ntest_empty_template() {\n    setup\n    touch empty.myst\n    output=$(bash &quot;$MYST_SH&quot; render empty.myst 2&gt;&amp;1)\n    # Should succeed with empty output\n    assert_success &quot;Empty template succeeds&quot;\n    teardown\n}\n\nrun_tests() {\n    test_missing_template\n    test_invalid_json\n    test_missing_json\n    test_unknown_option\n    test_no_template\n    test_empty_template\n}\n\n[[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]] &amp;&amp; run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">test-myst-cli.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/__tests/test-myst-cli.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# Test suite for myst.sh - CLI Interface\n\nSCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;\nMYST_SH=&quot;${SCRIPT_DIR}/../myst.sh&quot;\n\nsetup() {\n    TEST_DIR=$(mktemp -d)\n    cd &quot;$TEST_DIR&quot;\n}\n\nteardown() {\n    cd /\n    rm -rf &quot;$TEST_DIR&quot;\n}\n\n# Test 1: Help command\ntest_help() {\n    setup\n    output=$(bash &quot;$MYST_SH&quot; --help 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;USAGE&quot; &quot;Help shows usage&quot;\n    assert_contains &quot;$output&quot; &quot;OPTIONS&quot; &quot;Help shows options&quot;\n    teardown\n}\n\n# Test 2: Version command\ntest_version() {\n    setup\n    output=$(bash &quot;$MYST_SH&quot; --version 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;version&quot; &quot;Version command&quot;\n    teardown\n}\n\n# Test 3: No arguments shows help\ntest_no_args() {\n    setup\n    output=$(bash &quot;$MYST_SH&quot; 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;USAGE&quot; &quot;No args shows help&quot;\n    teardown\n}\n\n# Test 4: Missing template file error\ntest_missing_template() {\n    setup\n    set +e\n    output=$(bash &quot;$MYST_SH&quot; render nonexistent.myst 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Missing template fails&quot;\n    assert_contains &quot;$output&quot; &quot;not found&quot; &quot;Error message&quot;\n    teardown\n}\n\n# Test 5: Render with -t flag\ntest_render_with_t_flag() {\n    setup\n    echo &quot;Hello {{name}}!&quot; &gt; test.myst\n    output=$(bash &quot;$MYST_SH&quot; render -t test.myst -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Hello World!&quot; &quot;Render with -t&quot;\n    teardown\n}\n\n# Test 6: Render with positional argument\ntest_render_positional() {\n    setup\n    echo &quot;Hello {{name}}!&quot; &gt; test.myst\n    output=$(bash &quot;$MYST_SH&quot; render test.myst -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Hello World!&quot; &quot;Render positional&quot;\n    teardown\n}\n\n# Test 7: Render shorthand (without &#39;render&#39; command)\ntest_render_shorthand() {\n    setup\n    echo &quot;Hello {{name}}!&quot; &gt; test.myst\n    output=$(bash &quot;$MYST_SH&quot; test.myst -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Hello World!&quot; &quot;Render shorthand&quot;\n    teardown\n}\n\n# Test 8: Stdin template\ntest_stdin_template() {\n    setup\n    output=$(echo &quot;Hello {{name}}!&quot; | bash &quot;$MYST_SH&quot; render --stdin -v name=World 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;Hello World!&quot; &quot;Stdin template&quot;\n    teardown\n}\n\n# Test 9: Output to file\ntest_output_file() {\n    setup\n    echo &quot;Test&quot; &gt; template.myst\n    bash &quot;$MYST_SH&quot; render template.myst -o output.txt 2&gt;&amp;1\n    assert_file_exists &quot;output.txt&quot; &quot;Output file created&quot;\n    content=$(cat output.txt)\n    assert_contains &quot;$content&quot; &quot;Test&quot; &quot;Output file content&quot;\n    teardown\n}\n\n# Test 10: Unknown option error\ntest_unknown_option() {\n    setup\n    echo &quot;Test&quot; &gt; template.myst\n    set +e\n    output=$(bash &quot;$MYST_SH&quot; render template.myst --unknown 2&gt;&amp;1)\n    exit_code=$?\n    set -e\n    assert_exit_code 1 &quot;$exit_code&quot; &quot;Unknown option fails&quot;\n    assert_contains &quot;$output&quot; &quot;Unknown option&quot; &quot;Error message&quot;\n    teardown\n}\n\n# Test 11: Variable via -v flag\ntest_var_flag() {\n    setup\n    echo &quot;{{x}}&quot; &gt; template.myst\n    output=$(bash &quot;$MYST_SH&quot; render template.myst -v x=42 2&gt;&amp;1)\n    assert_contains &quot;$output&quot; &quot;42&quot; &quot;Variable via -v&quot;\n    teardown\n}\n\nrun_tests() {\n    test_help\n    test_version\n    test_no_args\n    test_missing_template\n    test_render_with_t_flag\n    test_render_positional\n    test_render_shorthand\n    test_stdin_template\n    test_output_file\n    test_unknown_option\n    test_var_flag\n}\n\n[[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]] &amp;&amp; run_tests</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">myst.sh</h3><p class=\"text-blue-100 text-sm\">.arty/libs/myst.sh/myst.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n# myst.sh - Minimal Working Version\n# Version: 1.1.0\n\nset -euo pipefail\n\nVERSION=&quot;1.1.0&quot;\n\n# Global state\ndeclare -A MYST_VARS=()\ndeclare -A MYST_PARTIALS=()\n\n#=============================================================================\n# Core Functions\n#=============================================================================\n\ndie() {\n    echo &quot;[ERROR] $*&quot; &gt;&amp;2\n    exit 1\n}\n\n#=============================================================================\n# Variable Management\n#=============================================================================\n\nmyst_set_var() {\n    MYST_VARS[&quot;$1&quot;]=&quot;$2&quot;\n}\n\nmyst_load_json() {\n    [[ ! -f &quot;$1&quot; ]] &amp;&amp; die &quot;JSON file not found: $1&quot;\n    \n    # Test if jq can parse it first\n    if ! jq empty &quot;$1&quot; 2&gt;/dev/null; then\n        die &quot;Invalid JSON in $1&quot;\n    fi\n    \n    while IFS=&#39;=&#39; read -r key value; do\n        [[ -n &quot;$key&quot; ]] &amp;&amp; MYST_VARS[&quot;$key&quot;]=&quot;$value&quot;\n    done &lt; &lt;(jq -r &#39;to_entries | .[] | &quot;\\(.key)=\\(.value)&quot;&#39; &quot;$1&quot; 2&gt;/dev/null)\n}\n\nmyst_load_env() {\n    local prefix=&quot;${1:-MYST_}&quot;\n    while IFS=&#39;=&#39; read -r key value; do\n        if [[ &quot;$key&quot; =~ ^${prefix}(.+)$ ]]; then\n            MYST_VARS[&quot;${BASH_REMATCH[1]}&quot;]=&quot;$value&quot;\n        fi\n    done &lt; &lt;(env)\n}\n\n#=============================================================================\n# Rendering\n#=============================================================================\n\n# HTML escape function\nhtml_escape() {\n    local text=&quot;$1&quot;\n    text=&quot;${text//&amp;/&amp;amp;}&quot;\n    text=&quot;${text//&lt;/&amp;lt;}&quot;\n    text=&quot;${text//&gt;/&amp;gt;}&quot;\n    text=&quot;${text//\\&quot;/&amp;quot;}&quot;\n    text=&quot;${text//\\&#39;/&amp;#39;}&quot;\n    printf &#39;%s&#39; &quot;$text&quot;\n}\n\nmyst_render_vars() {\n    local content=&quot;$1&quot;\n    \n    # First pass: Handle unescaped variables {{{var}}} and {{&amp;var}}\n    for key in &quot;${!MYST_VARS[@]}&quot;; do\n        local value=&quot;${MYST_VARS[$key]}&quot;\n        # Triple braces (unescaped)\n        content=&quot;${content//\\{\\{\\{${key}\\}\\}\\}/$value}&quot;\n        # Ampersand syntax (unescaped)\n        content=&quot;${content//\\{\\{&amp;${key}\\}\\}/$value}&quot;\n    done\n    \n    # Second pass: Handle regular escaped variables {{var}}\n    for key in &quot;${!MYST_VARS[@]}&quot;; do\n        local value=&quot;${MYST_VARS[$key]}&quot;\n        local escaped_value=$(html_escape &quot;$value&quot;)\n        content=&quot;${content//\\{\\{${key}\\}\\}/$escaped_value}&quot;\n    done\n    \n    printf &#39;%s&#39; &quot;$content&quot;\n}\n\nmyst_render_conditionals() {\n    local content=&quot;$1&quot;\n    \n    # Skip if no conditionals\n    [[ ! &quot;$content&quot; =~ \\{\\{#(if|unless) ]] &amp;&amp; printf &#39;%s&#39; &quot;$content&quot; &amp;&amp; return\n    \n    local output=&quot;&quot; state=&quot;normal&quot; var_name=&quot;&quot; block=&quot;&quot; is_unless=false\n    \n    while IFS= read -r line; do\n        if [[ &quot;$state&quot; == &quot;normal&quot; ]]; then\n            if [[ &quot;$line&quot; =~ ^\\{\\{#if[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*)\\}\\}$ ]]; then\n                var_name=&quot;${BASH_REMATCH[1]}&quot;\n                block=&quot;&quot;\n                is_unless=false\n                state=&quot;in_block&quot;\n            elif [[ &quot;$line&quot; =~ ^\\{\\{#unless[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*)\\}\\}$ ]]; then\n                var_name=&quot;${BASH_REMATCH[1]}&quot;\n                block=&quot;&quot;\n                is_unless=true\n                state=&quot;in_block&quot;\n            else\n                output+=&quot;$line&quot;$&#39;\\n&#39;\n            fi\n        elif [[ &quot;$state&quot; == &quot;in_block&quot; ]]; then\n            if [[ &quot;$line&quot; =~ ^\\{\\{/(if|unless)\\}\\}$ ]]; then\n                local value=&quot;${MYST_VARS[$var_name]:-}&quot;\n                local render=false\n                \n                if [[ &quot;$is_unless&quot; == true ]]; then\n                    [[ -z &quot;$value&quot; || &quot;$value&quot; == &quot;false&quot; || &quot;$value&quot; == &quot;0&quot; ]] &amp;&amp; render=true\n                else\n                    [[ -n &quot;$value&quot; &amp;&amp; &quot;$value&quot; != &quot;false&quot; &amp;&amp; &quot;$value&quot; != &quot;0&quot; ]] &amp;&amp; render=true\n                fi\n                \n                [[ &quot;$render&quot; == true ]] &amp;&amp; output+=&quot;$block&quot;\n                state=&quot;normal&quot;\n            else\n                block+=&quot;$line&quot;$&#39;\\n&#39;\n            fi\n        fi\n    done &lt;&lt;&lt; &quot;$content&quot;\n    \n    printf &#39;%s&#39; &quot;${output%$&#39;\\n&#39;}&quot;\n}\n\nmyst_render_loops() {\n    local content=&quot;$1&quot;\n    \n    # Skip if no loops\n    [[ ! &quot;$content&quot; =~ \\{\\{#each ]] &amp;&amp; printf &#39;%s&#39; &quot;$content&quot; &amp;&amp; return\n    \n    local output=&quot;&quot; state=&quot;normal&quot; var_name=&quot;&quot; block=&quot;&quot;\n    \n    while IFS= read -r line; do\n        if [[ &quot;$state&quot; == &quot;normal&quot; ]]; then\n            if [[ &quot;$line&quot; =~ ^\\{\\{#each[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*)\\}\\}$ ]]; then\n                var_name=&quot;${BASH_REMATCH[1]}&quot;\n                block=&quot;&quot;\n                state=&quot;in_loop&quot;\n            else\n                output+=&quot;$line&quot;$&#39;\\n&#39;\n            fi\n        elif [[ &quot;$state&quot; == &quot;in_loop&quot; ]]; then\n            if [[ &quot;$line&quot; =~ ^\\{\\{/each\\}\\}$ ]]; then\n                local array_value=&quot;${MYST_VARS[$var_name]:-}&quot;\n                \n                if [[ -n &quot;$array_value&quot; ]]; then\n                    IFS=&#39;,&#39; read -ra items &lt;&lt;&lt; &quot;$array_value&quot;\n                    for item in &quot;${items[@]}&quot;; do\n                        # Trim\n                        item=&quot;${item#&quot;${item%%[![:space:]]*}&quot;}&quot;\n                        item=&quot;${item%&quot;${item##*[![:space:]]}&quot;}&quot;\n                        # Replace\n                        local rendered=&quot;$block&quot;\n                        rendered=&quot;${rendered//\\{\\{this\\}\\}/$item}&quot;\n                        rendered=&quot;${rendered//\\{\\{.\\}\\}/$item}&quot;\n                        output+=&quot;$rendered&quot;\n                    done\n                fi\n                state=&quot;normal&quot;\n            else\n                block+=&quot;$line&quot;$&#39;\\n&#39;\n            fi\n        fi\n    done &lt;&lt;&lt; &quot;$content&quot;\n    \n    printf &#39;%s&#39; &quot;${output%$&#39;\\n&#39;}&quot;\n}\n\nmyst_render_partials() {\n    local content=&quot;$1&quot;\n    \n    # Skip if no partials\n    [[ ! &quot;$content&quot; =~ \\{\\{\\&gt; ]] &amp;&amp; printf &#39;%s&#39; &quot;$content&quot; &amp;&amp; return\n    \n    local max_iter=100 iter=0\n    \n    while [[ &quot;$content&quot; =~ \\{\\{\\&gt;[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)\\}\\} ]] &amp;&amp; (( iter &lt; max_iter )); do\n        local name=&quot;${BASH_REMATCH[1]}&quot;\n        local partial=&quot;${MYST_PARTIALS[$name]:-}&quot;\n        content=&quot;${content//\\{\\{&gt; $name\\}\\}/$partial}&quot;\n        content=&quot;${content//\\{\\{&gt;$name\\}\\}/$partial}&quot;\n        (( iter++ ))\n    done\n    \n    printf &#39;%s&#39; &quot;$content&quot;\n}\n\nmyst_render() {\n    local content=&quot;$1&quot;\n    content=$(myst_render_partials &quot;$content&quot;)\n    content=$(myst_render_loops &quot;$content&quot;)\n    content=$(myst_render_conditionals &quot;$content&quot;)\n    content=$(myst_render_vars &quot;$content&quot;)\n    printf &#39;%s&#39; &quot;$content&quot;\n}\n\n#=============================================================================\n# Template Loading\n#=============================================================================\n\nmyst_load_template() {\n    [[ ! -f &quot;$1&quot; ]] &amp;&amp; die &quot;Template not found: $1&quot;\n    cat &quot;$1&quot;\n}\n\nmyst_load_partials_dir() {\n    [[ ! -d &quot;$1&quot; ]] &amp;&amp; return 0\n    while IFS= read -r -d &#39;&#39; file; do\n        local name=$(basename &quot;$file&quot; .myst)\n        MYST_PARTIALS[&quot;$name&quot;]=$(cat &quot;$file&quot;)\n    done &lt; &lt;(find &quot;$1&quot; -name &quot;*.myst&quot; -type f -print0 2&gt;/dev/null)\n}\n\n#=============================================================================\n# CLI\n#=============================================================================\n\nshow_help() {\n    cat &lt;&lt; &#39;EOF&#39;\nmyst.sh - Minimal templating engine\n\nUSAGE:\n    myst.sh [OPTIONS] &lt;template&gt;\n\nOPTIONS:\n    -v, --var KEY=VALUE     Set variable\n    -j, --json FILE         Load JSON\n    -e, --env [PREFIX]      Load env vars (default: MYST_)\n    -p, --partials DIR      Partials directory\n    -o, --output FILE       Output file\n    --stdin                 Read from stdin\n    -h, --help              Show help\n    -V, --version           Show version\nEOF\n}\n\nshow_version() {\n    echo &quot;myst.sh version $VERSION&quot;\n}\n\nmain() {\n    local template_file=&quot;&quot; output_file=&quot;&quot; use_stdin=false partials_dir=&quot;&quot;\n    \n    # No args = help\n    if [[ $# -eq 0 ]]; then\n        show_help\n        exit 0\n    fi\n    \n    # Parse arguments\n    while [[ $# -gt 0 ]]; do\n        case &quot;$1&quot; in\n            -h|--help)\n                show_help\n                exit 0\n                ;;\n            -V|--version)\n                show_version\n                exit 0\n                ;;\n            --stdin)\n                use_stdin=true\n                shift\n                ;;\n            -v|--var)\n                if [[ &quot;$2&quot; =~ ^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$ ]]; then\n                    myst_set_var &quot;${BASH_REMATCH[1]}&quot; &quot;${BASH_REMATCH[2]}&quot;\n                fi\n                shift 2\n                ;;\n            -j|--json)\n                myst_load_json &quot;$2&quot;\n                shift 2\n                ;;\n            -e|--env)\n                if [[ -n &quot;${2:-}&quot; ]] &amp;&amp; [[ &quot;$2&quot; != -* ]]; then\n                    myst_load_env &quot;$2&quot;\n                    shift 2\n                else\n                    myst_load_env &quot;MYST_&quot;\n                    shift\n                fi\n                ;;\n            -p|--partials)\n                partials_dir=&quot;$2&quot;\n                shift 2\n                ;;\n            -o|--output)\n                output_file=&quot;$2&quot;\n                shift 2\n                ;;\n            -t|--template)\n                template_file=&quot;$2&quot;\n                shift 2\n                ;;\n            render)\n                # Skip &#39;render&#39; command\n                shift\n                ;;\n            -*)\n                die &quot;Unknown option: $1&quot;\n                ;;\n            *)\n                if [[ -z &quot;$template_file&quot; ]]; then\n                    template_file=&quot;$1&quot;\n                fi\n                shift\n                ;;\n        esac\n    done\n    \n    # Load partials\n    [[ -n &quot;$partials_dir&quot; ]] &amp;&amp; myst_load_partials_dir &quot;$partials_dir&quot;\n    \n    # Load template\n    local content=&quot;&quot;\n    if [[ &quot;$use_stdin&quot; == true ]]; then\n        content=$(cat)\n    elif [[ -n &quot;$template_file&quot; ]]; then\n        content=$(myst_load_template &quot;$template_file&quot;)\n    else\n        die &quot;No template specified&quot;\n    fi\n    \n    # Render\n    local result=$(myst_render &quot;$content&quot;)\n    \n    # Output\n    if [[ -n &quot;$output_file&quot; ]]; then\n        printf &#39;%s&#39; &quot;$result&quot; &gt; &quot;$output_file&quot;\n    else\n        printf &#39;%s&#39; &quot;$result&quot;\n    fi\n}\n\n# Run main\nmain &quot;$@&quot;</code></pre></div></div><div class=\"bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden\"><div class=\"bg-gradient-to-r from-blue-500 to-blue-600 px-6 py-4\"><h3 class=\"text-xl font-semibold text-white\">whip.sh</h3><p class=\"text-blue-100 text-sm\">whip.sh</p></div><div class=\"p-6\"><pre><code class=\"language-bash\">#!/usr/bin/env bash\n\n# whip.sh - Release cycle management for arty.sh projects\n# Handles semver versioning, changelogs, git tags, commit hooks, and monorepo operations\n# Version: 1.0.0\n\nset -euo pipefail\n\n# Colors for output - only use colors if output is to a terminal or if FORCE_COLOR is set\nexport FORCE_COLOR=${FORCE_COLOR:-&quot;1&quot;}\nif [ &quot;$FORCE_COLOR&quot; = &quot;0&quot; ]; then\n  export RED=&#39;&#39;\n  export GREEN=&#39;&#39;\n  export YELLOW=&#39;&#39;\n  export BLUE=&#39;&#39;\n  export CYAN=&#39;&#39;\n  export MAGENTA=&#39;&#39;\n  export BOLD=&#39;&#39;\n  export NC=&#39;&#39;\nelse\n  export RED=&#39;\\033[0;31m&#39;\n  export GREEN=&#39;\\033[0;32m&#39;\n  export YELLOW=&#39;\\033[1;33m&#39;\n  export BLUE=&#39;\\033[0;34m&#39;\n  export CYAN=&#39;\\033[0;36m&#39;\n  export MAGENTA=&#39;\\033[0;35m&#39;\n  export BOLD=&#39;\\033[1m&#39;\n  export NC=&#39;\\033[0m&#39;\nfi\n\n# Configuration\nWHIP_CONFIG=&quot;${WHIP_CONFIG:-arty.yml}&quot;\nWHIP_HOOKS_DIR=&quot;.whip/hooks&quot;\nWHIP_CHANGELOG=&quot;${WHIP_CHANGELOG:-CHANGELOG.md}&quot;\n\n# Logging functions\nlog_info() {\n    echo -e &quot;${BLUE}[INFO]${NC} $1&quot; &gt;&amp;2\n}\n\nlog_success() {\n    echo -e &quot;${GREEN}[✓]${NC} $1&quot; &gt;&amp;2\n}\n\nlog_warn() {\n    echo -e &quot;${YELLOW}[⚠]${NC} $1&quot; &gt;&amp;2\n}\n\nlog_error() {\n    echo -e &quot;${RED}[✗]${NC} $1&quot; &gt;&amp;2\n}\n\nlog_step() {\n    echo -e &quot;${CYAN}[→]${NC} $1&quot; &gt;&amp;2\n}\n\n# Check if yq is installed\ncheck_dependencies() {\n    local missing=0\n    \n    if ! command -v yq &amp;&gt; /dev/null; then\n        log_error &quot;yq is not installed&quot;\n        missing=1\n    fi\n    \n    if ! command -v git &amp;&gt; /dev/null; then\n        log_error &quot;git is not installed&quot;\n        missing=1\n    fi\n    \n    if [[ $missing -eq 1 ]]; then\n        log_error &quot;Missing required dependencies&quot;\n        exit 1\n    fi\n}\n\n# Get current version from arty.yml\nget_current_version() {\n    local config=&quot;${1:-$WHIP_CONFIG}&quot;\n    \n    if [[ ! -f &quot;$config&quot; ]]; then\n        echo &quot;0.0.0&quot;\n        return\n    fi\n    \n    local version=$(yq eval &#39;.version&#39; &quot;$config&quot; 2&gt;/dev/null)\n    if [[ -z &quot;$version&quot; ]] || [[ &quot;$version&quot; == &quot;null&quot; ]]; then\n        echo &quot;0.0.0&quot;\n    else\n        echo &quot;$version&quot;\n    fi\n}\n\n# Update version in arty.yml\nupdate_version() {\n    local new_version=&quot;$1&quot;\n    local config=&quot;${2:-$WHIP_CONFIG}&quot;\n    \n    if [[ ! -f &quot;$config&quot; ]]; then\n        log_error &quot;Config file not found: $config&quot;\n        return 1\n    fi\n    \n    yq eval &quot;.version = \\&quot;$new_version\\&quot;&quot; -i &quot;$config&quot;\n    log_success &quot;Updated version to $new_version in $config&quot;\n}\n\n# Parse semver components\nparse_version() {\n    local version=&quot;$1&quot;\n    local -n major_ref=$2\n    local -n minor_ref=$3\n    local -n patch_ref=$4\n    \n    # Remove &#39;v&#39; prefix if present\n    version=&quot;${version#v}&quot;\n    \n    if [[ &quot;$version&quot; =~ ^([0-9]+)\\.([0-9]+)\\.([0-9]+)$ ]]; then\n        major_ref=&quot;${BASH_REMATCH[1]}&quot;\n        minor_ref=&quot;${BASH_REMATCH[2]}&quot;\n        patch_ref=&quot;${BASH_REMATCH[3]}&quot;\n        return 0\n    else\n        return 1\n    fi\n}\n\n# Bump version (major, minor, or patch)\nbump_version() {\n    local bump_type=&quot;$1&quot;\n    local config=&quot;${2:-$WHIP_CONFIG}&quot;\n    \n    local current_version=$(get_current_version &quot;$config&quot;)\n    local major minor patch\n    \n    if ! parse_version &quot;$current_version&quot; major minor patch; then\n        log_error &quot;Invalid version format: $current_version&quot;\n        return 1\n    fi\n    \n    case &quot;$bump_type&quot; in\n        major)\n            major=$((major + 1))\n            minor=0\n            patch=0\n            ;;\n        minor)\n            minor=$((minor + 1))\n            patch=0\n            ;;\n        patch)\n            patch=$((patch + 1))\n            ;;\n        *)\n            log_error &quot;Invalid bump type: $bump_type (use major, minor, or patch)&quot;\n            return 1\n            ;;\n    esac\n    \n    local new_version=&quot;${major}.${minor}.${patch}&quot;\n    echo &quot;$new_version&quot;\n}\n\n# Generate changelog from git commits\ngenerate_changelog() {\n    local from_tag=&quot;${1:-}&quot;\n    local to_ref=&quot;${2:-HEAD}&quot;\n    local title=&quot;${3:-Changelog}&quot;\n    \n    local range\n    if [[ -z &quot;$from_tag&quot; ]]; then\n        # Get all commits if no from_tag\n        range=&quot;$to_ref&quot;\n    else\n        range=&quot;${from_tag}..${to_ref}&quot;\n    fi\n    \n    echo &quot;# $title&quot;\n    echo &quot;&quot;\n    echo &quot;## Changes&quot;\n    echo &quot;&quot;\n    \n    git log &quot;$range&quot; --pretty=format:&quot;- %s (%h)&quot; --reverse 2&gt;/dev/null || {\n        echo &quot;- Initial release&quot;\n    }\n    echo &quot;&quot;\n}\n\n# Update CHANGELOG.md file\nupdate_changelog_file() {\n    local new_version=&quot;$1&quot;\n    local changelog_file=&quot;${2:-$WHIP_CHANGELOG}&quot;\n    \n    local previous_tag=$(git describe --tags --abbrev=0 2&gt;/dev/null || echo &quot;&quot;)\n    local date=$(date +%Y-%m-%d)\n    \n    local temp_file=$(mktemp)\n    \n    # Generate new version section\n    {\n        echo &quot;# Changelog&quot;\n        echo &quot;&quot;\n        echo &quot;## [$new_version] - $date&quot;\n        echo &quot;&quot;\n        \n        if [[ -n &quot;$previous_tag&quot; ]]; then\n            git log &quot;${previous_tag}..HEAD&quot; --pretty=format:&quot;- %s&quot; --reverse\n        else\n            echo &quot;- Initial release&quot;\n        fi\n        echo &quot;&quot;\n        echo &quot;&quot;\n        \n        # Append existing changelog if it exists\n        if [[ -f &quot;$changelog_file&quot; ]]; then\n            # Skip the first &quot;# Changelog&quot; line and empty lines\n            tail -n +2 &quot;$changelog_file&quot; | sed &#39;/^$/d; 1s/^//&#39;\n        fi\n    } &gt; &quot;$temp_file&quot;\n    \n    mv &quot;$temp_file&quot; &quot;$changelog_file&quot;\n    log_success &quot;Updated $changelog_file&quot;\n}\n\n# Create and push git tag\ncreate_release_tag() {\n    local version=&quot;$1&quot;\n    local message=&quot;${2:-Release version $version}&quot;\n    local push=&quot;${3:-true}&quot;\n    \n    local tag=&quot;v${version}&quot;\n    \n    # Check if tag already exists\n    if git rev-parse &quot;$tag&quot; &gt;/dev/null 2&gt;&amp;1; then\n        log_warn &quot;Tag $tag already exists&quot;\n        return 1\n    fi\n    \n    # Create annotated tag\n    git tag -a &quot;$tag&quot; -m &quot;$message&quot;\n    log_success &quot;Created tag: $tag&quot;\n    \n    # Push tag if requested\n    if [[ &quot;$push&quot; == &quot;true&quot; ]]; then\n        git push origin &quot;$tag&quot;\n        log_success &quot;Pushed tag: $tag&quot;\n    fi\n}\n\n# Full release workflow\nrelease() {\n    local bump_type=&quot;${1:-patch}&quot;\n    local config=&quot;${2:-$WHIP_CONFIG}&quot;\n    local push=&quot;${3:-true}&quot;\n    \n    check_dependencies\n    \n    # Check if we&#39;re in a git repository\n    if ! git rev-parse --git-dir &gt; /dev/null 2&gt;&amp;1; then\n        log_error &quot;Not a git repository&quot;\n        return 1\n    fi\n    \n    # Check for uncommitted changes\n    if [[ -n $(git status --porcelain) ]]; then\n        log_warn &quot;You have uncommitted changes&quot;\n        read -p &quot;Continue anyway? [y/N] &quot; -n 1 -r\n        echo\n        if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n            log_info &quot;Release cancelled&quot;\n            return 1\n        fi\n    fi\n    \n    log_step &quot;Starting release process&quot;\n    \n    # Bump version\n    local new_version=$(bump_version &quot;$bump_type&quot; &quot;$config&quot;)\n    log_info &quot;New version: $new_version&quot;\n    \n    # Update version in config\n    update_version &quot;$new_version&quot; &quot;$config&quot;\n    \n    # Update changelog\n    update_changelog_file &quot;$new_version&quot;\n    \n    # Commit changes\n    git add &quot;$config&quot; &quot;$WHIP_CHANGELOG&quot;\n    git commit -m &quot;chore: release version $new_version&quot;\n    log_success &quot;Committed version changes&quot;\n    \n    # Create and push tag\n    create_release_tag &quot;$new_version&quot; &quot;Release version $new_version&quot; &quot;$push&quot;\n    \n    # Push commits if requested\n    if [[ &quot;$push&quot; == &quot;true&quot; ]]; then\n        git push\n        log_success &quot;Pushed commits&quot;\n    fi\n    \n    log_success &quot;Release $new_version completed successfully!&quot;\n}\n\n# Install git hooks\ninstall_hooks() {\n    local hooks_source_dir=&quot;${1:-$WHIP_HOOKS_DIR}&quot;\n    local git_hooks_dir=&quot;.git/hooks&quot;\n    \n    if [[ ! -d &quot;$git_hooks_dir&quot; ]]; then\n        log_error &quot;Not a git repository&quot;\n        return 1\n    fi\n    \n    if [[ ! -d &quot;$hooks_source_dir&quot; ]]; then\n        log_warn &quot;Hooks directory not found: $hooks_source_dir&quot;\n        log_info &quot;Creating default hooks directory...&quot;\n        mkdir -p &quot;$hooks_source_dir&quot;\n        create_default_hooks &quot;$hooks_source_dir&quot;\n    fi\n    \n    log_step &quot;Installing git hooks from $hooks_source_dir&quot;\n    \n    local installed=0\n    for hook_file in &quot;$hooks_source_dir&quot;/*; do\n        if [[ -f &quot;$hook_file&quot; ]]; then\n            local hook_name=$(basename &quot;$hook_file&quot;)\n            local target=&quot;$git_hooks_dir/$hook_name&quot;\n            \n            cp &quot;$hook_file&quot; &quot;$target&quot;\n            chmod +x &quot;$target&quot;\n            log_success &quot;Installed: $hook_name&quot;\n            installed=$((installed + 1))\n        fi\n    done\n    \n    if [[ $installed -eq 0 ]]; then\n        log_warn &quot;No hooks found in $hooks_source_dir&quot;\n    else\n        log_success &quot;Installed $installed hook(s)&quot;\n    fi\n}\n\n# Create default hooks with validation\ncreate_default_hooks() {\n    local hooks_dir=&quot;$1&quot;\n    \n    mkdir -p &quot;$hooks_dir&quot;\n    \n    # Pre-commit hook with shellcheck and bash -n validation\n    cat &gt; &quot;$hooks_dir/pre-commit&quot; &lt;&lt; &#39;EOF&#39;\n#!/usr/bin/env bash\n# Pre-commit hook: validates bash scripts\n\nset -e\n\necho &quot;Running pre-commit checks...&quot;\n\n# Find all staged .sh files\nstaged_files=$(git diff --cached --name-only --diff-filter=ACM | grep &#39;\\.sh$&#39; || true)\n\nif [[ -z &quot;$staged_files&quot; ]]; then\n    echo &quot;No shell scripts to check&quot;\n    exit 0\nfi\n\nerrors=0\n\n# Check each file\nfor file in $staged_files; do\n    if [[ ! -f &quot;$file&quot; ]]; then\n        continue\n    fi\n    \n    echo &quot;Checking: $file&quot;\n    \n    # Bash syntax check\n    if ! bash -n &quot;$file&quot; 2&gt;&amp;1; then\n        echo &quot;ERROR: Syntax error in $file&quot;\n        errors=$((errors + 1))\n    fi\n    \n    # ShellCheck if available\n    if command -v shellcheck &amp;&gt; /dev/null; then\n        if ! shellcheck &quot;$file&quot; 2&gt;&amp;1; then\n            echo &quot;WARNING: ShellCheck found issues in $file&quot;\n            # Don&#39;t fail on shellcheck warnings, just inform\n        fi\n    fi\ndone\n\nif [[ $errors -gt 0 ]]; then\n    echo &quot;ERROR: $errors file(s) with syntax errors&quot;\n    echo &quot;Please fix the errors before committing&quot;\n    exit 1\nfi\n\necho &quot;Pre-commit checks passed!&quot;\nexit 0\nEOF\n    \n    chmod +x &quot;$hooks_dir/pre-commit&quot;\n    log_success &quot;Created default pre-commit hook&quot;\n}\n\n# Uninstall git hooks\nuninstall_hooks() {\n    local git_hooks_dir=&quot;.git/hooks&quot;\n    \n    if [[ ! -d &quot;$git_hooks_dir&quot; ]]; then\n        log_error &quot;Not a git repository&quot;\n        return 1\n    fi\n    \n    log_step &quot;Removing git hooks&quot;\n    \n    # Remove hooks that were installed by whip\n    local hooks=(&quot;pre-commit&quot; &quot;pre-push&quot; &quot;commit-msg&quot;)\n    local removed=0\n    \n    for hook in &quot;${hooks[@]}&quot;; do\n        local hook_file=&quot;$git_hooks_dir/$hook&quot;\n        if [[ -f &quot;$hook_file&quot; ]]; then\n            rm &quot;$hook_file&quot;\n            log_success &quot;Removed: $hook&quot;\n            removed=$((removed + 1))\n        fi\n    done\n    \n    if [[ $removed -eq 0 ]]; then\n        log_info &quot;No hooks to remove&quot;\n    else\n        log_success &quot;Removed $removed hook(s)&quot;\n    fi\n}\n\n# Find arty.yml projects in subdirectories\nfind_arty_projects() {\n    local root_dir=&quot;${1:-.}&quot;\n    local pattern=&quot;${2:-*}&quot;\n    \n    find &quot;$root_dir&quot; -maxdepth 2 -type f -name &quot;arty.yml&quot; | while read -r config; do\n        local project_dir=$(dirname &quot;$config&quot;)\n        local project_name=$(basename &quot;$project_dir&quot;)\n        \n        # Apply glob pattern filter\n        if [[ &quot;$project_name&quot; == $pattern ]]; then\n            echo &quot;$project_dir&quot;\n        fi\n    done\n}\n\n# Execute bash command on monorepo projects\nmonorepo_exec() {\n    local bash_cmd=&quot;$1&quot;\n    local root_dir=&quot;${2:-.}&quot;\n    local pattern=&quot;${3:-*}&quot;\n    \n    if [[ -z &quot;$bash_cmd&quot; ]]; then\n        log_error &quot;Command required&quot;\n        return 1\n    fi\n    \n    log_step &quot;Scanning for arty.yml projects in $root_dir&quot;\n    \n    local projects=()\n    while IFS= read -r project_dir; do\n        projects+=(&quot;$project_dir&quot;)\n    done &lt; &lt;(find_arty_projects &quot;$root_dir&quot; &quot;$pattern&quot;)\n    \n    if [[ ${#projects[@]} -eq 0 ]]; then\n        log_warn &quot;No arty.yml projects found matching pattern: $pattern&quot;\n        return 1\n    fi\n    \n    log_info &quot;Found ${#projects[@]} project(s)&quot;\n    log_info &quot;Executing: $bash_cmd&quot;\n    echo\n    \n    local failed=0\n    for project_dir in &quot;${projects[@]}&quot;; do\n        local project_name=$(basename &quot;$project_dir&quot;)\n        echo -e &quot;${CYAN}━━━ $project_name ━━━${NC}&quot;\n        \n        (\n            # Export variables for use in command\n            export WHIP_PROJECT_DIR=&quot;$project_dir&quot;\n            export WHIP_PROJECT_NAME=&quot;$project_name&quot;\n            \n            cd &quot;$project_dir&quot; || exit 1\n            \n            # Execute the bash command\n            eval &quot;$bash_cmd&quot;\n        ) || {\n            log_error &quot;Failed for $project_name&quot;\n            failed=$((failed + 1))\n        }\n        \n        echo\n    done\n    \n    if [[ $failed -gt 0 ]]; then\n        log_warn &quot;$failed project(s) failed&quot;\n        return 1\n    else\n        log_success &quot;All projects processed successfully&quot;\n    fi\n}\n\n# Batch operation on monorepo projects\nmonorepo_batch() {\n    local command=&quot;$1&quot;\n    local root_dir=&quot;${2:-.}&quot;\n    local pattern=&quot;${3:-*}&quot;\n    \n    log_step &quot;Scanning for arty.yml projects in $root_dir&quot;\n    \n    local projects=()\n    while IFS= read -r project_dir; do\n        projects+=(&quot;$project_dir&quot;)\n    done &lt; &lt;(find_arty_projects &quot;$root_dir&quot; &quot;$pattern&quot;)\n    \n    if [[ ${#projects[@]} -eq 0 ]]; then\n        log_warn &quot;No arty.yml projects found matching pattern: $pattern&quot;\n        return 1\n    fi\n    \n    log_info &quot;Found ${#projects[@]} project(s)&quot;\n    echo\n    \n    local failed=0\n    for project_dir in &quot;${projects[@]}&quot;; do\n        local project_name=$(basename &quot;$project_dir&quot;)\n        echo -e &quot;${CYAN}━━━ Processing: $project_name ━━━${NC}&quot;\n        \n        (\n            cd &quot;$project_dir&quot;\n            \n            case &quot;$command&quot; in\n                version)\n                    local version=$(get_current_version)\n                    echo &quot;Version: $version&quot;\n                    ;;\n                bump)\n                    local bump_type=&quot;${4:-patch}&quot;\n                    local new_version=$(bump_version &quot;$bump_type&quot;)\n                    update_version &quot;$new_version&quot;\n                    echo &quot;Bumped to: $new_version&quot;\n                    ;;\n                status)\n                    if git rev-parse --git-dir &gt; /dev/null 2&gt;&amp;1; then\n                        git status --short\n                    else\n                        echo &quot;Not a git repository&quot;\n                    fi\n                    ;;\n                *)\n                    log_error &quot;Unknown command: $command&quot;\n                    return 1\n                    ;;\n            esac\n        ) || {\n            log_error &quot;Failed for $project_name&quot;\n            failed=$((failed + 1))\n        }\n        \n        echo\n    done\n    \n    if [[ $failed -gt 0 ]]; then\n        log_warn &quot;$failed project(s) failed&quot;\n        return 1\n    else\n        log_success &quot;All projects processed successfully&quot;\n    fi\n}\n\n# Show comprehensive mono help\nshow_mono_help() {\n    cat &lt;&lt; &#39;EOF&#39;\nwhip.sh mono - Monorepo management commands\n\nUSAGE:\n    whip mono &lt;subcommand&gt; [options] [pattern]\n\nSUBCOMMANDS:\n    list [root] [pattern]              List all arty.yml projects\n    version [root] [pattern]           Show version of all projects  \n    bump &lt;type&gt; [root] [pattern]       Bump version (major|minor|patch)\n    status [root] [pattern]            Show git status for all projects\n    exec &lt;command&gt; [root] [pattern]    Execute bash command on all projects\n    help                               Show this help message\n\nARGUMENTS:\n    root        Root directory to search (default: current directory)\n    pattern     Glob pattern to filter projects (default: *)\n    type        Version bump type: major, minor, or patch\n    command     Bash command or script to execute\n\nAVAILABLE VARIABLES (in exec):\n    $WHIP_PROJECT_DIR     Full path to project directory\n    $WHIP_PROJECT_NAME    Project name (basename)\n    $PWD                  Current directory (already cd&#39;d into project)\n\nEXAMPLES:\n\n  Basic Operations:\n    whip mono list                    # List all projects in current dir\n    whip mono list ../monorepo        # List projects in specific dir\n    whip mono list . &quot;lib-*&quot;          # List only lib-* projects\n    whip mono version                 # Show all project versions\n    whip mono status                  # Git status for all projects\n\n  Version Management:\n    whip mono bump patch              # Bump patch version for all\n    whip mono bump minor &quot;lib-*&quot;      # Bump minor for lib-* projects\n    whip mono bump major . &quot;*-core&quot;   # Bump major for *-core projects\n\n  Executing Commands:\n    # Simple commands\n    whip mono exec &quot;pwd&quot;\n    whip mono exec &quot;echo \\$WHIP_PROJECT_NAME&quot;\n    whip mono exec &quot;git status&quot;\n    \n    # Using project variables\n    whip mono exec &#39;echo &quot;Project: $WHIP_PROJECT_NAME at $WHIP_PROJECT_DIR&quot;&#39;\n    \n    # Multi-line commands (use quotes)\n    whip mono exec &#39;git add . &amp;&amp; git commit -m &quot;chore: update&quot; &amp;&amp; git push&#39;\n    \n    # Conditional execution\n    whip mono exec &#39;if [[ -f package.json ]]; then npm install; fi&#39;\n    \n    # Complex operations\n    whip mono exec &#39;\n        echo &quot;Cleaning $WHIP_PROJECT_NAME...&quot;\n        rm -rf node_modules dist\n        echo &quot;Building...&quot;\n        npm run build\n    &#39;\n    \n    # With pattern filtering\n    whip mono exec &quot;npm test&quot; . &quot;lib-*&quot;\n    whip mono exec &quot;make clean &amp;&amp; make&quot; . &quot;*-service&quot;\n\n  Real-World Scenarios:\n    # Commit and push all projects\n    whip mono exec &#39;git add . &amp;&amp; git commit -m &quot;chore: streamline&quot; &amp;&amp; git push origin main&#39;\n    \n    # Update dependencies\n    whip mono exec &#39;arty deps&#39;\n    \n    # Run tests\n    whip mono exec &#39;bash test.sh&#39;\n    \n    # Create git tags\n    whip mono exec &#39;git tag -a v1.0.0 -m &quot;Release 1.0.0&quot; &amp;&amp; git push --tags&#39;\n    \n    # Check for uncommitted changes\n    whip mono exec &#39;[[ -n $(git status --porcelain) ]] &amp;&amp; echo &quot;Has changes&quot; || echo &quot;Clean&quot;&#39;\n    \n    # Generate documentation\n    whip mono exec &#39;leaf.sh . &amp;&amp; echo &quot;Docs generated&quot;&#39;\n    \n    # Sync with remote\n    whip mono exec &#39;git fetch &amp;&amp; git pull origin main&#39;\n\nPATTERN MATCHING:\n    Glob patterns filter which projects to process:\n    \n    *           All projects (default)\n    lib-*       Projects starting with &quot;lib-&quot;\n    *-core      Projects ending with &quot;-core&quot;\n    app-*       Projects starting with &quot;app-&quot;\n    *-service   Projects ending with &quot;-service&quot;\n    test-*      Projects starting with &quot;test-&quot;\n\nPROJECT DISCOVERY:\n    whip searches for arty.yml files up to 2 levels deep:\n    \n    monorepo/\n    ├── lib-core/\n    │   └── arty.yml          ✓ Found\n    ├── services/\n    │   ├── api-service/\n    │   │   └── arty.yml      ✓ Found\n    │   └── web-service/\n    │       └── arty.yml      ✓ Found\n    └── tools/\n        └── deep/\n            └── nested/\n                └── arty.yml  ✗ Too deep (&gt;2 levels)\n\nERROR HANDLING:\n    - Individual project failures don&#39;t stop the batch\n    - Failed projects are reported at the end\n    - Exit code reflects overall success/failure\n    - Use -e in commands for strict error handling\n\nTIPS:\n    - Quote commands with special characters\n    - Use single quotes to prevent variable expansion\n    - Test commands on one project first\n    - Use pattern matching to limit scope\n    - Check for uncommitted changes before operations\n    - Combine with other whip commands for workflows\n\nSEE ALSO:\n    whip --help              Main help\n    whip release --help      Release workflow help\n    whip hooks --help        Git hooks help\n\nEOF\n}\n\n# Show usage\nshow_usage() {\n    cat &lt;&lt; &#39;EOF&#39;\nwhip.sh - Release cycle management for arty.sh projects\n\nUSAGE:\n    whip &lt;command&gt; [options]\n\nRELEASE COMMANDS:\n    release [major|minor|patch]   Full release workflow (default: patch)\n                                  - Bumps version in arty.yml\n                                  - Updates CHANGELOG.md from git history\n                                  - Creates git commit\n                                  - Creates and pushes git tag\n    \n    version                       Show current version from arty.yml\n    bump &lt;major|minor|patch&gt;      Bump version in arty.yml (no commit/tag)\n    changelog                     Generate changelog from git history\n    tag &lt;version&gt;                 Create and push git tag\n\nHOOK COMMANDS:\n    hooks install                 Install git commit hooks\n                                  - Includes shellcheck validation\n                                  - Includes bash -n syntax check\n    hooks uninstall              Remove git commit hooks\n    hooks create                 Create default hook templates\n\nMONOREPO COMMANDS:\n    mono list [root] [pattern]          List arty.yml projects\n    mono version [root] [pattern]       Show versions of all projects\n    mono bump &lt;type&gt; [root] [pattern]   Bump version for all projects\n    mono status [root] [pattern]        Show git status for all projects\n    mono exec &lt;cmd&gt; [root] [pattern]    Execute bash command on all projects\n    mono help                           Show detailed mono help\n\nOPTIONS:\n    --no-push                    Don&#39;t push commits/tags (for release)\n    --config &lt;file&gt;              Use custom config file (default: arty.yml)\n    --changelog &lt;file&gt;           Use custom changelog file (default: CHANGELOG.md)\n    -h, --help                   Show this help message\n\nEXAMPLES:\n    # Full release workflow (patch)\n    whip release\n\n    # Major version release\n    whip release major\n\n    # Just bump version without release\n    whip bump minor\n\n    # Install commit hooks\n    whip hooks install\n\n    # Monorepo: list all projects\n    whip mono list\n\n    # Monorepo: bump patch version for all projects matching &quot;lib-*&quot;\n    whip mono bump patch . &quot;lib-*&quot;\n\n    # Monorepo: execute command on all projects\n    whip mono exec &quot;git status&quot;\n    whip mono exec &#39;git add . &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push&#39; . &quot;lib-*&quot;\n\n    # Release without pushing\n    whip release --no-push\n\n    # Get detailed monorepo help\n    whip mono help\n\nHOOKS:\n    whip installs pluggable git hooks for code quality:\n    \n    pre-commit:\n    - Validates bash syntax with &#39;bash -n&#39;\n    - Runs shellcheck if available\n    - Prevents commits with syntax errors\n\n    Custom hooks can be added to .whip/hooks/\n\nMONOREPO SUPPORT:\n    whip can manage multiple arty.yml projects in a monorepo structure:\n    \n    monorepo/\n    ├── lib-core/\n    │   └── arty.yml\n    ├── lib-utils/\n    │   └── arty.yml\n    └── app-main/\n        └── arty.yml\n    \n    Use glob patterns to filter projects:\n    - &quot;lib-*&quot;    Match all projects starting with &quot;lib-&quot;\n    - &quot;*-core&quot;   Match all projects ending with &quot;-core&quot;\n    - &quot;*&quot;        Match all projects (default)\n    \n    Execute arbitrary bash commands:\n    - Access project info via $WHIP_PROJECT_NAME and $WHIP_PROJECT_DIR\n    - Commands run in project directory (already cd&#39;d)\n    - Quote commands with special characters\n\nEOF\n}\n\n# Main function\nmain() {\n    if [[ $# -eq 0 ]]; then\n        show_usage\n        exit 0\n    fi\n    \n    # Parse global options\n    local push=true\n    local config=&quot;$WHIP_CONFIG&quot;\n    local changelog=&quot;$WHIP_CHANGELOG&quot;\n    \n    while [[ $# -gt 0 ]]; do\n        case $1 in\n            --no-push)\n                push=false\n                shift\n                ;;\n            --config)\n                config=&quot;$2&quot;\n                WHIP_CONFIG=&quot;$config&quot;\n                shift 2\n                ;;\n            --changelog)\n                changelog=&quot;$2&quot;\n                WHIP_CHANGELOG=&quot;$changelog&quot;\n                shift 2\n                ;;\n            -h|--help)\n                show_usage\n                exit 0\n                ;;\n            *)\n                break\n                ;;\n        esac\n    done\n    \n    if [[ $# -eq 0 ]]; then\n        show_usage\n        exit 0\n    fi\n    \n    local command=&quot;$1&quot;\n    shift\n    \n    case &quot;$command&quot; in\n        release)\n            local bump_type=&quot;${1:-patch}&quot;\n            release &quot;$bump_type&quot; &quot;$config&quot; &quot;$push&quot;\n            ;;\n        version)\n            get_current_version &quot;$config&quot;\n            ;;\n        bump)\n            if [[ $# -eq 0 ]]; then\n                log_error &quot;Bump type required (major, minor, or patch)&quot;\n                exit 1\n            fi\n            local new_version=$(bump_version &quot;$1&quot; &quot;$config&quot;)\n            update_version &quot;$new_version&quot; &quot;$config&quot;\n            echo &quot;$new_version&quot;\n            ;;\n        changelog)\n            generate_changelog &quot;${1:-}&quot; &quot;${2:-HEAD}&quot;\n            ;;\n        tag)\n            if [[ $# -eq 0 ]]; then\n                log_error &quot;Version required&quot;\n                exit 1\n            fi\n            create_release_tag &quot;$1&quot; &quot;${2:-Release version $1}&quot; &quot;$push&quot;\n            ;;\n        hooks)\n            if [[ $# -eq 0 ]]; then\n                log_error &quot;Hooks subcommand required (install, uninstall, create)&quot;\n                exit 1\n            fi\n            local subcommand=&quot;$1&quot;\n            shift\n            case &quot;$subcommand&quot; in\n                install)\n                    install_hooks &quot;${1:-$WHIP_HOOKS_DIR}&quot;\n                    ;;\n                uninstall)\n                    uninstall_hooks\n                    ;;\n                create)\n                    create_default_hooks &quot;${1:-$WHIP_HOOKS_DIR}&quot;\n                    ;;\n                *)\n                    log_error &quot;Unknown hooks subcommand: $subcommand&quot;\n                    exit 1\n                    ;;\n            esac\n            ;;\n        mono|monorepo)\n            if [[ $# -eq 0 ]]; then\n                log_error &quot;Monorepo subcommand required&quot;\n                show_mono_help\n                exit 1\n            fi\n            local subcommand=&quot;$1&quot;\n            shift\n            case &quot;$subcommand&quot; in\n                help|--help|-h)\n                    show_mono_help\n                    ;;\n                list)\n                    find_arty_projects &quot;${1:-.}&quot; &quot;${2:-*}&quot;\n                    ;;\n                version|bump|status)\n                    monorepo_batch &quot;$subcommand&quot; &quot;${1:-.}&quot; &quot;${2:-*}&quot; &quot;${3:-}&quot;\n                    ;;\n                exec)\n                    if [[ $# -eq 0 ]]; then\n                        log_error &quot;Command required for exec&quot;\n                        echo &quot;Usage: whip mono exec &lt;command&gt; [root] [pattern]&quot;\n                        echo &quot;Example: whip mono exec &#39;git status&#39; . &#39;lib-*&#39;&quot;\n                        exit 1\n                    fi\n                    local cmd=&quot;$1&quot;\n                    shift\n                    monorepo_exec &quot;$cmd&quot; &quot;${1:-.}&quot; &quot;${2:-*}&quot;\n                    ;;\n                *)\n                    log_error &quot;Unknown monorepo subcommand: $subcommand&quot;\n                    echo &quot;Run &#39;whip mono help&#39; for detailed usage&quot;\n                    exit 1\n                    ;;\n            esac\n            ;;\n        *)\n            log_error &quot;Unknown command: $command&quot;\n            show_usage\n            exit 1\n            ;;\n    esac\n}\n\n# Run main if executed directly\nif [[ &quot;${BASH_SOURCE[0]}&quot; == &quot;${0}&quot; ]]; then\n    main &quot;$@&quot;\nfi</code></pre></div></div>",
  "examples_html": "<p class=\"text-center text-slate-600\">No examples found.</p>",
  "myst_enabled": "true"
}
